<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÏàèÏ∏† ÏûêÎèôÌôî ÌîÑÎ°úÍ∑∏Îû® - UI</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Face-api.js for real face detection -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #d3d9e2 0%, #a8b4c2 100%);
            --panel-bg: rgba(255, 255, 255, 0.95);
            --text-primary: #1a202c;
            --text-secondary: #4a5568;
            --border-color: #e2e8f0;
            --accent-color: #667eea;
            --accent-hover: #5a67d8;
            --card-bg: rgb(225, 231, 235);
            --card-border: #e2e8f0;
            --download-bg: #28a745;
            --download-hover-bg: #218838;
            --upload-bg: #f8f9ff;
            --upload-border: #667eea;
            --upload-hover-bg: #f0f2ff;
            --upload-hover-border: #764ba2;
            --btn-disabled-bg: #ccc;
            --success-bg: #d4edda;
            --success-text: #155724;
            --success-border: #2f4434;
            --error-bg: #bfc9c7;
            --error-text: #721c24;
            --error-border: #cfe3e3;
            --input-bg: rgb(209, 225, 224);
            --input-border: #ddd;
        }

        body.dark-mode {
            --bg-gradient: linear-gradient(135deg, #08282f 0%, #1a2a2f 100%);
            --panel-bg: rgba(30, 45, 50, 0.95);
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --border-color: #405560;
            --accent-color: #00897b;
            --accent-hover: #00695c;
            --card-bg: #2c3e50;
            --card-border: #405560;
            --download-bg: #388e3c;
            --download-hover-bg: #2e7d32;
            --upload-bg: #2a3f34;
            --upload-border: #26a69a;
            --upload-hover-bg: #37454f;
            --btn-disabled-bg: #555;
            --success-bg: #2e7d32;
            --success-text: #e0e0e0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            padding: 1rem;
            color: var(--text-primary);
            transition: background 0.3s ease;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 7fr 3fr; /* 7:3 ÎπÑÏú®Î°ú Ï°∞Ï†ï */
            gap: 2rem;
        }

        .left-panel, .right-panel {
            background: var(--panel-bg);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .resizer {
            background-color: rgba(0,0,0,0.1);
            cursor: col-resize;
            width: 10px;
            border-radius: 5px;
            transition: background-color 0.2s;
        }

        .resizer:hover, .resizer.active {
            background-color: #667eea;
        }

        .header {
            text-align: center;
            margin-bottom: 0.5rem;
            position: relative;
        }

        .title-box {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 0.8rem 1.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        body.dark-mode .title-box {
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .header .title-box {
            display: inline-block;
            text-align: center;
            padding: 0.8rem 1.5rem;
        }
        
        .left-panel .title-box,
        .right-panel .title-box {
            margin-bottom: 1.5rem;
        }

        .right-panel .title-box {
            align-self: center;
            text-align: center;
        }

        .title-box > * {
            margin: 0;
            padding: 0;
        }

        .title-box h1 {
            font-size: 1.5rem;
            margin: 0;
        }
        
        .title-box p {
            color: var(--text-secondary);
        }

        .header-actions {
            position: absolute;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-logo {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-60%); /* Adjusted from -50% to move it up */
            height: 77px; /* Reduced from 96px (approx 20% reduction) */
            width: auto;
        }

        #theme-toggle {
            position: static;
            flex-shrink: 0;
            background: none;
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        #theme-toggle:hover {
            border-color: var(--accent-color);
            color: var(--accent-color);
            transform: rotate(15deg);
        }

        .upload-section {
            background: #000;
            border: none;
            aspect-ratio: 16 / 9;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-section:hover {
            transform: scale(1.01);
            background: #111;
        }

        .upload-section.dragover {
            background: #222;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4rem;
            color: white;
            margin-bottom: 1rem;
        }

        .upload-section h3 {
            color: white;
        }
        
        .upload-section p {
            color: #ccc;
        }

        .file-input {
            display: none;
        }

        .file-info {
            background: var(--success-bg);
            color: var(--success-text);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
            display: none;
        }

        .options-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .option-group {
            background: var(--upload-bg);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .option-group:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.08);
        }

        .option-group h3 {
            color: var(--text-primary);
            margin-top: 0;
            margin-bottom: 1.2rem;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-color);
        }

        .platform-selection {
            /* Override theme variables for this section to mimic dark mode */
            --card-bg: #2c3e50;
            --card-border: #405560;
            --text-primary: #e0e0e0;
            --accent-color: #00897b;

            background: #2a3f34;
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .platform-selection h3 {
            color: var(--text-primary);
            margin-top: 0;
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
        }

        .platform-grid {
            display: flex;
            align-items: stretch;
            justify-content: space-between;
            flex-wrap: nowrap;
            gap: 1.5rem;
            width: 100%;
        }

        .platform-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap; /* Ï∞Ω ÌÅ¨Í∏∞Í∞Ä Ï§ÑÏñ¥Îì§Î©¥ Ï§ÑÎ∞îÍøà ÎêòÎèÑÎ°ù */
            align-items: center;
        }

        .llm-group {
            padding-left: 1.5rem;
            border-left: 1px solid var(--card-border);
        }

        .llm-card {
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 10px;
            padding: 0.75rem 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .llm-card:hover {
            border-color: var(--accent-color);
            transform: translateY(-2px);
        }

        .llm-card.selected {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .platform-empty-space {
            display: none; /* Ïù¥Ï†ú ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå */
        }

        .platform-card {
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 10px;
            padding: 0.75rem 0.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            max-width: 120px;
            font-size: 0.8rem;
            color: var(--text-primary); /* Use variable for text color */
        }

        .platform-card:hover {
            border-color: var(--accent-color);
            transform: translateY(-2px);
        }

        .platform-card.selected {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .platform-icon {
            font-size: 1.8rem;
            margin-bottom: 0.25rem;
        }

        .process-section {
            text-align: center;
        }

        .process-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 1rem 3rem;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .process-btn:hover {
            transform: translateY(-3px);
            background: var(--accent-hover);
            box-shadow: 0 15px 30px rgba(102, 126, 234, 0.4);
        }

        .process-btn:disabled {
            background: var(--btn-disabled-bg);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress-section {
            margin-top: 2rem;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: var(--border-color);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-color);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status-text {
            text-align: center;
            color: var(--text-secondary);
            font-weight: 600;
        }

        /* Ïò§Î•∏Ï™Ω Ìå®ÎÑê Ïä§ÌÉÄÏùº */
        .video-preview-section {
            margin-bottom: 2rem;
            display: none; /* Hidden by default */
        }

        .video-preview-section h3 {
            color: var(--text-primary);
            margin-bottom: 1.5rem; /* More space */
            text-align: center;
        }

        .video-container {
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 1rem;
            position: relative;
            width: 100%;
            height: 400px; /* Set a fixed height for the container */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-container video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Show the entire video without cropping */
        }

        .video-placeholder {
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            font-size: 1.2rem;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 1rem;
            aspect-ratio: 9 / 16;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .control-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .control-btn:hover {
            background: var(--accent-hover);
        }

        .control-btn:disabled {
            background: var(--btn-disabled-bg);
            cursor: not-allowed;
        }

        .results-section {
            display: block;
        }

        .results-section h3 {
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .result-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            aspect-ratio: 9 / 16;
            max-width: 240px;
            width: 100%;
            background: var(--upload-bg);
            border: 2px dashed var(--border-color);
            border-radius: 15px;
            color: var(--text-secondary);
            text-align: center;
            padding: 1rem;
            margin: 0 auto;
        }

        .result-video-grid {
            display: grid;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .result-video-item {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 1rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .result-video-item h4 {
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .result-video-container {
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 1rem;
            aspect-ratio: 9 / 16;
            max-width: 240px; /* Set max-width as requested */
            margin-left: auto;
            margin-right: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result-video-container video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Fill the container for 9:16 shorts */
        }

        .result-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        .download-btn {
            background: var(--download-bg);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .download-btn:hover {
            background: var(--download-hover-bg);
        }

        .upload-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .upload-btn:hover {
            background: var(--accent-hover);
        }

        .upload-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .upload-modal.active {
            display: flex;
        }

        .upload-modal-content {
            background: var(--panel-bg);
            border-radius: 15px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
        }

        .upload-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-group label {
            font-weight: 600;
            color: var(--text-primary);
        }

        .form-group input,
        .form-group textarea {
            padding: 0.5rem;
            border: 1px solid var(--input-border);
            border-radius: 5px;
            font-size: 1rem;
            background-color: var(--input-bg);
            color: var(--text-primary);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1rem;
        }

        .modal-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
        }

        .modal-btn.cancel {
            background: #6c757d;
            color: white;
        }

        .modal-btn.upload {
            background: var(--accent-color);
            color: white;
        }

        .status-message {
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
            text-align: center;
            font-weight: 600;
        }

        .status-message.success {
            background: var(--success-bg);
            color: var(--success-text);
            border: 1px solid var(--success-border);
        }

        .status-message.error {
            background: var(--error-bg);
            color: var(--error-text);
            border: 1px solid var(--error-border);
        }

        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
            }
            
            .right-panel {
                order: -1;
            }
        }

        main {
            display: flex;
            flex: 1;
            min-height: 0;
            margin-top: 10px;
        }

        #video-display-section {
            width: 50%; /* Ï¥àÍ∏∞ ÎÑàÎπÑ */
            min-width: 300px;
            display: flex;
            flex-direction: column;
            padding-right: 5px;
            /* border-right ÏÜçÏÑ± Ï†úÍ±∞ */
        }

        #resizer {
            width: 5px;
            cursor: col-resize;
            background-color: var(--border-color);
            flex-shrink: 0;
            transition: background-color 0.2s;
        }
        #resizer:hover {
            background-color: var(--accent-color);
        }

        #video-work-section {
            flex-grow: 1; /* ÎÇ®ÏùÄ Í≥µÍ∞ÑÏùÑ Î™®Îëê Ï∞®ÏßÄ */
            min-width: 300px;
            display: flex;
            flex-direction: column;
            padding-left: 5px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1rem;
        }

        .setting-item:first-of-type {
            margin-top: 0.5rem;
        }

        .setting-item label {
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .setting-input {
            width: 80px;
            padding: 0.5rem;
            border-radius: 5px;
            border: 1px solid var(--input-border);
            text-align: center;
            background-color: var(--input-bg);
            color: var(--text-primary);
        }

        body.dark-mode .setting-input {
            color: #1a202c; /* Dark text for light inputs in dark mode */
        }

        /* Ìè¥Îçî ÏÑ†ÌÉù ÏÉÅÌÉúÎ≥Ñ Ïä§ÌÉÄÏùº */
        .setting-input.folder-selected {
            border-color: #28a745 !important;
            background-color: #d4edda !important;
        }

        .setting-input.folder-not-selected {
            border-color: #ffc107 !important;
            background-color: #fff3cd !important;
        }

        .control-btn.folder-selected {
            background-color: #28a745 !important;
            color: white !important;
            border-color: #28a745 !important;
        }

        .control-btn.folder-not-selected {
            background-color: #ffc107 !important;
            color: #212529 !important;
            border-color: #ffc107 !important;
            animation: pulse-folder 2s infinite;
        }

        @keyframes pulse-folder {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 193, 7, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 193, 7, 0);
            }
        }

        #videoEditorContainer {
            width: 100%;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 2rem;
            /* aspect-ratio Ï†úÍ±∞ */
        }

        #videoPreview {
            width: 100%;
            height: auto;
            max-height: 500px; /* ÎπÑÎîîÏò§ ÏµúÎåÄ ÎÜíÏù¥ Ï†úÌïú Ï∂îÍ∞Ä */
            display: block; /* ÏàòÏßÅ Ï†ïÎ†¨ Î¨∏Ï†ú Î∞©ÏßÄ */
        }

        .short-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.08);
        }

        .short-item .video-container {
            position: relative;
            cursor: pointer;
            aspect-ratio: 9 / 16;
            background-color: #000;
            margin: 0 auto;
            height: auto;
        }

        .short-item video {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: cover;
        }

        .short-item .video-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: rgba(255, 255, 255, 0.7);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .short-item .video-container:hover .video-overlay {
            opacity: 1;
        }

        .short-info {
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--upload-bg);
            gap: 0.5rem;
        }

        .delete-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .delete-btn:hover {
            background-color: #c82333;
        }

        #completedShortsGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(292px, 1fr));
            gap: 1.5rem;
            align-items: start;
            justify-items: center;
        }

        .selection-container {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 2rem;
            align-items: stretch;
        }

        .dark-selection-box {
            --card-bg: #2c3e50;
            --card-border: #405560;
            --text-primary: #e0e0e0;
            --accent-color: #00897b;
            background: #2a3f34;
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
        }

        .selection-container .dark-selection-box:first-child {
            flex: 6;
        }
        
        .selection-container .dark-selection-box:last-child {
            flex: 4;
        }

        .dark-selection-box h3 {
            color: var(--text-primary);
            margin-top: 0;
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
        }

        .short-item {
            border: 1px solid var(--card-border);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }

        .short-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.08);
        }

        .short-item .video-container {
            position: relative;
            cursor: pointer;
            aspect-ratio: 9 / 16;
            background-color: #000;
            margin: 0 auto;
            height: auto;
        }

        .short-item video {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: cover;
        }
        
        .short-item .video-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: rgba(255, 255, 255, 0.7);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .short-item .video-container:hover .video-overlay {
            opacity: 1;
        }

        .short-info {
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--upload-bg);
            gap: 0.5rem;
        }

        /* Face Gallery Styles */
        .face-gallery-container {
            background: var(--upload-bg);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .face-gallery-container h3 {
            color: var(--text-primary);
            margin-top: 0;
            margin-bottom: 1.5rem;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            text-align: center;
            justify-content: center;
        }

        .face-gallery-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .face-gallery-controls .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .face-gallery-controls .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .face-gallery-controls .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .face-gallery-controls .btn-primary {
            background: var(--accent-color);
            color: white;
        }

        .face-gallery-controls .btn-primary:hover {
            background: #007b6d;
            transform: translateY(-2px);
        }

        .face-gallery-controls .btn-success {
            background: #28a745;
            color: white;
        }

        .face-gallery-controls .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        /* ÏûêÎèô Ïã§Ìñâ Ï≤¥ÌÅ¨Î∞ïÏä§ Ïä§ÌÉÄÏùº */
        #autoFaceAnalysis {
            width: 16px;
            height: 16px;
            margin-right: 0.5rem;
            accent-color: var(--accent-color);
            cursor: pointer;
        }

        #autoFaceAnalysis + label {
            cursor: pointer;
            user-select: none;
            transition: color 0.2s ease;
        }

        #autoFaceAnalysis:checked + label {
            color: var(--accent-color);
            font-weight: 500;
        }

        #autoFaceAnalysis + label:hover {
            color: var(--accent-color);
        }

        .analysis-progress {
            margin-bottom: 2rem;
        }

        .analysis-progress .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .analysis-progress .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, var(--accent-color), #007b6d);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .analysis-progress .progress-text {
            text-align: center;
            color: var(--text-primary);
            font-weight: 600;
        }

        .face-results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .face-card {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .face-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
        }

        .face-card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 1rem;
            background: #f8f9fa;
        }

        .face-card h4 {
            color: var(--text-primary);
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        .face-card .face-info {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .face-card .face-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        .face-card .face-actions button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .face-card .btn-edit {
            background: #ffc107;
            color: #212529;
        }

        .face-card .btn-edit:hover {
            background: #e0a800;
        }

        .face-card .btn-upload {
            background: #17a2b8;
            color: white;
        }

        .face-card .btn-upload:hover {
            background: #138496;
        }

        .face-card .btn-delete {
            background: #dc3545;
            color: white;
        }

        .face-card .btn-delete:hover {
            background: #c82333;
        }

        .face-placeholder {
            width: 100%;
            height: 200px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        /* --- Right Panel Chat Styles --- */
        .chat-panel {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            overflow: hidden; /* ÏûêÏãù ÏöîÏÜåÍ∞Ä Î∂ÄÎ™®Î•º ÎÑòÏßÄ ÏïäÎèÑÎ°ù */
            min-height: 0; /* flex-growÍ∞Ä Ï†úÎåÄÎ°ú ÏûëÎèôÌïòÍ∏∞ ÏúÑÌï¥ ÌïÑÏöî */
        }

        .chat-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header h3 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--text-primary);
        }

        #newChatBtn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #newChatBtn:hover {
            background-color: var(--accent-hover);
        }

        .chat-history {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .chat-message {
            display: flex;
            gap: 0.75rem;
            max-width: 85%;
        }

        .chat-message .avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .chat-message .message-content {
            background-color: var(--upload-bg);
            padding: 0.75rem 1rem;
            border-radius: 15px;
            color: var(--text-secondary);
        }
        
        .chat-message .message-content p {
            margin: 0;
            line-height: 1.5;
            white-space: pre-line; /* Ï§ÑÎ∞îÍøà ÏßÄÏõê */
        }

        .user-message {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .user-message .message-content {
            background-color: var(--accent-color);
            color: white;
        }

        .ai-message {
            align-self: flex-start;
        }

        .chat-input-area {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 1rem;
        }

        #chatInput {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-primary);
            resize: none;
            font-family: inherit;
            font-size: 1rem;
        }

        #chatInput:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        #sendChatBtn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 0 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
        }
        
        #sendChatBtn:disabled {
             background: var(--btn-disabled-bg);
             cursor: not-allowed;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 2rem; /* ÏÑπÏÖò ÏÇ¨Ïù¥ Í∞ÑÍ≤© */
        }

        #resultsContainer {
            flex-shrink: 0;
        }

        .selection-container {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 2rem;
            align-items: stretch;
        }

        .dark-selection-box {
            --card-bg: #2c3e50;
            --card-border: #405560;
            --text-primary: #e0e0e0;
            --accent-color: #00897b;
            background: #2a3f34;
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
        }

        .dark-selection-box h3 {
            color: var(--text-primary);
            margin-top: 0;
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
        }

        #completedShortsGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(292px, 1fr));
            gap: 1.5rem;
            align-items: start;
            justify-items: center;
        }

        .ai-model-box {
            justify-content: space-between;
        }
        .ai-model-box .chat-input-area {
            padding: 0;
            border-top: none;
            margin-bottom: 1.5rem;
            display: flex;
            gap: 0.75rem;
        }
        .ai-model-box #chatInput {
            background-color: #ffffff; /* Ìù∞ÏÉâ Î∞∞Í≤Ω */
            color: #000000; /* Í≤ÄÏùÄÏÉâ Ìè∞Ìä∏ */
            border: 1px solid #d1d5db; /* Î∞ùÏùÄ ÌöåÏÉâ ÌÖåÎëêÎ¶¨ */
        }
        .ai-model-box #chatInput::placeholder {
            color: #6b7280; /* Ïñ¥ÎëêÏö¥ ÌöåÏÉâ placeholder */
        }
        .ai-model-box #chatInput:focus {
            border-color: var(--accent-color);
        }
        .ai-model-box #sendChatBtn {
            background-color: var(--accent-color);
            color: white;
            font-weight: normal;
        }

        .ai-model-box .ai-model-container {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            width: 90%;
            margin: 0 auto;
        }
        
        .ai-model-container .setting-input {
            color: #1a202c; /* Í≤ÄÏùÄÏÉâ ÌÖçÏä§Ìä∏ */
            background-color: #ffffff; /* Ìù∞ÏÉâ Î∞∞Í≤Ω */
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            padding: 0.65rem;
            font-size: 0.9rem;
            flex-grow: 1;
        }

        .ai-model-container .setting-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(0, 137, 123, 0.2);
        }

        .ai-model-container .settings-btn {
            background: none;
            border: 1px solid var(--card-border);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
            transition: all 0.2s;
        }

        .ai-model-container .settings-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: var(--accent-color);
        }

        /* --- API Key Modal Styles --- */
        .api-key-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            animation: fadeIn 0.3s;
        }

        .api-key-modal .modal-content {
            background-color: #fefefe;
            color: #1a202c;
            margin: 15% auto;
            padding: 2rem;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            animation: slideIn 0.3s;
        }

        .api-key-modal .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .api-key-modal .close-button:hover,
        .api-key-modal .close-button:focus {
            color: black;
            text-decoration: none;
        }

        .api-key-modal h3 {
            margin-top: 0;
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
        }

        .api-key-modal .form-group {
            margin-bottom: 1.5rem;
        }
        
        .api-key-modal .form-label-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .api-key-modal .form-label-group label {
            font-size: 1rem;
            font-weight: 600;
        }

        .api-key-modal #apiKeyLink {
            font-size: 0.85rem;
            color: #007bff;
            text-decoration: none;
        }

        .api-key-modal #apiKeyLink:hover {
            text-decoration: underline;
        }

        .api-key-modal .form-group-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1rem;
            box-sizing: border-box;
            color: #000000;
        }

        .api-key-modal .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }

        .api-key-modal .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .api-key-modal .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .api-key-modal .btn-secondary:hover {
            background-color: #5a6268;
        }

        .api-key-modal .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .api-key-modal .btn-primary:hover {
            background-color: #0056b3;
        }

        @keyframes fadeIn {
            from {opacity: 0;}
            to {opacity: 1;}
        }

        @keyframes slideIn {
            from {transform: translateY(-50px);}
            to {transform: translateY(0);}
        }

        .left-panel .chat-panel {
            flex: 7;
            margin-bottom: 0;
            max-height: none;
        }

        .chat-area {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 2rem;
            height: 450px;
        }

        .chat-list-panel {
            flex: 3;
            display: flex;
            flex-direction: column;
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            overflow: hidden;
        }

        .chat-list-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .chat-list-header h3 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--text-primary);
        }
        
        #selectAllChats {
             width: 16px;
             height: 16px;
        }

        .chat-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .chat-list-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
            position: relative;
        }
        
        .chat-list-item:hover {
            background-color: var(--upload-bg);
        }

        .chat-list-item.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-hover);
        }

        .chat-list-item input[type="checkbox"] {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
        }

        .chat-list-item-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
            padding-left: 0.5rem; /* Add some space between checkbox and text */
        }
        
        .chat-list-item-title:hover {
            text-decoration: underline;
        }


        .chat-list-actions {
            padding: 0.75rem;
            border-top: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .chat-list-actions button {
            padding: 0.6rem;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            background-color: var(--upload-bg);
            color: var(--text-primary);
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 1rem;
        }

        .chat-list-actions button:hover {
            background-color: var(--border-color);
        }

        .shorts-carousel {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            max-width: 360px; /* Set to desired width */
        }

        .shorts-viewport {
            width: 100%;
            overflow: hidden;
        }

        #shortsTrack {
            display: flex;
            transition: transform 0.3s ease-in-out;
        }

        .carousel-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            cursor: pointer;
            z-index: 10;
            display: none; /* Initially hidden */
        }

        .carousel-btn.prev {
            left: -50px;
        }

        .carousel-btn.next {
            right: -50px;
        }

        .volume-btn {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 16px;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .volume-btn:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        .progress-bar-container {
            width: 90%;
            height: 4px;
            background-color: #ccc;
            cursor: pointer;
            border-radius: 2px;
            margin: 8px auto 4px auto;
        }
        body.dark-mode .progress-bar-container {
             background-color: rgba(255, 255, 255, 0.3);
        }

        .progress-bar-fill {
            height: 100%;
            background-color: var(--accent-color);
            width: 0%;
            border-radius: 2px;
        }

        #shorts-counter {
            text-align: center;
            margin-top: 1rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .short-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            padding: 8px 0;
            background: var(--upload-bg);
        }

        .short-controls button {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            padding: 0;
            line-height: 1;
        }

        .short-controls button:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .short-controls button.active {
            color: var(--accent-color);
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="main-layout">
        <!-- ÏôºÏ™Ω Ìå®ÎÑê: ÏÑ§Ï†ï Î∞è Ïª®Ìä∏Î°§ -->
        <div class="left-panel">
            <div class="header">
                <img src="image/TwinverseLogo.png" alt="Twinverse Logo" class="header-logo">
                <div class="title-box">
                    <h1>üé¨ ÏàèÏ∏† ÏûêÎèôÌôî ÌîÑÎ°úÍ∑∏Îû®</h1>
                </div>
                <div class="header-actions">
                    <button id="loadNewVideoButton" class="upload-btn">ÏÉà ÏòÅÏÉÅ Î∂àÎü¨Ïò§Í∏∞ üìÇ</button>
                    <button id="theme-toggle">üåô</button>
                </div>
            </div>

            <!-- ÌååÏùº ÏóÖÎ°úÎìú ÏÑπÏÖò -->
            <div class="upload-section" id="uploadContainer">
                <div class="upload-icon">üìÅ</div>
                <h3>ÏòÅÏÉÅ ÌååÏùºÏùÑ ÎìúÎûòÍ∑∏ÌïòÍ±∞ÎÇò ÌÅ¥Î¶≠ÌïòÏó¨ ÏóÖÎ°úÎìú</h3>
                <p>MP4, AVI, MOV ÌååÏùº ÏßÄÏõê</p>
                <input type="file" id="file-input" class="file-input" accept="video/*">
                <div class="file-info" id="fileInfo">
                    <p id="fileName"></p>
                    <p id="fileSize"></p>
                </div>
            </div>

            <!-- ÏõêÎ≥∏ ÏòÅÏÉÅ ÎØ∏Î¶¨Î≥¥Í∏∞ (ÏóÖÎ°úÎìú ÌõÑ ÌëúÏãú) -->
            <div class="video-preview-section" id="videoPreviewSection">
                <h3>üìπ&nbsp;ÏõêÎ≥∏ ÏòÅÏÉÅ ÎØ∏Î¶¨Î≥¥Í∏∞</h3>
                <div class="video-container" id="originalVideoContainer">
                    <div class="video-placeholder">
                        ÏòÅÏÉÅÏùÑ ÏóÖÎ°úÎìúÌïòÎ©¥ Ïó¨Í∏∞ÏóêÏÑú ÎØ∏Î¶¨Î≥º Ïàò ÏûàÏäµÎãàÎã§
                    </div>
                </div>
                <div class="video-controls">
                    <button class="control-btn" id="playBtn" disabled>‚ñ∂Ô∏è Ïû¨ÏÉù</button>
                    <button class="control-btn" id="pauseBtn" disabled>‚è∏Ô∏è ÏùºÏãúÏ†ïÏßÄ</button>
                    <button class="control-btn" id="rewindBtn" disabled>‚è™ ÎêòÍ∞êÍ∏∞</button>
                </div>
            </div>
            
            <!-- Ï≤òÎ¶¨ ÏòµÏÖò ÏÑπÏÖò -->
            <div id="videoEditorContainer" style="display: none;">
                <video id="videoPreview" controls></video>
            </div>

            <div class="options-section">
                <div class="option-group">
                    <h3>üìº ÏòÅÏÉÅ Ï≤òÎ¶¨</h3>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="autoHighlight" name="video_processing" value="highlight" checked>
                            <label for="autoHighlight">ÏûêÎèô ÌïòÏù¥ÎùºÏù¥Ìä∏ Ï∂îÏ∂ú</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="autoCrop" name="video_processing" value="crop" checked>
                            <label for="autoCrop">ÏûêÎèô ÌÅ¨Î°≠</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="colorCorrection" name="video_processing" value="color" checked>
                            <label for="colorCorrection">ÏÉâÏÉÅ Î≥¥Ï†ï</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="videoStabilization" name="video_processing" value="stabilize">
                            <label for="videoStabilization">ÏòÅÏÉÅ ÏïàÏ†ïÌôî</label>
                        </div>
                    </div>
                </div>

                <div class="option-group">
                    <h3>üîä Ïò§ÎîîÏò§ Ï≤òÎ¶¨</h3>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="removeSilence" name="audio_processing" value="silence" checked>
                            <label for="removeSilence">Î¨¥Ïùå Íµ¨Í∞Ñ Ï†úÍ±∞</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="enhanceAudio" name="audio_processing" value="enhance" checked>
                            <label for="enhanceAudio">Ïò§ÎîîÏò§ Ìñ•ÏÉÅ</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="noiseReduction" name="audio_processing" value="noise" checked>
                            <label for="noiseReduction">ÎÖ∏Ïù¥Ï¶à Í∞êÏÜå</label>
                        </div>
                    </div>
                </div>

                <div class="option-group">
                    <h3>üìù&nbsp;Ï∂îÍ∞Ä Í∏∞Îä•</h3>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="addTitle" name="features" value="title">
                            <label for="addTitle">ÌÉÄÏù¥ÌãÄ Ï∂îÍ∞Ä</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="addSubtitles" name="features" value="subtitles">
                            <label for="addSubtitles">ÏûêÎßâ Ï∂îÍ∞Ä</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="addEffects" name="features" value="effects">
                            <label for="addEffects">ÏòÅÏÉÅÌö®Í≥º Ï∂îÍ∞Ä</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="faceAnalysis" name="features" value="face_analysis">
                            <label for="faceAnalysis">üé≠ Î∞∞Ïö∞ ÏñºÍµ¥ Î∂ÑÏÑù Î∞è Í∞§Îü¨Î¶¨ ÏÉùÏÑ±</label>
                        </div>
                    </div>
                </div>

                <div class="option-group">
                    <h3>‚öôÔ∏è&nbsp;ÏàèÏ∏† ÏÉùÏÑ± ÏÑ§Ï†ï</h3>
                    <div class="setting-item">
                        <label for="shortsLength">ÏòÅÏÉÅ Í∏∏Ïù¥</label>
                        <select id="shortsLength" class="setting-input">
                            <option value="15">15Ï¥à</option>
                            <option value="30">30Ï¥à</option>
                            <option value="45">45Ï¥à</option>
                            <option value="60" selected>60Ï¥à</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label for="shortsCount">ÏÉùÏÑ± Í∞úÏàò</label>
                        <input type="number" id="shortsCount" class="setting-input" value="1" min="1" max="10">
                    </div>
                </div>

                <div class="option-group">
                    <h3>üìÅ&nbsp;Ï†ÄÏû• Í¥ÄÎ¶¨</h3>
                    <div class="setting-item">
                        <label for="outputFolder">Ï†ÄÏû• Ìè¥Îçî</label>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <input type="text" id="outputFolder" class="setting-input" placeholder="Ìè¥ÎçîÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî" readonly style="flex: 1;">
                            <button id="selectFolderBtn" class="control-btn" style="padding: 0.5rem;">üìÅ</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label for="autoSave">ÏûêÎèô Ï†ÄÏû•</label>
                        <input type="checkbox" id="autoSave" checked>
                    </div>
                    <div class="setting-item">
                        <label for="fileNaming">ÌååÏùºÎ™Ö ÌòïÏãù</label>
                        <select id="fileNaming" class="setting-input">
                            <option value="timestamp">ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ (20241220_143022)</option>
                            <option value="sequential">ÏàúÏ∞®Î≤àÌò∏ (shorts_001, shorts_002)</option>
                            <option value="custom">ÏÇ¨Ïö©Ïûê Ï†ïÏùò</option>
                        </select>
                    </div>
                    <div class="setting-item" id="customNameContainer" style="display: none;">
                        <label for="customName">ÏÇ¨Ïö©Ïûê Ï†ïÏùòÎ™Ö</label>
                        <input type="text" id="customName" class="setting-input" placeholder="Ïòà: MyShorts">
                    </div>
                </div>
            </div>

            <div class="chat-area">
                <div class="chat-list-panel">
                    <div class="chat-list-header">
                        <h3>ÎåÄÌôî Î™©Î°ù</h3>
                        <input type="checkbox" id="selectAllChats" title="Ï†ÑÏ≤¥ ÏÑ†ÌÉù">
                    </div>
                    <div class="chat-list" id="chatList">
                        <!-- Populated by JavaScript -->
                    </div>
                    <div class="chat-list-actions">
                        <button id="saveChatsBtn" title="Î™®Îì† ÎåÄÌôî Ï†ÄÏû•">üíæ Ï†ÄÏû•</button>
                        <button id="loadChatsBtn" title="ÌååÏùºÏóêÏÑú Î∂àÎü¨Ïò§Í∏∞">üìÇ Î∂àÎü¨Ïò§Í∏∞</button>
                        <input type="file" id="loadChatsInput" style="display: none;" accept=".json">
                        <button id="deleteChatsBtn" title="ÏÑ†ÌÉù ÎåÄÌôî ÏÇ≠Ï†ú">üóëÔ∏è ÏÇ≠Ï†ú</button>
                    </div>
                </div>

                <div class="chat-panel">
                    <div class="chat-header">
                        <h3>AI Ïñ¥ÏãúÏä§ÌÑ¥Ìä∏</h3>
                        <button id="newChatBtn">ÏÉà ÎåÄÌôî</button>
                    </div>
                    <div class="chat-history" id="chatHistory">
                        <!-- Chat messages will be appended here -->
                    </div>
                </div>
            </div>

            <div class="selection-container">
                <div class="dark-selection-box">
                    <h3>üåê&nbsp;ÌîåÎû´Ìèº ÏÑ†ÌÉù</h3>
                    <div class="platform-group">
                        <div class="platform-card" data-platform="youtube_shorts">
                            <div class="platform-icon">üì∫</div>
                            YouTube Shorts
                        </div>
                        <div class="platform-card" data-platform="instagram_reels">
                            <div class="platform-icon">üì∏</div>
                            Instagram Reels
                        </div>
                        <div class="platform-card" data-platform="tiktok">
                            <div class="platform-icon">üéµ</div>
                            TikTok
                        </div>
                        <div class="platform-card" data-platform="naver">
                            <div class="platform-icon">KR</div>
                            ÎÑ§Ïù¥Î≤Ñ
                        </div>
                        <div class="platform-card" data-platform="facebook_reels">
                            <div class="platform-icon">üë•</div>
                            Facebook Reels
                        </div>
                    </div>
                </div>
    
                <div class="dark-selection-box ai-model-box">
                    <div class="chat-input-area">
                        <textarea id="chatInput" placeholder="AIÏóêÍ≤å ÏòÅÏÉÅ Ï≤òÎ¶¨Î•º ÏöîÏ≤≠ÌïòÏÑ∏Ïöî..." rows="1"></textarea>
                        <button id="sendChatBtn" disabled>Ï†ÑÏÜ°</button>
                    </div>
                    <div class="ai-model-container">
                        <select id="mainModelSelect" class="setting-input"></select>
                        <select id="subModelSelect" class="setting-input"></select>
                        <button class="settings-btn" id="apiSettingsBtn" title="API ÌÇ§ ÏÑ§Ï†ï">‚öôÔ∏è</button>
                    </div>
                </div>
            </div>

            <div class="process-section">
                <button id="processBtn" class="process-btn" disabled>üöÄ&nbsp;ÏòÅÏÉÅ Ï≤òÎ¶¨ ÏãúÏûë</button>
            </div>

            <!-- Î∞∞Ïö∞ ÏñºÍµ¥ Í∞§Îü¨Î¶¨ ÏÑπÏÖò -->
            <div class="face-gallery-container" id="faceGalleryContainer" style="display: none;">
                <h3>üé≠ Î∞∞Ïö∞ ÏñºÍµ¥ Í∞§Îü¨Î¶¨</h3>
                <div class="face-gallery-controls">
                    <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                        <button class="btn btn-secondary" id="analyzeFacesBtn">
                            üîç ÏñºÍµ¥ Î∂ÑÏÑù ÏãúÏûë
                        </button>
                        <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; background: rgba(0, 137, 123, 0.1); border-radius: 20px; border: 1px solid rgba(0, 137, 123, 0.2);">
                            <input type="checkbox" id="autoFaceAnalysis" checked>
                            <label for="autoFaceAnalysis" style="color: var(--text-secondary); font-size: 0.9rem; margin: 0;">
                                ‚ö° ÏòÅÏÉÅ Î°úÎî©Ïãú ÏûêÎèô Ïã§Ìñâ
                            </label>
                        </div>
                    </div>
                    <button class="btn btn-primary" id="generateFaceImagesBtn" style="display: none;">
                        üé® AI ÏñºÍµ¥ Í∑∏Î¶¨Í∏∞
                    </button>
                    <button class="btn btn-success" id="downloadFaceGalleryBtn" style="display: none;">
                        üì• Í∞§Îü¨Î¶¨ Îã§Ïö¥Î°úÎìú
                    </button>
                </div>
                <div style="text-align: center; margin-bottom: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                    üéØ <strong>Ïã§Ï†ú ÏñºÍµ¥ Ïù∏Ïãù ÏãúÏä§ÌÖú:</strong><br>
                    ‚Ä¢ <span style="color: #00bcd4;">Face-api.js</span>Î°ú ÏòÅÏÉÅÏóêÏÑú Ïã§Ï†ú Î∞∞Ïö∞ ÏñºÍµ¥ Í∞êÏßÄ<br>
                    ‚Ä¢ <span style="color: #ff9800;">ÎÇòÏù¥, ÏÑ±Î≥Ñ, ÌëúÏ†ï</span> ÏûêÎèô Î∂ÑÏÑù<br>
                    ‚Ä¢ <span style="color: #4caf50;">ÏñºÍµ¥Î≥Ñ Îì±Ïû• ÌöüÏàò</span> Î∞è ÏãúÍ∞Ñ Ï∂îÏ†Å<br>
                    ‚Ä¢ <span style="color: #9c27b0;">Í∞ôÏùÄ Ïù∏Î¨º ÏûêÎèô Í∑∏Î£πÌôî</span> (AI Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞)
                </div>
                <div class="analysis-progress" id="analysisProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="faceProgressFill"></div>
                    </div>
                    <div class="progress-text" id="faceProgressText">ÏñºÍµ¥ Î∂ÑÏÑù Ï§ë...</div>
                </div>
                <div class="face-results" id="faceResults">
                    <!-- Î∂ÑÏÑùÎêú ÏñºÍµ¥Îì§Ïù¥ Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§ -->
                </div>
            </div>

            <!-- ÏßÑÌñâÎ•† ÌëúÏãú -->
            <div class="progress-section" id="progressSection">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="status-text" id="statusText">Ï≤òÎ¶¨ Ï§ë...</div>
            </div>
        </div>

        <!-- Ïò§Î•∏Ï™Ω Ìå®ÎÑê: Í≤∞Í≥º -->
        <div class="right-panel">
            <div id="resultsContainer">
                <div class="title-box">
                    <h3>‚úÖ ÏôÑÏÑ±Îêú ÏàèÏ∏† ÏòÅÏÉÅ</h3>
                </div>
                <div class="shorts-carousel">
                    <button class="carousel-btn prev" id="prevShortBtn">‚Äπ</button>
                    <div class="shorts-viewport">
                        <div id="shortsTrack">
                            <!-- JS will populate this -->
                        </div>
                    </div>
                    <button class="carousel-btn next" id="nextShortBtn">‚Ä∫</button>
                </div>
                <div id="shorts-counter"></div>
                <div id="completedShortsGrid" style="display: none;">
                    <!-- This is now unused, but kept for safety, will be controlled by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- ÏóÖÎ°úÎìú Î™®Îã¨ -->
    <div class="upload-modal" id="uploadModal">
        <div class="upload-modal-content">
            <h3 id="modalTitle">ÌîåÎû´Ìèº ÏóÖÎ°úÎìú</h3>
            <form class="upload-form" id="uploadForm">
                <div class="form-group">
                    <label for="videoTitle">Ï†úÎ™©</label>
                    <input type="text" id="videoTitle" required>
                </div>
                <div class="form-group">
                    <label for="videoDescription">ÏÑ§Î™Ö</label>
                    <textarea id="videoDescription" placeholder="ÏòÅÏÉÅÏóê ÎåÄÌïú ÏÑ§Î™ÖÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."></textarea>
                </div>
                <div class="form-group">
                    <label for="videoTags">ÌÉúÍ∑∏ (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)</label>
                    <input type="text" id="videoTags" placeholder="Ïòà: ÏàèÏ∏†, Ïú†ÌäúÎ∏å, Ïû¨ÎØ∏ÏûàÎäî">
                </div>
            </form>
            <div class="modal-actions">
                <button class="modal-btn cancel" id="cancelUpload">Ï∑®ÏÜå</button>
                <button class="modal-btn upload" id="confirmUpload">ÏóÖÎ°úÎìú</button>
            </div>
        </div>
    </div>

    <!-- API Key Modal -->
    <div id="apiKeyModal" class="api-key-modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h3 id="apiKeyModalTitle">API ÌÇ§ ÏÑ§Ï†ï</h3>
            <div class="form-group">
                <div class="form-label-group">
                    <label for="apiKeyInput">API ÌÇ§</label>
                    <a href="#" id="apiKeyLink" target="_blank" rel="noopener noreferrer">API ÌÇ§ Î∞úÍ∏âÎ∞õÍ∏∞ &nearr;</a>
                </div>
                <input type="password" id="apiKeyInput" class="form-group-input">
            </div>
            <div class="modal-actions">
                <button id="cancelApiKey" class="btn btn-secondary">Ï∑®ÏÜå</button>
                <button id="saveApiKey" class="btn btn-primary">Ï†ÄÏû•</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const themeToggle = document.getElementById('theme-toggle');
            
            // Upload related
            const uploadContainer = document.getElementById('uploadContainer');
            const fileInput = document.getElementById('file-input');

            // Video Preview related
            const videoEditorContainer = document.getElementById('videoEditorContainer');
            const videoPreview = document.getElementById('videoPreview');
            
            // Controls and buttons
            const processBtn = document.getElementById('processBtn');
            const platformCards = document.querySelectorAll('.platform-card');
            const loadNewVideoButton = document.getElementById('loadNewVideoButton');
            
            // Storage management elements
            const selectFolderBtn = document.getElementById('selectFolderBtn');
            const outputFolder = document.getElementById('outputFolder');
            const autoSave = document.getElementById('autoSave');
            const fileNaming = document.getElementById('fileNaming');
            const customName = document.getElementById('customName');
            const customNameContainer = document.getElementById('customNameContainer');
            
            // Results related
            const resultsContainer = document.getElementById('resultsContainer');
            const completedShortsGrid = document.getElementById('completedShortsGrid');
            const shortsTrack = document.getElementById('shortsTrack');
            const prevShortBtn = document.getElementById('prevShortBtn');
            const nextShortBtn = document.getElementById('nextShortBtn');
            const shortsCounter = document.getElementById('shorts-counter');

            // Chat panel elements
            const chatHistory = document.getElementById('chatHistory');
            const chatInput = document.getElementById('chatInput');
            const sendChatBtn = document.getElementById('sendChatBtn');
            const newChatBtn = document.getElementById('newChatBtn');

            // Chat List elements
            const chatList = document.getElementById('chatList');
            const selectAllChats = document.getElementById('selectAllChats');
            const saveChatsBtn = document.getElementById('saveChatsBtn');
            const loadChatsBtn = document.getElementById('loadChatsBtn');
            const loadChatsInput = document.getElementById('loadChatsInput');
            const deleteChatsBtn = document.getElementById('deleteChatsBtn');

            // Face Gallery elements
            const faceGalleryContainer = document.getElementById('faceGalleryContainer');
            const faceAnalysisCheckbox = document.getElementById('faceAnalysis');
            const analyzeFacesBtn = document.getElementById('analyzeFacesBtn');
            const autoFaceAnalysis = document.getElementById('autoFaceAnalysis');
            const generateFaceImagesBtn = document.getElementById('generateFaceImagesBtn');
            const downloadFaceGalleryBtn = document.getElementById('downloadFaceGalleryBtn');
            const analysisProgress = document.getElementById('analysisProgress');
            const faceProgressFill = document.getElementById('faceProgressFill');
            const faceProgressText = document.getElementById('faceProgressText');
            const faceResults = document.getElementById('faceResults');

            let uploadedFile = null;
            let chats = [];
            let currentChatId = null;
            let allGeneratedShorts = [];
            let currentShortIndex = 0;
            let outputFolderHandle = null;
            let savedShortsCount = 0;
            let detectedFaces = [];
            let faceAnalysisInProgress = false;
            let faceApiModelsLoaded = false;
            let videoFrames = [];
            let faceDescriptors = [];

            // --- AI Model Data & Logic ---
            const aiModels = {
                claude: { 
                    name: "Claude", 
                    subModels: [
                        "Claude 3.5 Sonnet", 
                        "Claude 3.5 Haiku", 
                        "Claude 3 Opus", 
                        "Claude 3 Sonnet", 
                        "Claude 3 Haiku"
                    ], 
                    apiKey: "", 
                    apiKeyUrl: "https://console.anthropic.com/settings/keys",
                    endpoint: "https://api.anthropic.com/v1/messages"
                },
                gpt: { 
                    name: "OpenAI GPT", 
                    subModels: [
                        "GPT-4o", 
                        "GPT-4o mini", 
                        "GPT-4 Turbo", 
                        "GPT-4", 
                        "GPT-3.5 Turbo", 
                        "GPT-3.5 Turbo 16k"
                    ], 
                    apiKey: "", 
                    apiKeyUrl: "https://platform.openai.com/api-keys",
                    endpoint: "https://api.openai.com/v1/chat/completions"
                },
                gemini: { 
                    name: "Google Gemini", 
                    subModels: [
                        "Gemini 2.0 Flash", 
                        "Gemini 1.5 Pro", 
                        "Gemini 1.5 Flash", 
                        "Gemini 1.5 Flash-8B", 
                        "Gemini 1.0 Pro"
                    ], 
                    apiKey: "", 
                    apiKeyUrl: "https://aistudio.google.com/app/api-keys",
                    endpoint: "https://generativelanguage.googleapis.com/v1beta/models"
                },
                groq: { 
                    name: "Groq", 
                    subModels: [
                        "Llama 3.3 70B", 
                        "Llama 3.1 405B", 
                        "Llama 3.1 70B", 
                        "Llama 3.1 8B", 
                        "Llama 3 70B", 
                        "Llama 3 8B", 
                        "Mixtral 8x7B", 
                        "Gemma 2 9B", 
                        "Gemma 7B"
                    ], 
                    apiKey: "", 
                    apiKeyUrl: "https://console.groq.com/keys",
                    endpoint: "https://api.groq.com/openai/v1/chat/completions"
                },
                perplexity: {
                    name: "Perplexity",
                    subModels: [
                        "Llama 3.1 Sonar Large",
                        "Llama 3.1 Sonar Small", 
                        "Llama 3.1 70B",
                        "Llama 3.1 8B"
                    ],
                    apiKey: "",
                    apiKeyUrl: "https://www.perplexity.ai/settings/api",
                    endpoint: "https://api.perplexity.ai/chat/completions"
                },
                cohere: {
                    name: "Cohere",
                    subModels: [
                        "Command R+",
                        "Command R",
                        "Command",
                        "Command Light"
                    ],
                    apiKey: "",
                    apiKeyUrl: "https://dashboard.cohere.com/api-keys",
                    endpoint: "https://api.cohere.ai/v1/chat"
                }
            };

            const mainModelSelect = document.getElementById('mainModelSelect');
            const subModelSelect = document.getElementById('subModelSelect');
            const apiSettingsBtn = document.getElementById('apiSettingsBtn');
            
            // API Key Modal Elements
            const apiKeyModal = document.getElementById('apiKeyModal');
            const apiKeyModalTitle = document.getElementById('apiKeyModalTitle');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const apiKeyLink = document.getElementById('apiKeyLink');
            const saveApiKeyBtn = document.getElementById('saveApiKey');
            const cancelApiKeyBtn = document.getElementById('cancelApiKey');
            const closeBtn = apiKeyModal.querySelector('.close-button');
            let currentEditingModel = null;

            function initializeMainModels() {
                mainModelSelect.innerHTML = '';
                for (const key in aiModels) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = aiModels[key].name;
                    mainModelSelect.appendChild(option);
                }
            }

            function updateSubModels() {
                const selectedModelKey = mainModelSelect.value;
                const subModels = aiModels[selectedModelKey].subModels;
                
                subModelSelect.innerHTML = '';
                subModels.forEach(modelName => {
                    const option = document.createElement('option');
                    option.value = modelName;
                    option.textContent = modelName;
                    subModelSelect.appendChild(option);
                });
            }
            
            mainModelSelect.addEventListener('change', updateSubModels);

            // --- API Key Modal Logic ---
            apiSettingsBtn.addEventListener('click', () => {
                const selectedModelKey = mainModelSelect.value;
                const modelData = aiModels[selectedModelKey];
                
                apiKeyModalTitle.textContent = `${modelData.name} API ÌÇ§ ÏÑ§Ï†ï`;
                apiKeyInput.value = modelData.apiKey || '';
                apiKeyLink.href = modelData.apiKeyUrl;

                apiKeyModal.style.display = 'block';
                
                currentEditingModel = selectedModelKey;
            });

            function closeApiKeyModal() {
                 apiKeyModal.style.display = 'none';
            }

            closeBtn.addEventListener('click', closeApiKeyModal);
            cancelApiKeyBtn.addEventListener('click', closeApiKeyModal);
            
            saveApiKeyBtn.addEventListener('click', () => {
                if (currentEditingModel) {
                    aiModels[currentEditingModel].apiKey = apiKeyInput.value;
                    localStorage.setItem(`apiKey_${currentEditingModel}`, apiKeyInput.value);
                    console.log(`${aiModels[currentEditingModel].name} API Key saved.`); // For debugging
                    alert(`${aiModels[currentEditingModel].name} API ÌÇ§Í∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.`);
                    closeApiKeyModal();
                }
            });

            // Load saved API keys
            function loadSavedApiKeys() {
                for (const modelKey in aiModels) {
                    const savedKey = localStorage.getItem(`apiKey_${modelKey}`);
                    if (savedKey) {
                        aiModels[modelKey].apiKey = savedKey;
                    }
                }
            }

            // --- Storage Management Functions ---
            async function selectOutputFolder() {
                try {
                    if ('showDirectoryPicker' in window) {
                        outputFolderHandle = await window.showDirectoryPicker();
                        const folderName = outputFolderHandle.name;
                        outputFolder.value = folderName;
                        localStorage.setItem('outputFolderName', folderName);
                        
                        // Ìè¥Îçî ÏÑ†ÌÉù ÌõÑ ÏãúÍ∞ÅÏ†Å ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                        updateFolderStatus(true, folderName);
                        addMessage('ai', `‚úÖ Ï†ÄÏû• Ìè¥ÎçîÍ∞Ä "${folderName}"Î°ú ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§. Ïù¥Ï†ú ÏòÅÏÉÅ Ï≤òÎ¶¨ ÏôÑÎ£å ÌõÑ ÏûêÎèôÏúºÎ°ú Ïù¥ Ìè¥ÎçîÏóê Ï†ÄÏû•Îê©ÎãàÎã§.`);
                    } else {
                        // Fallback for browsers that don't support File System Access API
                        const folderPath = prompt('Ï†ÄÏû•Ìï† Ìè¥Îçî Í≤ΩÎ°úÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî:', 'C:\\AutoShorts\\Output');
                        if (folderPath) {
                            outputFolder.value = folderPath;
                            localStorage.setItem('outputFolderPath', folderPath);
                            
                            // Ìè¥Îçî ÏÑ†ÌÉù ÌõÑ ÏãúÍ∞ÅÏ†Å ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                            updateFolderStatus(true, folderPath);
                            addMessage('ai', `‚úÖ Ï†ÄÏû• Í≤ΩÎ°úÍ∞Ä "${folderPath}"Î°ú ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§. Ïù¥Ï†ú ÏòÅÏÉÅ Ï≤òÎ¶¨ ÏôÑÎ£å ÌõÑ ÏûêÎèôÏúºÎ°ú Ïù¥ Ìè¥ÎçîÏóê Ï†ÄÏû•Îê©ÎãàÎã§.`);
                        }
                    }
                } catch (error) {
                    console.error('Folder selection error:', error);
                    addMessage('ai', '‚ùå Ìè¥Îçî ÏÑ†ÌÉùÏù¥ Ï∑®ÏÜåÎêòÏóàÍ±∞ÎÇò Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                }
            }

            function generateFileName(index, originalName = 'video') {
                const namingType = fileNaming.value;
                const now = new Date();
                
                switch (namingType) {
                    case 'timestamp':
                        const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
                        return `shorts_${timestamp}_${index}.mp4`;
                    
                    case 'sequential':
                        const paddedIndex = String(savedShortsCount + index).padStart(3, '0');
                        return `shorts_${paddedIndex}.mp4`;
                    
                    case 'custom':
                        const customPrefix = customName.value.trim() || 'MyShorts';
                        const paddedCustomIndex = String(index).padStart(3, '0');
                        return `${customPrefix}_${paddedCustomIndex}.mp4`;
                    
                    default:
                        return `shorts_${index}.mp4`;
                }
            }

            async function saveVideoFile(videoElement, fileName) {
                try {
                    // Create download link for the video
                    const link = document.createElement('a');
                    link.href = videoElement.src;
                    link.download = fileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    return true;
                } catch (error) {
                    console.error('Save error:', error);
                    return false;
                }
            }

            async function autoSaveShorts() {
                if (!autoSave.checked) return;
                
                // Ï†ÄÏû• Ìè¥Îçî ÌôïÏù∏
                const currentFolder = outputFolder.value;
                if (!currentFolder) {
                    addMessage('ai', '‚ö†Ô∏è Ï†ÄÏû• Ìè¥ÎçîÍ∞Ä ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Î®ºÏ†Ä Ï†ÄÏû• Ìè¥ÎçîÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                    updateFolderStatus(false);
                    return;
                }
                
                let savedCount = 0;
                const totalShorts = allGeneratedShorts.length;
                
                addMessage('ai', `üíæ ${totalShorts}Í∞úÏùò ÏàèÏ∏†Î•º "${currentFolder}" Ìè¥ÎçîÏóê ÏûêÎèô Ï†ÄÏû•ÌïòÍ≥† ÏûàÏäµÎãàÎã§...`);
                
                for (let i = 0; i < allGeneratedShorts.length; i++) {
                    const shortElement = allGeneratedShorts[i];
                    const video = shortElement.querySelector('video');
                    const fileName = generateFileName(i + 1);
                    
                    const success = await saveVideoFile(video, fileName);
                    if (success) {
                        savedCount++;
                        // Update UI to show saved status
                        const shortInfo = shortElement.querySelector('.short-info');
                        const savedBadge = document.createElement('span');
                        savedBadge.innerHTML = 'üíæ Ï†ÄÏû•Îê®';
                        savedBadge.style.cssText = 'font-size: 0.75rem; color: var(--success-text); margin-left: 0.5rem;';
                        shortInfo.appendChild(savedBadge);
                    }
                }
                
                savedShortsCount += savedCount;
                localStorage.setItem('savedShortsCount', savedShortsCount.toString());
                
                if (savedCount === totalShorts) {
                    addMessage('ai', `‚úÖ ${savedCount}Í∞úÏùò ÏàèÏ∏†Í∞Ä Î™®Îëê "${currentFolder}" Ìè¥ÎçîÏóê ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!`);
                } else {
                    addMessage('ai', `‚ö†Ô∏è ${savedCount}/${totalShorts}Í∞úÏùò ÏàèÏ∏†Í∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§. ${totalShorts - savedCount}Í∞úÎäî Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.`);
                }
            }

            // Individual download function
            window.downloadSingleShort = function(button, index) {
                // Ï†ÄÏû• Ìè¥Îçî ÌôïÏù∏
                const currentFolder = outputFolder.value;
                if (!currentFolder) {
                    addMessage('ai', '‚ö†Ô∏è Ï†ÄÏû• Ìè¥ÎçîÍ∞Ä ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Î®ºÏ†Ä Ï†ÄÏû• Ìè¥ÎçîÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                    updateFolderStatus(false);
                    return;
                }
                
                const shortElement = button.closest('.short-item');
                const video = shortElement.querySelector('video');
                const fileName = generateFileName(index);
                
                saveVideoFile(video, fileName).then(success => {
                    if (success) {
                        addMessage('ai', `üíæ ÏàèÏ∏† #${index}Í∞Ä "${currentFolder}" Ìè¥ÎçîÏóê "${fileName}" Ïù¥Î¶ÑÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.`);
                        
                        // Add saved badge if not already present
                        const shortInfo = shortElement.querySelector('.short-info');
                        if (!shortInfo.querySelector('.saved-badge')) {
                            const savedBadge = document.createElement('span');
                            savedBadge.className = 'saved-badge';
                            savedBadge.innerHTML = 'üíæ Ï†ÄÏû•Îê®';
                            savedBadge.style.cssText = 'font-size: 0.75rem; color: var(--success-text); margin-left: 0.5rem;';
                            shortInfo.appendChild(savedBadge);
                        }
                    } else {
                        addMessage('ai', `‚ùå ÏàèÏ∏† #${index} Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.`);
                    }
                });
            };

            // Event listeners for storage management
            selectFolderBtn.addEventListener('click', selectOutputFolder);
            
            fileNaming.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    customNameContainer.style.display = 'flex';
                } else {
                    customNameContainer.style.display = 'none';
                }
            });

            // Load saved settings
            function loadStorageSettings() {
                const savedFolderName = localStorage.getItem('outputFolderName');
                const savedFolderPath = localStorage.getItem('outputFolderPath');
                const savedCount = localStorage.getItem('savedShortsCount');
                
                // ÏûêÎèô Ïã§Ìñâ ÏÑ§Ï†ï Î°úÎî©
                const savedAutoFaceAnalysis = localStorage.getItem('autoFaceAnalysis');
                if (savedAutoFaceAnalysis !== null) {
                    autoFaceAnalysis.checked = savedAutoFaceAnalysis === 'true';
                }
                
                // Ï≤òÏùå Ïã§ÌñâÏãú Îπà ÏÉÅÌÉúÎ°ú ÌëúÏãú
                if (savedFolderName) {
                    outputFolder.value = savedFolderName;
                    updateFolderStatus(true, savedFolderName);
                    // Í∏∞Ï°¥ Ìè¥Îçî ÏÑ§Ï†ï ÏïåÎ¶º
                    setTimeout(() => {
                        addMessage('ai', `üìÅ Ïù¥Ï†ÑÏóê ÏÑ§Ï†ïÌïú Ï†ÄÏû• Ìè¥Îçî "${savedFolderName}"Î•º Î∂àÎü¨ÏôîÏäµÎãàÎã§. ÏòÅÏÉÅ Ï≤òÎ¶¨ ÏôÑÎ£å ÌõÑ ÏûêÎèôÏúºÎ°ú Ïù¥ Ìè¥ÎçîÏóê Ï†ÄÏû•Îê©ÎãàÎã§.`);
                    }, 1000);
                } else if (savedFolderPath) {
                    outputFolder.value = savedFolderPath;
                    updateFolderStatus(true, savedFolderPath);
                    // Í∏∞Ï°¥ Ìè¥Îçî ÏÑ§Ï†ï ÏïåÎ¶º
                    setTimeout(() => {
                        addMessage('ai', `üìÅ Ïù¥Ï†ÑÏóê ÏÑ§Ï†ïÌïú Ï†ÄÏû• Í≤ΩÎ°ú "${savedFolderPath}"Î•º Î∂àÎü¨ÏôîÏäµÎãàÎã§. ÏòÅÏÉÅ Ï≤òÎ¶¨ ÏôÑÎ£å ÌõÑ ÏûêÎèôÏúºÎ°ú Ïù¥ Í≤ΩÎ°úÏóê Ï†ÄÏû•Îê©ÎãàÎã§.`);
                    }, 1000);
                } else {
                    // Ï≤òÏùå Ïã§Ìñâ - Îπà ÏÉÅÌÉú Î™ÖÏãúÏ†Å ÌëúÏãú
                    outputFolder.value = '';
                    outputFolder.placeholder = 'üìÅ Ï†ÄÏû• Ìè¥ÎçîÎ•º Î®ºÏ†Ä ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî';
                    updateFolderStatus(false);
                    // Ìè¥Îçî ÏÑ†ÌÉù ÏïàÎÇ¥ Î©îÏãúÏßÄ
                    setTimeout(() => {
                        addMessage('ai', 'üëã ÌôòÏòÅÌï©ÎãàÎã§! ÏòÅÏÉÅ Ï≤òÎ¶¨Î•º ÏãúÏûëÌïòÍ∏∞ Ï†ÑÏóê Ï†ÄÏû• Ìè¥ÎçîÎ•º Î®ºÏ†Ä ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî. üìÅ Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ Ìè¥ÎçîÎ•º ÏßÄÏ†ïÌïòÎ©¥ Îã§ÏùåÎ∂ÄÌÑ∞Îäî ÏûêÎèôÏúºÎ°ú ÏÑ§Ï†ïÎê©ÎãàÎã§.');
                    }, 1500);
                }
                
                if (savedCount) {
                    savedShortsCount = parseInt(savedCount, 10);
                }
            }

            // Ìè¥Îçî ÏÑ†ÌÉù ÏÉÅÌÉúÎ•º ÏãúÍ∞ÅÏ†ÅÏúºÎ°ú ÌëúÏãúÌïòÎäî Ìï®Ïàò
            function updateFolderStatus(isSelected, folderName = '') {
                const selectFolderBtn = document.getElementById('selectFolderBtn');
                const outputFolder = document.getElementById('outputFolder');
                
                if (isSelected && folderName) {
                    // Ìè¥ÎçîÍ∞Ä ÏÑ†ÌÉùÎêú ÏÉÅÌÉú
                    outputFolder.className = 'setting-input folder-selected';
                    selectFolderBtn.className = 'control-btn folder-selected';
                    selectFolderBtn.innerHTML = '‚úÖ';
                    selectFolderBtn.title = `ÌòÑÏû¨ Ìè¥Îçî: ${folderName}`;
                    outputFolder.placeholder = `ÌòÑÏû¨ ÏÑ†ÌÉù: ${folderName}`;
                } else {
                    // Ìè¥ÎçîÍ∞Ä ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏùÄ ÏÉÅÌÉú (Ï≤òÏùå Ïã§Ìñâ)
                    outputFolder.className = 'setting-input folder-not-selected';
                    selectFolderBtn.className = 'control-btn folder-not-selected';
                    selectFolderBtn.innerHTML = 'üìÅ';
                    selectFolderBtn.title = 'Ï†ÄÏû• Ìè¥ÎçîÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî (ÌïÑÏàò)';
                    outputFolder.placeholder = 'üìÅ Ï†ÄÏû• Ìè¥ÎçîÎ•º Î®ºÏ†Ä ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî';
                }
            }

            // --- Video Analysis Functions ---
            async function extractVideoFrames(videoElement, numFrames = 5) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const frames = [];
                
                canvas.width = 640;
                canvas.height = 360;
                
                const duration = videoElement.duration;
                const interval = duration / numFrames;
                
                for (let i = 0; i < numFrames; i++) {
                    const time = i * interval;
                    await seekToTime(videoElement, time);
                    
                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    const frameData = canvas.toDataURL('image/jpeg', 0.8);
                    frames.push({
                        time: time,
                        data: frameData
                    });
                }
                
                return frames;
            }
            
            function seekToTime(videoElement, time) {
                return new Promise((resolve) => {
                    const onSeeked = () => {
                        videoElement.removeEventListener('seeked', onSeeked);
                        resolve();
                    };
                    videoElement.addEventListener('seeked', onSeeked);
                    videoElement.currentTime = time;
                });
            }

            // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Î™®Îì† ÏòµÏÖòÏùÑ Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò
            function getCurrentOptions() {
                const selectedPlatforms = Array.from(getSelectedPlatforms()).map(p => p.dataset.platform);
                const platformNames = {
                    'youtube_shorts': 'YouTube Shorts',
                    'instagram_reels': 'Instagram Reels',
                    'tiktok': 'TikTok',
                    'naver': 'ÎÑ§Ïù¥Î≤Ñ',
                    'facebook_reels': 'Facebook Reels'
                };

                return {
                    // ÏòÅÏÉÅ Ï≤òÎ¶¨ ÏòµÏÖò
                    videoProcessing: {
                        autoHighlight: document.getElementById('autoHighlight').checked,
                        autoCrop: document.getElementById('autoCrop').checked,
                        colorCorrection: document.getElementById('colorCorrection').checked,
                        videoStabilization: document.getElementById('videoStabilization').checked
                    },
                    // Ïò§ÎîîÏò§ Ï≤òÎ¶¨ ÏòµÏÖò
                    audioProcessing: {
                        removeSilence: document.getElementById('removeSilence').checked,
                        enhanceAudio: document.getElementById('enhanceAudio').checked,
                        noiseReduction: document.getElementById('noiseReduction').checked
                    },
                    // Ï∂îÍ∞Ä Í∏∞Îä•
                    features: {
                        addTitle: document.getElementById('addTitle').checked,
                        addSubtitles: document.getElementById('addSubtitles').checked,
                        addEffects: document.getElementById('addEffects').checked
                    },
                    // ÏàèÏ∏† ÏÑ§Ï†ï
                    settings: {
                        shortsLength: parseInt(document.getElementById('shortsLength').value),
                        shortsCount: parseInt(document.getElementById('shortsCount').value)
                    },
                    // ÏÑ†ÌÉùÎêú ÌîåÎû´Ìèº
                    platforms: selectedPlatforms.map(p => platformNames[p] || p),
                    // AI Î™®Îç∏ Ï†ïÎ≥¥
                    aiModel: {
                        provider: mainModelSelect.options[mainModelSelect.selectedIndex].text,
                        model: subModelSelect.options[subModelSelect.selectedIndex].text
                    },
                    // Ï†ÄÏû• Í¥ÄÎ¶¨ ÏÑ§Ï†ï
                    storage: {
                        autoSave: document.getElementById('autoSave').checked,
                        outputFolder: document.getElementById('outputFolder').value,
                        fileNaming: document.getElementById('fileNaming').value,
                        customName: document.getElementById('customName').value
                    }
                };
            }

            // ÏòµÏÖòÏùÑ ÌÖçÏä§Ìä∏Î°ú Î≥ÄÌôòÌïòÎäî Ìï®Ïàò
            function formatOptionsForAI(options) {
                let optionsText = "\nüìã ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÏòµÏÖòÎì§:\n\n";
                
                // ÌîåÎû´Ìèº Ï†ïÎ≥¥
                if (options.platforms.length > 0) {
                    optionsText += `üåê ÌÉÄÍ≤ü ÌîåÎû´Ìèº: ${options.platforms.join(', ')}\n`;
                } else {
                    optionsText += `‚ö†Ô∏è ÌîåÎû´ÌèºÏù¥ ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.\n`;
                }
                
                // ÏàèÏ∏† ÏÑ§Ï†ï
                optionsText += `‚è±Ô∏è ÏàèÏ∏† Í∏∏Ïù¥: ${options.settings.shortsLength}Ï¥à\n`;
                optionsText += `üî¢ ÏÉùÏÑ± Í∞úÏàò: ${options.settings.shortsCount}Í∞ú\n\n`;
                
                // ÏòÅÏÉÅ Ï≤òÎ¶¨ ÏòµÏÖò
                const videoOptions = [];
                if (options.videoProcessing.autoHighlight) videoOptions.push("ÏûêÎèô ÌïòÏù¥ÎùºÏù¥Ìä∏ Ï∂îÏ∂ú");
                if (options.videoProcessing.autoCrop) videoOptions.push("ÏûêÎèô ÌÅ¨Î°≠");
                if (options.videoProcessing.colorCorrection) videoOptions.push("ÏÉâÏÉÅ Î≥¥Ï†ï");
                if (options.videoProcessing.videoStabilization) videoOptions.push("ÏòÅÏÉÅ ÏïàÏ†ïÌôî");
                
                if (videoOptions.length > 0) {
                    optionsText += `üìº ÏòÅÏÉÅ Ï≤òÎ¶¨: ${videoOptions.join(', ')}\n`;
                }
                
                // Ïò§ÎîîÏò§ Ï≤òÎ¶¨ ÏòµÏÖò
                const audioOptions = [];
                if (options.audioProcessing.removeSilence) audioOptions.push("Î¨¥Ïùå Íµ¨Í∞Ñ Ï†úÍ±∞");
                if (options.audioProcessing.enhanceAudio) audioOptions.push("Ïò§ÎîîÏò§ Ìñ•ÏÉÅ");
                if (options.audioProcessing.noiseReduction) audioOptions.push("ÎÖ∏Ïù¥Ï¶à Í∞êÏÜå");
                
                if (audioOptions.length > 0) {
                    optionsText += `üîä Ïò§ÎîîÏò§ Ï≤òÎ¶¨: ${audioOptions.join(', ')}\n`;
                }
                
                // Ï∂îÍ∞Ä Í∏∞Îä•
                const features = [];
                if (options.features.addTitle) features.push("ÌÉÄÏù¥ÌãÄ Ï∂îÍ∞Ä");
                if (options.features.addSubtitles) features.push("ÏûêÎßâ Ï∂îÍ∞Ä");
                if (options.features.addEffects) features.push("ÏòÅÏÉÅÌö®Í≥º Ï∂îÍ∞Ä");
                
                if (features.length > 0) {
                    optionsText += `‚ú® Ï∂îÍ∞Ä Í∏∞Îä•: ${features.join(', ')}\n`;
                }
                
                optionsText += `\nü§ñ ÏÇ¨Ïö© Ï§ëÏù∏ AI: ${options.aiModel.provider} - ${options.aiModel.model}\n`;
                
                // Ï†ÄÏû• Í¥ÄÎ¶¨ ÏÑ§Ï†ï
                if (options.storage.outputFolder) {
                    optionsText += `üìÅ Ï†ÄÏû• Ìè¥Îçî: ${options.storage.outputFolder}\n`;
                }
                optionsText += `üíæ ÏûêÎèô Ï†ÄÏû•: ${options.storage.autoSave ? 'ÌôúÏÑ±Ìôî' : 'ÎπÑÌôúÏÑ±Ìôî'}\n`;
                optionsText += `üìù ÌååÏùºÎ™Ö ÌòïÏãù: ${options.storage.fileNaming === 'timestamp' ? 'ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ' : options.storage.fileNaming === 'sequential' ? 'ÏàúÏ∞®Î≤àÌò∏' : 'ÏÇ¨Ïö©Ïûê Ï†ïÏùò'}\n`;
                
                return optionsText;
            }

            async function analyzeVideoContent(message) {
                if (!uploadedFile || !videoPreview.src) {
                    return "ÏòÅÏÉÅÏù¥ ÏóÖÎ°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Î®ºÏ†Ä ÏòÅÏÉÅÏùÑ ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.";
                }
                
                try {
                    // Extract frames from video
                    const frames = await extractVideoFrames(videoPreview, 3);
                    
                    // Get video metadata
                    const videoInfo = {
                        duration: Math.round(videoPreview.duration),
                        width: videoPreview.videoWidth,
                        height: videoPreview.videoHeight,
                        aspectRatio: (videoPreview.videoWidth / videoPreview.videoHeight).toFixed(2)
                    };
                    
                    // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÏòµÏÖòÎì§ Í∞ÄÏ†∏Ïò§Í∏∞
                    const currentOptions = getCurrentOptions();
                    const optionsText = formatOptionsForAI(currentOptions);
                    
                    const analysisPrompt = `
ÏòÅÏÉÅ Î∂ÑÏÑù Î∞è ÏàèÏ∏† Ï†úÏûë ÏöîÏ≤≠: ${message}

üìπ ÏòÅÏÉÅ Ï†ïÎ≥¥:
- Í∏∏Ïù¥: ${videoInfo.duration}Ï¥à
- Ìï¥ÏÉÅÎèÑ: ${videoInfo.width}x${videoInfo.height}
- ÌôîÎ©¥ÎπÑ: ${videoInfo.aspectRatio}:1

${optionsText}

üéØ ÏöîÏ≤≠ÏÇ¨Ìï≠:
1. ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÏòµÏÖòÎì§ÏùÑ Î™®Îëê Í≥†Î†§ÌïòÏó¨ ÏòÅÏÉÅÏùÑ Î∂ÑÏÑùÌï¥Ï£ºÏÑ∏Ïöî.
2. ÏÑ†ÌÉùÎêú ÌîåÎû´Ìèº(${currentOptions.platforms.join(', ')})Ïóê ÏµúÏ†ÅÌôîÎêú Ìé∏Ïßë Î∞©Î≤ïÏùÑ Ï†úÏïàÌï¥Ï£ºÏÑ∏Ïöî.
3. ${currentOptions.settings.shortsCount}Í∞úÏùò ${currentOptions.settings.shortsLength}Ï¥à ÏàèÏ∏†Î•º ÎßåÎì§Í∏∞ ÏúÑÌïú ÏµúÏ†ÅÏùò Íµ¨Í∞ÑÏùÑ Ï∂îÏ≤úÌï¥Ï£ºÏÑ∏Ïöî.
4. ÏÑ†ÌÉùÎêú Ï≤òÎ¶¨ ÏòµÏÖòÎì§(ÌïòÏù¥ÎùºÏù¥Ìä∏ Ï∂îÏ∂ú, ÌÅ¨Î°≠, ÏÉâÏÉÅÎ≥¥Ï†ï Îì±)Ïùò Ï†ÅÏö© Î∞©Î≤ïÏùÑ Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú ÏÑ§Î™ÖÌï¥Ï£ºÏÑ∏Ïöî.
5. ÎßåÏïΩ ÏÇ¨Ïö©ÏûêÍ∞Ä ÏàèÏ∏† Ï†úÏûëÏùÑ ÏöîÏ≤≠ÌñàÎã§Î©¥, ÎßàÏßÄÎßâÏóê "‚úÖ Î∂ÑÏÑù ÏôÑÎ£å! ÏßÄÍ∏à Î∞îÎ°ú ÏàèÏ∏† Ï†úÏûëÏùÑ ÏãúÏûëÌïòÍ≤†ÏäµÎãàÎã§."ÎùºÍ≥† ÎßêÌï¥Ï£ºÏÑ∏Ïöî.

ÏÇ¨Ïö©ÏûêÏùò ÏöîÏ≤≠Í≥º ÌòÑÏû¨ ÏÑ§Ï†ïÏùÑ Î∞îÌÉïÏúºÎ°ú Ï†ÑÎ¨∏Ï†ÅÏù¥Í≥† Íµ¨Ï≤¥Ï†ÅÏù∏ Ï°∞Ïñ∏ÏùÑ Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî.`;
                    
                    // ÏßÅÏ†ë AI API Ìò∏Ï∂ú (sendToAI ÎåÄÏã†)
                    const selectedModelKey = mainModelSelect.value;
                    const selectedSubModel = subModelSelect.value;
                    const modelData = aiModels[selectedModelKey];
                    
                    if (!modelData.apiKey) {
                        throw new Error(`${modelData.name} API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.`);
                    }

                    const systemPrompt = `ÎãπÏã†ÏùÄ ÏàèÏ∏† ÏòÅÏÉÅ Ï†úÏûëÏùÑ ÎèÑÏôÄÏ£ºÎäî AI Ïñ¥ÏãúÏä§ÌÑ¥Ìä∏ÏûÖÎãàÎã§. 
ÏÇ¨Ïö©ÏûêÍ∞Ä ÏòÅÏÉÅ Ìé∏ÏßëÍ≥º Í¥ÄÎ†®Îêú ÏßàÎ¨∏ÏùÑ ÌïòÎ©¥ ÏπúÏ†àÌïòÍ≥† Ï†ÑÎ¨∏Ï†ÅÏúºÎ°ú ÎãµÎ≥ÄÌï¥Ï£ºÏÑ∏Ïöî.
ÏòÅÏÉÅ Ï≤òÎ¶¨, Ìé∏Ïßë, ÌîåÎû´ÌèºÎ≥Ñ ÏµúÏ†ÅÌôîÏóê ÎåÄÌïú Ï°∞Ïñ∏ÏùÑ Ï†úÍ≥µÌï† Ïàò ÏûàÏäµÎãàÎã§.
ÏÇ¨Ïö©ÏûêÍ∞Ä Íµ¨Ï≤¥Ï†ÅÏù∏ ÏûëÏóÖÏùÑ ÏöîÏ≤≠ÌïòÎ©¥ Îã®Í≥ÑÎ≥ÑÎ°ú ÏïàÎÇ¥Ìï¥Ï£ºÏÑ∏Ïöî.`;

                    switch (selectedModelKey) {
                        case 'claude':
                            return await callClaudeAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        case 'gpt':
                            return await callOpenAIAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        case 'gemini':
                            return await callGeminiAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        case 'groq':
                            return await callGroqAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        case 'perplexity':
                            return await callPerplexityAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        case 'cohere':
                            return await callCohereAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        default:
                            throw new Error('ÏßÄÏõêÌïòÏßÄ ÏïäÎäî AI Î™®Îç∏ÏûÖÎãàÎã§.');
                    }
                    
                } catch (error) {
                    console.error('Video analysis error:', error);
                    return `ÏòÅÏÉÅ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}`;
                }
            }

            // --- AI API Functions ---
            async function sendToAI(message) {
                const selectedModelKey = mainModelSelect.value;
                const selectedSubModel = subModelSelect.value;
                const modelData = aiModels[selectedModelKey];
                
                if (!modelData.apiKey) {
                    throw new Error(`${modelData.name} API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ÏÑ§Ï†ï Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ API ÌÇ§Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.`);
                }

                // Check if this is a video analysis request
                const videoAnalysisKeywords = ['ÏòÅÏÉÅ', 'ÎπÑÎîîÏò§', 'Î∂ÑÏÑù', 'ÌïòÏù¥ÎùºÏù¥Ìä∏', 'Ìé∏Ïßë', 'ÌÅ¨Î°≠', 'ÏûêÎßâ', 'Ìö®Í≥º'];
                const isVideoAnalysis = videoAnalysisKeywords.some(keyword => message.includes(keyword)) && uploadedFile;
                
                if (isVideoAnalysis) {
                    return await analyzeVideoContent(message);
                }

                // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÏòµÏÖòÎì§ÎèÑ ÏùºÎ∞ò ÎåÄÌôîÏóê Ìè¨Ìï®
                const currentOptions = getCurrentOptions();
                const optionsText = formatOptionsForAI(currentOptions);
                
                const systemPrompt = `ÎãπÏã†ÏùÄ ÏàèÏ∏† ÏòÅÏÉÅ Ï†úÏûëÏùÑ ÎèÑÏôÄÏ£ºÎäî AI Ïñ¥ÏãúÏä§ÌÑ¥Ìä∏ÏûÖÎãàÎã§. 
ÏÇ¨Ïö©ÏûêÍ∞Ä ÏòÅÏÉÅ Ìé∏ÏßëÍ≥º Í¥ÄÎ†®Îêú ÏßàÎ¨∏ÏùÑ ÌïòÎ©¥ ÏπúÏ†àÌïòÍ≥† Ï†ÑÎ¨∏Ï†ÅÏúºÎ°ú ÎãµÎ≥ÄÌï¥Ï£ºÏÑ∏Ïöî.
ÏòÅÏÉÅ Ï≤òÎ¶¨, Ìé∏Ïßë, ÌîåÎû´ÌèºÎ≥Ñ ÏµúÏ†ÅÌôîÏóê ÎåÄÌïú Ï°∞Ïñ∏ÏùÑ Ï†úÍ≥µÌï† Ïàò ÏûàÏäµÎãàÎã§.
ÏÇ¨Ïö©ÏûêÍ∞Ä Íµ¨Ï≤¥Ï†ÅÏù∏ ÏûëÏóÖÏùÑ ÏöîÏ≤≠ÌïòÎ©¥ Îã®Í≥ÑÎ≥ÑÎ°ú ÏïàÎÇ¥Ìï¥Ï£ºÏÑ∏Ïöî.

${optionsText}

ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÏòµÏÖòÎì§ÏùÑ Ìï≠ÏÉÅ Í≥†Î†§ÌïòÏó¨ ÎßûÏ∂§Ìòï Ï°∞Ïñ∏ÏùÑ Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî.
ÎßåÏïΩ ÏÇ¨Ïö©ÏûêÍ∞Ä ÏàèÏ∏† Ï†úÏûëÏùÑ ÏöîÏ≤≠ÌïòÎ©¥ "‚úÖ Î∂ÑÏÑù ÏôÑÎ£å! ÏßÄÍ∏à Î∞îÎ°ú ÏàèÏ∏† Ï†úÏûëÏùÑ ÏãúÏûëÌïòÍ≤†ÏäµÎãàÎã§."ÎùºÍ≥† ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî.`;

                switch (selectedModelKey) {
                    case 'claude':
                        return await callClaudeAPI(message, systemPrompt, modelData, selectedSubModel);
                    case 'gpt':
                        return await callOpenAIAPI(message, systemPrompt, modelData, selectedSubModel);
                    case 'gemini':
                        return await callGeminiAPI(message, systemPrompt, modelData, selectedSubModel);
                    case 'groq':
                        return await callGroqAPI(message, systemPrompt, modelData, selectedSubModel);
                    case 'perplexity':
                        return await callPerplexityAPI(message, systemPrompt, modelData, selectedSubModel);
                    case 'cohere':
                        return await callCohereAPI(message, systemPrompt, modelData, selectedSubModel);
                    default:
                        throw new Error('ÏßÄÏõêÌïòÏßÄ ÏïäÎäî AI Î™®Îç∏ÏûÖÎãàÎã§.');
                }
            }

            async function callClaudeAPI(message, systemPrompt, modelData, subModel) {
                // API ÌÇ§ Í≤ÄÏ¶ù
                if (!modelData.apiKey || modelData.apiKey.trim() === '') {
                    throw new Error('Claude API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. API ÏÑ§Ï†ïÏóêÏÑú ÌÇ§Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                }

                if (!modelData.apiKey.startsWith('sk-ant-')) {
                    throw new Error('Claude API ÌÇ§ ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§. API ÌÇ§Îäî "sk-ant-"Î°ú ÏãúÏûëÌï¥Ïïº Ìï©ÎãàÎã§.');
                }

                const modelMap = {
                    "Claude 3.5 Sonnet": "claude-3-5-sonnet-20241022",
                    "Claude 3.5 Haiku": "claude-3-5-haiku-20241022",
                    "Claude 3 Opus": "claude-3-opus-20240229",
                    "Claude 3 Sonnet": "claude-3-sonnet-20240229", 
                    "Claude 3 Haiku": "claude-3-haiku-20240307"
                };

                const requestBody = {
                    model: modelMap[subModel] || "claude-3-5-sonnet-20241022",
                    max_tokens: 1000,
                    system: systemPrompt,
                    messages: [{ role: "user", content: message }]
                };

                // CORS Ïö∞ÌöåÎ•º ÏúÑÌïú ÌîÑÎ°ùÏãú ÏÑúÎ≤Ñ ÏÇ¨Ïö©
                try {
                    console.log('Claude API Ìò∏Ï∂ú ÏãúÎèÑ - ÌîÑÎ°ùÏãú ÏÇ¨Ïö©');
                    
                    // CORS Anywhere ÌîÑÎ°ùÏãú ÏÑúÎ≤Ñ ÏÇ¨Ïö© (Îçî Í∞ÑÎã®Ìïú Î∞©Ïãù)
                    const proxyUrl = `https://cors-anywhere.herokuapp.com/${modelData.endpoint}`;
                    
                    const response = await fetch(proxyUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': modelData.apiKey,
                            'anthropic-version': '2023-06-01',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('ÌîÑÎ°ùÏãú ÏóêÎü¨ ÏùëÎãµ:', errorText);
                        throw new Error(`Claude API Ïò§Î•ò (${response.status}): ${errorText}`);
                    }

                    const claudeResponse = await response.json();
                    console.log('Claude API ÏùëÎãµ:', claudeResponse);

                    // Claude API ÏóêÎü¨ ÏùëÎãµ Ï≤òÎ¶¨
                    if (claudeResponse.error) {
                        throw new Error(`Claude API Ïò§Î•ò: ${claudeResponse.error.message || claudeResponse.error.type || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò'}`);
                    }

                    // Ï†ïÏÉÅ ÏùëÎãµ Ï≤òÎ¶¨
                    if (claudeResponse.content && claudeResponse.content[0] && claudeResponse.content[0].text) {
                        console.log('Claude API ÏÑ±Í≥µ (ÌîÑÎ°ùÏãú Í≤ΩÏú†)');
                        return claudeResponse.content[0].text;
                    } else {
                        console.error('ÏòàÏÉÅÌïòÏßÄ Î™ªÌïú ÏùëÎãµ ÌòïÏãù:', claudeResponse);
                        throw new Error('Claude API ÏùëÎãµ ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.');
                    }

                } catch (error) {
                    console.error('Claude API Ìò∏Ï∂ú Ïã§Ìå®:', error);
                    
                    // Îçî ÏπúÍ∑ºÌïú ÏóêÎü¨ Î©îÏãúÏßÄ Ï†úÍ≥µ
                    if (error.message.includes('CORS') || error.name === 'TypeError' || error.message.includes('Failed to fetch')) {
                        throw new Error(`üö´ Claude API Ïó∞Í≤∞ Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.\n\nüí° Í∞ÑÎã®Ìïú Ìï¥Í≤∞ Î∞©Î≤ï:\n1. ü§ñ Îã§Î•∏ AI Î™®Îç∏ ÏÇ¨Ïö© (GPT, Gemini Îì± - Ï∂îÏ≤ú!)\n2. üîß Î∏åÎùºÏö∞Ï†Ä ÌôïÏû• ÌîÑÎ°úÍ∑∏Îû®: "CORS Unblock" ÏÑ§Ïπò\n3. üåê ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏\n\n‚ú® GPTÎÇò GeminiÎäî Î∞îÎ°ú ÏÇ¨Ïö© Í∞ÄÎä•Ìï©ÎãàÎã§!`);
                    }
                    
                    throw error;
                }
            }

            async function callOpenAIAPI(message, systemPrompt, modelData, subModel) {
                const modelMap = {
                    "GPT-4o": "gpt-4o",
                    "GPT-4o mini": "gpt-4o-mini",
                    "GPT-4 Turbo": "gpt-4-turbo",
                    "GPT-4": "gpt-4",
                    "GPT-3.5 Turbo": "gpt-3.5-turbo",
                    "GPT-3.5 Turbo 16k": "gpt-3.5-turbo-16k"
                };

                const response = await fetch(modelData.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${modelData.apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelMap[subModel] || "gpt-4o-mini",
                        messages: [
                            {
                                role: "system",
                                content: systemPrompt
                            },
                            {
                                role: "user", 
                                content: message
                            }
                        ],
                        max_tokens: 1000,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`OpenAI API Ïò§Î•ò: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            async function callGeminiAPI(message, systemPrompt, modelData, subModel) {
                const modelMap = {
                    "Gemini 2.0 Flash": "gemini-2.0-flash-exp",
                    "Gemini 1.5 Pro": "gemini-1.5-pro-latest",
                    "Gemini 1.5 Flash": "gemini-1.5-flash-latest",
                    "Gemini 1.5 Flash-8B": "gemini-1.5-flash-8b-latest",
                    "Gemini 1.0 Pro": "gemini-pro"
                };
                
                const modelName = modelMap[subModel] || "gemini-pro";
                const url = `${modelData.endpoint}/${modelName}:generateContent?key=${modelData.apiKey}`;

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `${systemPrompt}\n\nÏÇ¨Ïö©Ïûê ÏßàÎ¨∏: ${message}`
                            }]
                        }],
                        generationConfig: {
                            maxOutputTokens: 1000,
                            temperature: 0.7
                        }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Gemini API Ïò§Î•ò: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            }

            async function callGroqAPI(message, systemPrompt, modelData, subModel) {
                const modelMap = {
                    "Llama 3.3 70B": "llama-3.3-70b-versatile",
                    "Llama 3.1 405B": "llama-3.1-405b-reasoning",
                    "Llama 3.1 70B": "llama-3.1-70b-versatile",
                    "Llama 3.1 8B": "llama-3.1-8b-instant",
                    "Llama 3 70B": "llama3-70b-8192",
                    "Llama 3 8B": "llama3-8b-8192",
                    "Mixtral 8x7B": "mixtral-8x7b-32768",
                    "Gemma 2 9B": "gemma2-9b-it",
                    "Gemma 7B": "gemma-7b-it"
                };

                const response = await fetch(modelData.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${modelData.apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelMap[subModel] || "llama-3.1-8b-instant",
                        messages: [
                            {
                                role: "system",
                                content: systemPrompt
                            },
                            {
                                role: "user",
                                content: message
                            }
                        ],
                        max_tokens: 1000,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Groq API Ïò§Î•ò: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            async function callPerplexityAPI(message, systemPrompt, modelData, subModel) {
                const modelMap = {
                    "Llama 3.1 Sonar Large": "llama-3.1-sonar-large-128k-online",
                    "Llama 3.1 Sonar Small": "llama-3.1-sonar-small-128k-online",
                    "Llama 3.1 70B": "llama-3.1-70b-instruct",
                    "Llama 3.1 8B": "llama-3.1-8b-instruct"
                };

                const response = await fetch(modelData.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${modelData.apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelMap[subModel] || "llama-3.1-sonar-small-128k-online",
                        messages: [
                            {
                                role: "system",
                                content: systemPrompt
                            },
                            {
                                role: "user",
                                content: message
                            }
                        ],
                        max_tokens: 1000,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Perplexity API Ïò§Î•ò: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            async function callCohereAPI(message, systemPrompt, modelData, subModel) {
                const modelMap = {
                    "Command R+": "command-r-plus",
                    "Command R": "command-r",
                    "Command": "command",
                    "Command Light": "command-light"
                };

                const response = await fetch(modelData.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${modelData.apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelMap[subModel] || "command-r",
                        message: message,
                        preamble: systemPrompt,
                        max_tokens: 1000,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Cohere API Ïò§Î•ò: ${errorData.message || response.statusText}`);
                }

                const data = await response.json();
                return data.text;
            }

            // --- Theme Switching ---
            function applyInitialTheme() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                document.body.classList.toggle('dark-mode', savedTheme === 'dark');
                themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            }

            themeToggle.addEventListener('click', () => {
                document.body.classList.toggle('dark-mode');
                const isDarkMode = document.body.classList.contains('dark-mode');
                localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
                themeToggle.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
            });

            loadNewVideoButton.addEventListener('click', () => {
                fileInput.click();
            });

            applyInitialTheme();

            // --- File Upload Logic ---
            function handleFile(file) {
                if (!file || !file.type.startsWith('video/')) {
                    alert('Ïú†Ìö®Ìïú ÎπÑÎîîÏò§ ÌååÏùºÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                    return;
                }
                uploadedFile = file;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    videoPreview.src = e.target.result;
                    videoPreview.load();
                    
                    // ÏòÅÏÉÅ Î°úÎî© ÏôÑÎ£åÏãú ÏûêÎèô ÏñºÍµ¥ Î∂ÑÏÑù Ïã§Ìñâ
                    videoPreview.addEventListener('loadedmetadata', () => {
                        // ÏñºÍµ¥ Î∂ÑÏÑù Ï≤¥ÌÅ¨Î∞ïÏä§Í∞Ä Ï≤¥ÌÅ¨ÎêòÏñ¥ ÏûàÍ≥†, ÏûêÎèô Ïã§ÌñâÏù¥ ÌôúÏÑ±ÌôîÎêú Í≤ΩÏö∞
                        if (faceAnalysisCheckbox.checked && autoFaceAnalysis.checked) {
                            setTimeout(() => {
                                faceGalleryContainer.style.display = 'block';
                                
                                // ÏûêÎèô Ïã§Ìñâ Î©îÏãúÏßÄ ÌëúÏãú
                                addMessage('ai', '‚ö° ÏòÅÏÉÅ Î°úÎî© ÏôÑÎ£å! ÏûêÎèôÏúºÎ°ú Î∞∞Ïö∞ ÏñºÍµ¥ Î∂ÑÏÑùÏùÑ ÏãúÏûëÌï©ÎãàÎã§...');
                                
                                // ÏûêÎèôÏúºÎ°ú ÏñºÍµ¥ Î∂ÑÏÑù ÏãúÏûë
                                if (!faceAnalysisInProgress) {
                                    startFaceAnalysis();
                                }
                            }, 1000); // 1Ï¥à ÌõÑ ÏûêÎèô Ïã§Ìñâ
                        } else if (faceAnalysisCheckbox.checked) {
                            // Ï≤¥ÌÅ¨Î∞ïÏä§Îäî ÎêòÏñ¥ÏûàÏßÄÎßå ÏûêÎèô Ïã§ÌñâÏù¥ Í∫ºÏ†∏ÏûàÎäî Í≤ΩÏö∞
                            faceGalleryContainer.style.display = 'block';
                            addMessage('ai', '‚úÖ ÏòÅÏÉÅ Î°úÎî© ÏôÑÎ£å! ÏàòÎèôÏúºÎ°ú "ÏñºÍµ¥ Î∂ÑÏÑù ÏãúÏûë" Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏãúÍ±∞ÎÇò, "‚ö° ÏòÅÏÉÅ Î°úÎî©Ïãú ÏûêÎèô Ïã§Ìñâ" ÏòµÏÖòÏùÑ ÌôúÏÑ±ÌôîÌïòÏÑ∏Ïöî.');
                        }
                    }, { once: true }); // Ïù¥Î≤§Ìä∏Îäî Ìïú Î≤àÎßå Ïã§Ìñâ
                };
                reader.readAsDataURL(file);

                uploadContainer.style.display = 'none';
                videoEditorContainer.style.display = 'block';
                updateProcessButtonState();
            }
            
            uploadContainer.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) handleFile(e.target.files[0]);
            });

            uploadContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadContainer.classList.add('dragover');
            });
            uploadContainer.addEventListener('dragleave', () => {
                uploadContainer.classList.remove('dragover');
            });
            uploadContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadContainer.classList.remove('dragover');
                if (e.dataTransfer.files.length > 0) handleFile(e.dataTransfer.files[0]);
            });

            // --- Platform Selection ---
            platformCards.forEach(card => {
                card.addEventListener('click', () => {
                    card.classList.toggle('selected');
                    updateProcessButtonState();
                });
            });

            function getSelectedPlatforms() {
                return document.querySelectorAll('.platform-card.selected');
            }

            // --- Process Button State ---
            function updateProcessButtonState() {
                const platformsSelected = getSelectedPlatforms().length > 0;
                processBtn.disabled = !uploadedFile || !platformsSelected;
                sendChatBtn.disabled = chatInput.value.trim() === '';
            }

            // --- Chat Panel Logic ---
            function renderChatHistory() {
                chatHistory.innerHTML = '';
                const currentChat = chats.find(chat => chat.id === currentChatId);
                if (!currentChat) return;

                currentChat.messages.forEach(msg => {
                    const messageElement = document.createElement('div');
                    messageElement.classList.add('chat-message', `${msg.sender}-message`);

                    const avatar = `<div class="avatar">${msg.sender === 'ai' ? 'ü§ñ' : 'üë§'}</div>`;
                    const content = `<div class="message-content"><p>${msg.text}</p></div>`;
                    
                    messageElement.innerHTML = avatar + content;
                    chatHistory.appendChild(messageElement);
                });
                chatHistory.scrollTop = chatHistory.scrollHeight;
            }

            function addMessage(sender, text) {
                const currentChat = chats.find(chat => chat.id === currentChatId);
                if (currentChat) {
                    currentChat.messages.push({ sender, text });
                    saveChats();
                    renderChatHistory();
                }
            }

            async function handleSendMessage() {
                const text = chatInput.value.trim();
                if (text) {
                    addMessage('user', text);
                    chatInput.value = '';
                    updateProcessButtonState();
                    
                    // Show typing indicator
                    addMessage('ai', 'ü§î ÏÉùÍ∞ÅÏ§ë...');
                    
                    try {
                        const aiResponse = await sendToAI(text);
                        // Remove typing indicator
                        const currentChat = chats.find(chat => chat.id === currentChatId);
                        if (currentChat && currentChat.messages.length > 0) {
                            currentChat.messages.pop(); // Remove typing indicator
                        }
                        addMessage('ai', aiResponse);
                        
                        // Check if AI suggests processing or analysis is complete
                        if (aiResponse.includes("‚úÖ Î∂ÑÏÑù ÏôÑÎ£å! ÏßÄÍ∏à Î∞îÎ°ú ÏàèÏ∏† Ï†úÏûëÏùÑ ÏãúÏûëÌïòÍ≤†ÏäµÎãàÎã§.") || 
                            aiResponse.includes("ÏòÅÏÉÅ Ï≤òÎ¶¨Î•º ÏãúÏûë") || 
                            text.includes("Ï≤òÎ¶¨ ÏãúÏûë") || 
                            text.includes("ÎßåÎì§Ïñ¥Ï§ò") ||
                            text.includes("ÏàèÏ∏† ÎßåÎì§Ïñ¥") ||
                            text.includes("ÏàèÏ∏† ÏÉùÏÑ±") ||
                            text.includes("Ï†úÏûëÌï¥")) {
                            
                            // ÌîåÎû´ÌèºÏù¥ ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ Í≤ΩÍ≥†
                            const selectedPlatforms = getSelectedPlatforms();
                            if (selectedPlatforms.length === 0) {
                                setTimeout(() => {
                                    addMessage('ai', '‚ö†Ô∏è ÌîåÎû´ÌèºÏùÑ Î®ºÏ†Ä ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî. ÏôºÏ™Ω ÌïòÎã®ÏóêÏÑú YouTube Shorts, Instagram Reels Îì± ÏõêÌïòÎäî ÌîåÎû´ÌèºÏùÑ ÏÑ†ÌÉùÌïú ÌõÑ Îã§Ïãú ÏöîÏ≤≠Ìï¥Ï£ºÏÑ∏Ïöî.');
                                }, 500);
                                return;
                            }
                            
                            setTimeout(() => {
                                addMessage('ai', 'üöÄ ÏÑ†ÌÉùÌïòÏã† ÏòµÏÖòÎì§ÏùÑ Ï†ÅÏö©ÌïòÏó¨ ÏàèÏ∏† Ï†úÏûëÏùÑ ÏãúÏûëÌï©ÎãàÎã§!');
                                processBtn.click();
                            }, 1000);
                        }
                    } catch (error) {
                        // Remove typing indicator
                        const currentChat = chats.find(chat => chat.id === currentChatId);
                        if (currentChat && currentChat.messages.length > 0) {
                            currentChat.messages.pop();
                        }
                        addMessage('ai', `Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}`);
                    }
                }
            }
            
            sendChatBtn.addEventListener('click', handleSendMessage);
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                }
            });
             chatInput.addEventListener('input', updateProcessButtonState);

            // Chat Management
            function saveChats() {
                localStorage.setItem('autoshorts_chats', JSON.stringify(chats));
            }

            function loadChats() {
                const savedChats = localStorage.getItem('autoshorts_chats');
                if (savedChats) {
                    chats = JSON.parse(savedChats);
                    const lastChat = chats[chats.length - 1];
                    if (lastChat) {
                        currentChatId = lastChat.id;
                    } else {
                        startNewChat(false); // Don't save yet
                    }
                } else {
                    startNewChat(false); // Don't save yet
                }
                renderAll();
            }

            function startNewChat(doSave = true) {
                const newChat = {
                    id: Date.now(),
                    messages: [
                        { sender: 'ai', text: `ÏïàÎÖïÌïòÏÑ∏Ïöî! üé¨ ÏàèÏ∏† ÏòÅÏÉÅ Ï†úÏûëÏùÑ ÎèÑÏôÄÎìúÎ¶¥ AI Ïñ¥ÏãúÏä§ÌÑ¥Ìä∏ÏûÖÎãàÎã§.

üìã ÏÇ¨Ïö© Î∞©Î≤ï:
1. ÏòÅÏÉÅÏùÑ ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî
2. ÏõêÌïòÎäî Ï≤òÎ¶¨ ÏòµÏÖòÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî  
3. Ï†ÄÏóêÍ≤å "ÏòÅÏÉÅÏùÑ Î∂ÑÏÑùÌï¥Ï§ò", "ÌïòÏù¥ÎùºÏù¥Ìä∏Î•º Ï∞æÏïÑÏ§ò" Îì±ÏùÑ ÏöîÏ≤≠ÌïòÍ±∞ÎÇò
4. 'ÏòÅÏÉÅ Ï≤òÎ¶¨ ÏãúÏûë' Î≤ÑÌäºÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî

üí° AI Í∏∞Îä•:
- ÏòÅÏÉÅ ÎÇ¥Ïö© Î∂ÑÏÑù Î∞è ÏµúÏ†Å Íµ¨Í∞Ñ Ï∂îÏ≤ú
- ÌîåÎû´ÌèºÎ≥Ñ ÎßûÏ∂§ Ìé∏Ïßë Ï†úÏïà
- ÏûêÎèô ÌïòÏù¥ÎùºÏù¥Ìä∏ Ï∂îÏ∂ú
- Í∞úÏù∏ÌôîÎêú Ìé∏Ïßë Ï°∞Ïñ∏

Í∂ÅÍ∏àÌïú Ï†êÏù¥ ÏûàÏúºÏãúÎ©¥ Ïñ∏Ï†úÎì† Î¨ºÏñ¥Î≥¥ÏÑ∏Ïöî!` }
                    ]
                };
                chats.push(newChat);
                currentChatId = newChat.id;
                if (doSave) {
                   saveChats();
                }
                renderAll();
            }

            newChatBtn.addEventListener('click', () => startNewChat());

            function renderAll() {
                renderChatList();
                renderChatHistory();
            }

            // --- Chat List Logic ---
            function renderChatList() {
                chatList.innerHTML = '';
                if (chats.length === 0) {
                    chatList.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 1rem;">ÎåÄÌôî Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.</p>`;
                    return;
                }

                chats.forEach(chat => {
                    const item = document.createElement('div');
                    item.className = 'chat-list-item';
                    item.dataset.chatId = chat.id;
                    if (chat.id === currentChatId) {
                        item.classList.add('active');
                    }

                    const firstUserMessage = chat.messages.find(m => m.sender === 'user');
                    const title = firstUserMessage ? firstUserMessage.text : (chat.messages[0]?.text || 'ÏÉà ÎåÄÌôî');

                    item.innerHTML = `
                        <input type="checkbox" class="chat-select-checkbox" data-chat-id="${chat.id}">
                        <span class="chat-list-item-title">${title}</span>
                    `;

                    item.querySelector('.chat-list-item-title').addEventListener('click', (e) => {
                        e.stopPropagation();
                        currentChatId = chat.id;
                        renderAll();
                    });

                    chatList.appendChild(item);
                });
            }

            function getSelectedChatIds() {
                const selected = [];
                document.querySelectorAll('.chat-select-checkbox:checked').forEach(cb => {
                    selected.push(Number(cb.dataset.chatId));
                });
                return selected;
            }

            selectAllChats.addEventListener('change', (e) => {
                document.querySelectorAll('.chat-select-checkbox').forEach(cb => {
                    cb.checked = e.target.checked;
                });
            });

            deleteChatsBtn.addEventListener('click', () => {
                const idsToDelete = getSelectedChatIds();
                if (idsToDelete.length === 0) {
                    alert('ÏÇ≠Ï†úÌï† ÎåÄÌôîÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                    return;
                }
                
                if (!confirm(`${idsToDelete.length}Í∞úÏùò ÎåÄÌôîÎ•º Ï†ïÎßê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                    return;
                }

                chats = chats.filter(chat => !idsToDelete.includes(chat.id));

                if (idsToDelete.includes(currentChatId)) {
                    currentChatId = chats.length > 0 ? chats[0].id : null;
                    if (!currentChatId) {
                        startNewChat(false); // Don't save yet, will be saved below
                    }
                }
                
                saveChats();
                renderAll();
            });

            function downloadJSON(data, filename) {
                const jsonStr = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            saveChatsBtn.addEventListener('click', () => {
                downloadJSON(chats, 'all_chats.json');
            });
            
            loadChatsBtn.addEventListener('click', () => {
                loadChatsInput.click();
            });

            loadChatsInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const loadedChats = JSON.parse(event.target.result);
                        if (Array.isArray(loadedChats)) {
                            // Basic validation
                            const validChats = loadedChats.filter(c => c.id && Array.isArray(c.messages));
                            const existingIds = new Set(chats.map(c => c.id));
                            const newChats = validChats.filter(c => !existingIds.has(c.id));
                            
                            chats.push(...newChats);
                            saveChats();
                            renderAll();
                            alert(`${newChats.length}Í∞úÏùò ÏÉà ÎåÄÌôîÎ•º Î∂àÎü¨ÏôîÏäµÎãàÎã§.`);
                        } else {
                            throw new Error('Invalid chat file format.');
                        }
                    } catch (err) {
                        alert('ÎåÄÌôî ÌååÏùºÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                        console.error(err);
                    }
                };
                reader.readAsText(file);
                // Reset input value to allow loading the same file again
                e.target.value = ''; 
            });

            // --- Carousel Logic ---
            function renderCompletedShorts() {
                shortsTrack.innerHTML = '';
                if (allGeneratedShorts.length === 0) {
                    shortsTrack.innerHTML = `<p style="text-align: center; color: var(--text-secondary); padding: 5rem 1rem;">ÏôºÏ™ΩÏùò 'ÏòÅÏÉÅ Ï≤òÎ¶¨ ÏãúÏûë' Î≤ÑÌäºÏùÑ ÎàåÎü¨ ÏàèÏ∏†Î•º ÏÉùÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.</p>`;
                    prevShortBtn.style.display = 'none';
                    nextShortBtn.style.display = 'none';
                    shortsCounter.textContent = '';
                    return;
                }

                allGeneratedShorts.forEach(shortElement => {
                    // Each item needs to be wrapped for the carousel
                    const slide = document.createElement('div');
                    slide.style.flex = '0 0 100%';
                    slide.appendChild(shortElement);
                    shortsTrack.appendChild(slide);
                });

                updateCarousel();
            }

            function updateCarousel() {
                // Move the track
                const offset = -currentShortIndex * 100;
                shortsTrack.style.transform = `translateX(${offset}%)`;

                // Update counter
                shortsCounter.textContent = `${currentShortIndex + 1} / ${allGeneratedShorts.length}`;

                // Update buttons visibility
                prevShortBtn.style.display = currentShortIndex > 0 ? 'block' : 'none';
                nextShortBtn.style.display = currentShortIndex < allGeneratedShorts.length - 1 ? 'block' : 'none';

                // Pause all videos first
                shortsTrack.querySelectorAll('video').forEach(v => v.pause());

                // Autoplay current video on hover
                const currentSlide = shortsTrack.children[currentShortIndex];
                if (currentSlide) {
                    const videoContainer = currentSlide.querySelector('.video-container');
                    const video = currentSlide.querySelector('video');
                    if (videoContainer && video) {
                         videoContainer.addEventListener('mouseenter', () => video.play().catch(e=>console.log("Autoplay failed", e)));
                         videoContainer.addEventListener('mouseleave', () => video.pause());
                    }
                }
            }

            prevShortBtn.addEventListener('click', () => {
                if (currentShortIndex > 0) {
                    currentShortIndex--;
                    updateCarousel();
                }
            });

            nextShortBtn.addEventListener('click', () => {
                if (currentShortIndex < allGeneratedShorts.length - 1) {
                    currentShortIndex++;
                    updateCarousel();
                }
            });

            // --- Video Processing Functions ---
            async function processVideoWithAI() {
                if (!uploadedFile || !videoPreview.src) {
                    throw new Error("Ï≤òÎ¶¨Ìï† ÏòÅÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§.");
                }
                
                // Get processing options
                const options = {
                    autoHighlight: document.getElementById('autoHighlight').checked,
                    autoCrop: document.getElementById('autoCrop').checked,
                    colorCorrection: document.getElementById('colorCorrection').checked,
                    videoStabilization: document.getElementById('videoStabilization').checked,
                    removeSilence: document.getElementById('removeSilence').checked,
                    enhanceAudio: document.getElementById('enhanceAudio').checked,
                    noiseReduction: document.getElementById('noiseReduction').checked,
                    addTitle: document.getElementById('addTitle').checked,
                    addSubtitles: document.getElementById('addSubtitles').checked,
                    addEffects: document.getElementById('addEffects').checked,
                    shortsLength: parseInt(document.getElementById('shortsLength').value),
                    shortsCount: parseInt(document.getElementById('shortsCount').value)
                };
                
                // Get current options for AI analysis
                const currentOptions = getCurrentOptions();
                const optionsText = formatOptionsForAI(currentOptions);
                
                // Ask AI for processing recommendations
                const analysisMessage = `
AI Í∏∞Î∞ò ÏàèÏ∏† ÏûêÎèô Ï†úÏûëÏùÑ ÏãúÏûëÌï©ÎãàÎã§.

${optionsText}

üéØ Ï†úÏûë Î™©Ìëú:
- ${options.shortsCount}Í∞úÏùò ${options.shortsLength}Ï¥à ÏàèÏ∏† ÏÉùÏÑ±
- ÏÑ†ÌÉùÎêú ÌîåÎû´ÌèºÏóê ÏµúÏ†ÅÌôîÎêú Ìé∏Ïßë
- Î™®Îì† ÏÑ†ÌÉùÎêú Ï≤òÎ¶¨ ÏòµÏÖò Ï†ÅÏö©

ÏòÅÏÉÅÏùÑ Î∂ÑÏÑùÌïòÏó¨ ÏµúÏ†ÅÏùò Íµ¨Í∞ÑÏùÑ ÏÑ†ÌÉùÌïòÍ≥† Ìé∏Ïßë Î∞©Ìñ•ÏùÑ Ï†úÏãúÌï¥Ï£ºÏÑ∏Ïöî.`;
                
                const aiAnalysis = await analyzeVideoContent(analysisMessage);
                addMessage('ai', aiAnalysis);
                
                return await generateShortsWithAI(options, aiAnalysis);
            }
            
            async function generateShortsWithAI(options, aiAnalysis) {
                const originalVideo = videoPreview;
                const videoSrc = originalVideo.src;
                const originalDuration = originalVideo.duration;
                const generatedShorts = [];
                
                if (originalDuration < options.shortsLength) {
                    throw new Error(`ÏõêÎ≥∏ ÏòÅÏÉÅ(${Math.round(originalDuration)}Ï¥à)Ïù¥ ÏöîÏ≤≠Îêú ÏàèÏ∏† Í∏∏Ïù¥(${options.shortsLength}Ï¥à)Î≥¥Îã§ ÏßßÏäµÎãàÎã§.`);
                }
                
                // AI Î∂ÑÏÑùÏùÑ Î∞îÌÉïÏúºÎ°ú ÏµúÏ†ÅÏùò Íµ¨Í∞Ñ ÏÑ†ÌÉù
                const segments = await selectBestSegments(originalDuration, options.shortsLength, options.shortsCount, aiAnalysis);
                
                for (let i = 0; i < segments.length; i++) {
                    const segment = segments[i];
                    const newShort = await createShortFromSegment(segment, videoSrc, options, i + 1);
                    generatedShorts.push(newShort);
                }
                
                return generatedShorts;
            }
            
            async function selectBestSegments(duration, segmentLength, count, aiAnalysis) {
                // Í∞ÑÎã®Ìïú ÏïåÍ≥†Î¶¨Ï¶òÏúºÎ°ú Íµ¨Í∞Ñ ÏÑ†ÌÉù (ÎÇòÏ§ëÏóê AI Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Îçî ÌôúÏö©Ìï† Ïàò ÏûàÏùå)
                const segments = [];
                const maxStartTime = duration - segmentLength;
                
                if (count === 1) {
                    // Îã®Ïùº ÏàèÏ∏†Ïùò Í≤ΩÏö∞ Ï§ëÍ∞Ñ Î∂ÄÎ∂Ñ ÏÑ†ÌÉù
                    const startTime = Math.max(0, (duration - segmentLength) / 2);
                    segments.push({
                        startTime: startTime,
                        endTime: startTime + segmentLength,
                        confidence: 0.8
                    });
                } else {
                    // Ïó¨Îü¨ ÏàèÏ∏†Ïùò Í≤ΩÏö∞ Í∑†Îì±ÌïòÍ≤å Î∂ÑÏÇ∞
                    const interval = maxStartTime / (count - 1);
                    for (let i = 0; i < count; i++) {
                        const startTime = Math.min(i * interval, maxStartTime);
                        segments.push({
                            startTime: startTime,
                            endTime: startTime + segmentLength,
                            confidence: 0.7 + (Math.random() * 0.2) // ÏûÑÏãú Ïã†Î¢∞ÎèÑ
                        });
                    }
                }
                
                return segments;
            }
            
            async function createShortFromSegment(segment, videoSrc, options, index) {
                const segmentSrc = `${videoSrc}#t=${segment.startTime},${segment.endTime}`;
                
                // Ï†ÅÏö©Îêú ÏòµÏÖòÎì§ÏùÑ ÌëúÏãúÌïòÍ∏∞ ÏúÑÌïú Î∞∞ÏßÄ ÏÉùÏÑ±
                const appliedOptions = [];
                if (options.autoHighlight) appliedOptions.push("üéØ ÌïòÏù¥ÎùºÏù¥Ìä∏");
                if (options.autoCrop) appliedOptions.push("‚úÇÔ∏è ÌÅ¨Î°≠");
                if (options.colorCorrection) appliedOptions.push("üé® ÏÉâÏÉÅÎ≥¥Ï†ï");
                if (options.videoStabilization) appliedOptions.push("üìπ ÏïàÏ†ïÌôî");
                if (options.removeSilence) appliedOptions.push("üîá Î¨¥ÏùåÏ†úÍ±∞");
                if (options.enhanceAudio) appliedOptions.push("üîä ÏùåÏßàÌñ•ÏÉÅ");
                if (options.addSubtitles) appliedOptions.push("üí¨ ÏûêÎßâ");
                if (options.addEffects) appliedOptions.push("‚ú® Ìö®Í≥º");
                
                const optionsBadges = appliedOptions.length > 0 
                    ? `<div style="font-size: 0.75rem; color: var(--accent-color); margin-bottom: 0.5rem;">${appliedOptions.join(' ')}</div>`
                    : '';
                
                const newShort = document.createElement('div');
                newShort.className = 'short-item';
                newShort.innerHTML = `
                    <div class="video-container">
                        <video src="${segmentSrc}" loop preload="metadata"></video>
                        <div class="video-overlay">‚ñ∂</div>
                        <button class="volume-btn">üîä</button>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar-fill"></div>
                    </div>
                    <div class="short-info">
                        ${optionsBadges}
                        <span style="font-size: 0.9rem; color: var(--text-secondary);">
                            ÏàèÏ∏† #${index} (${Math.round(segment.startTime)}s-${Math.round(segment.endTime)}s)
                        </span>
                        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                            <button class="download-btn" onclick="downloadSingleShort(this, ${index})">Îã§Ïö¥Î°úÎìú</button>
                            <button class="upload-btn">ÏóÖÎ°úÎìú</button>
                            <button class="delete-btn">ÏÇ≠Ï†ú</button>
                        </div>
                    </div>`;
                
                // Add event listeners
                setupShortEventListeners(newShort);
                
                return newShort;
            }
            
            function setupShortEventListeners(shortElement) {
                const video = shortElement.querySelector('video');
                const volumeBtn = shortElement.querySelector('.volume-btn');
                const progressBarContainer = shortElement.querySelector('.progress-bar-container');
                const progressBarFill = shortElement.querySelector('.progress-bar-fill');
                const uploadBtn = shortElement.querySelector('.upload-btn');
                const deleteBtn = shortElement.querySelector('.delete-btn');

                // Volume control
                volumeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (video.muted) {
                        video.muted = false;
                        volumeBtn.textContent = 'üîä';
                    } else {
                        video.muted = true;
                        volumeBtn.textContent = 'üîá';
                    }
                });

                // Progress bar update
                video.addEventListener('timeupdate', () => {
                    if (video.duration) {
                        const progressPercent = (video.currentTime / video.duration) * 100;
                        progressBarFill.style.width = `${progressPercent}%`;
                    }
                });

                // Seek on progress bar click
                progressBarContainer.addEventListener('click', (e) => {
                    const rect = progressBarContainer.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const width = progressBarContainer.clientWidth;
                    if (video.duration) {
                        video.currentTime = (clickX / width) * video.duration;
                    }
                });
                
                // Upload button opens modal
                uploadBtn.addEventListener('click', () => {
                    const uploadModal = document.getElementById('uploadModal');
                    uploadModal.classList.add('active');
                });
                
                // Delete button removes the short
                deleteBtn.addEventListener('click', () => {
                    const indexToRemove = allGeneratedShorts.findIndex(item => item === shortElement);
                    if (indexToRemove > -1) {
                        allGeneratedShorts.splice(indexToRemove, 1);
                        if (allGeneratedShorts.length === 0) {
                            currentShortIndex = 0;
                        } else {
                            if (currentShortIndex >= indexToRemove) {
                                currentShortIndex = Math.max(0, currentShortIndex - 1);
                            }
                        }
                        renderCompletedShorts();
                    }
                });
            }

            // --- Main Processing Logic ---
            processBtn.addEventListener('click', async () => {
                if (processBtn.disabled) return;
                
                addMessage('ai', "üöÄ AI Í∏∞Î∞ò ÏòÅÏÉÅ Ï≤òÎ¶¨Î•º ÏãúÏûëÌï©ÎãàÎã§. Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî...");

                shortsTrack.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 5rem 1rem;">AIÍ∞Ä ÏòÅÏÉÅÏùÑ Î∂ÑÏÑùÌïòÍ≥† Ï≤òÎ¶¨ÌïòÍ≥† ÏûàÏäµÎãàÎã§...</p>';
                allGeneratedShorts = [];
                currentShortIndex = 0;
                updateCarousel();
                
                                try {
                    const processedShorts = await processVideoWithAI();
                    allGeneratedShorts = processedShorts;
                    renderCompletedShorts();
                    
                    addMessage('ai', `‚úÖ ${processedShorts.length}Í∞úÏùò AI ÏµúÏ†ÅÌôîÎêú ÏàèÏ∏† ÏòÅÏÉÅÏù¥ ÏôÑÏÑ±ÎêòÏóàÏäµÎãàÎã§! Ïò§Î•∏Ï™Ω Ìå®ÎÑêÏóêÏÑú ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.`);
                    
                    // Auto-save if enabled
                    if (autoSave.checked) {
                        setTimeout(() => autoSaveShorts(), 1000);
                    }
                } catch (error) {
                     console.error('Processing error:', error);
                     addMessage('ai', `‚ùå Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}`);
                     shortsTrack.innerHTML = `<p style="text-align: center; color: var(--error-text); padding: 5rem 1rem;">Ï≤òÎ¶¨ Ïã§Ìå®: ${error.message}</p>`;
                 }
             });

            // --- Upload Modal Logic ---
            const uploadModal = document.getElementById('uploadModal');
            const cancelUpload = document.getElementById('cancelUpload');
            const confirmUpload = document.getElementById('confirmUpload');
            
            cancelUpload.addEventListener('click', () => {
                uploadModal.classList.remove('active');
            });
            
            confirmUpload.addEventListener('click', () => {
                const title = document.getElementById('videoTitle').value;
                const description = document.getElementById('videoDescription').value;
                const tags = document.getElementById('videoTags').value;
                
                if (!title.trim()) {
                    alert('Ï†úÎ™©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                    return;
                }
                
                // Ïã§Ï†úÎ°úÎäî Ïó¨Í∏∞ÏÑú ÏÑ†ÌÉùÎêú ÌîåÎû´ÌèºÏóê ÏóÖÎ°úÎìúÌïòÎäî Î°úÏßÅÏù¥ Îì§Ïñ¥Í∞ëÎãàÎã§
                const selectedPlatforms = Array.from(getSelectedPlatforms()).map(p => p.dataset.platform);
                
                addMessage('ai', `${selectedPlatforms.join(', ')}Ïóê "${title}" Ï†úÎ™©ÏúºÎ°ú ÏóÖÎ°úÎìúÎ•º ÏãúÏûëÌï©ÎãàÎã§...`);
                
                // ÏãúÎÆ¨Î†àÏù¥ÏÖò
                setTimeout(() => {
                    addMessage('ai', '‚úÖ ÏóÖÎ°úÎìúÍ∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!');
                }, 2000);
                
                uploadModal.classList.remove('active');
                
                // Ìèº Ï¥àÍ∏∞Ìôî
                document.getElementById('videoTitle').value = '';
                document.getElementById('videoDescription').value = '';
                document.getElementById('videoTags').value = '';
            });
            
            // Close modal when clicking outside
            uploadModal.addEventListener('click', (e) => {
                if (e.target === uploadModal) {
                    uploadModal.classList.remove('active');
                }
            });

            // --- Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò ---
            function drawRoundedRect(ctx, x, y, width, height, radius) {
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            }

            // --- AI API ÌÜµÌï© Ìï®Ïàò ---
            async function callAIAPI(modelKey, subModel, message) {
                const modelData = aiModels[modelKey];
                
                if (!modelData.apiKey) {
                    throw new Error(`${modelData.name} API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.`);
                }

                const systemPrompt = `ÎãπÏã†ÏùÄ ÏòÅÏÉÅ Î∂ÑÏÑù Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§. Ï£ºÏñ¥ÏßÑ ÏöîÏ≤≠ÏùÑ Î∂ÑÏÑùÌïòÏó¨ Ï†ïÌôïÌïú Ï†ïÎ≥¥Î•º Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî.`;

                try {
                    switch (modelKey) {
                        case 'claude':
                            return await callClaudeAPI(message, systemPrompt, modelData, subModel);
                        case 'gpt':
                            return await callOpenAIAPI(message, systemPrompt, modelData, subModel);
                        case 'gemini':
                            return await callGeminiAPI(message, systemPrompt, modelData, subModel);
                        case 'groq':
                            return await callGroqAPI(message, systemPrompt, modelData, subModel);
                        case 'perplexity':
                            return await callPerplexityAPI(message, systemPrompt, modelData, subModel);
                        case 'cohere':
                            return await callCohereAPI(message, systemPrompt, modelData, subModel);
                        default:
                            throw new Error('ÏßÄÏõêÌïòÏßÄ ÏïäÎäî AI Î™®Îç∏ÏûÖÎãàÎã§.');
                    }
                } catch (error) {
                    console.error(`${modelKey} API Ìò∏Ï∂ú Ïã§Ìå®:`, error);
                    throw error;
                }
            }

            // --- Face Analysis Logic ---
            faceAnalysisCheckbox.addEventListener('change', () => {
                if (faceAnalysisCheckbox.checked) {
                    faceGalleryContainer.style.display = 'block';
                } else {
                    faceGalleryContainer.style.display = 'none';
                }
            });

            analyzeFacesBtn.addEventListener('click', async () => {
                if (!uploadedFile) {
                    alert('Î®ºÏ†Ä ÏòÅÏÉÅÏùÑ ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.');
                    return;
                }

                if (faceAnalysisInProgress) {
                    alert('Ïù¥ÎØ∏ Î∂ÑÏÑùÏù¥ ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§.');
                    return;
                }

                console.log('ÏñºÍµ¥ Î∂ÑÏÑù ÏãúÏûë...');
                await startFaceAnalysis();
            });

            generateFaceImagesBtn.addEventListener('click', async () => {
                if (detectedFaces.length === 0) {
                    alert('Î®ºÏ†Ä ÏñºÍµ¥ Î∂ÑÏÑùÏùÑ ÏôÑÎ£åÌï¥Ï£ºÏÑ∏Ïöî.');
                    return;
                }

                await generateFaceImages();
            });

            downloadFaceGalleryBtn.addEventListener('click', () => {
                downloadFaceGallery();
            });

            // Face-api.js Î™®Îç∏ Î°úÎî© (Ïó¨Îü¨ CDN ÏãúÎèÑ)
            async function loadFaceApiModels() {
                if (faceApiModelsLoaded) return true;
                
                // Ïó¨Îü¨ CDN URL ÏãúÎèÑ
                const modelUrls = [
                    'https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights',
                    'https://unpkg.com/face-api.js@0.22.2/weights',
                    'https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@master/weights'
                ];
                
                for (let i = 0; i < modelUrls.length; i++) {
                    const MODEL_URL = modelUrls[i];
                    
                    try {
                        faceProgressText.textContent = `ü§ñ Face-api.js Î™®Îç∏ Î°úÎî© Ï§ë... (CDN ${i + 1}/${modelUrls.length})`;
                        faceProgressFill.style.width = '10%';
                        
                        console.log(`Trying to load models from: ${MODEL_URL}`);
                        
                        // ÌïÑÏàò Î™®Îç∏Îì§ Î°úÎìú (ÌÉÄÏûÑÏïÑÏõÉ Ï∂îÍ∞Ä)
                        await Promise.race([
                            faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
                        ]);
                        faceProgressFill.style.width = '30%';
                        
                        await Promise.race([
                            faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
                        ]);
                        faceProgressFill.style.width = '50%';
                        
                        await Promise.race([
                            faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
                        ]);
                        faceProgressFill.style.width = '70%';
                        
                        await Promise.race([
                            faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
                        ]);
                        faceProgressFill.style.width = '85%';
                        
                        await Promise.race([
                            faceapi.nets.ageGenderNet.loadFromUri(MODEL_URL),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
                        ]);
                        faceProgressFill.style.width = '100%';
                        
                        faceApiModelsLoaded = true;
                        faceProgressText.textContent = `‚úÖ Face-api.js Î™®Îç∏ Î°úÎî© ÏôÑÎ£å! (CDN ${i + 1} ÏÑ±Í≥µ)`;
                        
                        console.log('Face-api.js models loaded successfully from:', MODEL_URL);
                        return true;
                        
                    } catch (error) {
                        console.error(`Failed to load from CDN ${i + 1}:`, error);
                        faceProgressText.textContent = `‚ùå CDN ${i + 1} Ïã§Ìå®, Îã§Î•∏ ÏÑúÎ≤Ñ ÏãúÎèÑ Ï§ë...`;
                        
                        // ÎßàÏßÄÎßâ CDNÎèÑ Ïã§Ìå®Ìïú Í≤ΩÏö∞
                        if (i === modelUrls.length - 1) {
                            faceProgressText.textContent = '‚ùå Î™®Îì† CDN Î°úÎî© Ïã§Ìå®. Í∞ÑÎã®Ìïú ÏñºÍµ¥ Î∂ÑÏÑù Î™®ÎìúÎ°ú Ï†ÑÌôòÌï©ÎãàÎã§.';
                            return false;
                        }
                        
                        // Ïû†Ïãú ÎåÄÍ∏∞ ÌõÑ Îã§Ïùå CDN ÏãúÎèÑ
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
                
                return false;
            }

            async function startFaceAnalysis() {
                faceAnalysisInProgress = true;
                analysisProgress.style.display = 'block';
                analyzeFacesBtn.disabled = true;
                faceResults.innerHTML = '';

                try {
                    // Face-api.js Î™®Îç∏ Î°úÎî© ÏãúÎèÑ
                    const modelsLoaded = await loadFaceApiModels();
                    
                    if (modelsLoaded) {
                        // Face-api.jsÎ•º ÏÇ¨Ïö©Ìïú Í≥†Í∏â ÏñºÍµ¥ Î∂ÑÏÑù
                        faceProgressText.textContent = 'üé¨ Face-api.jsÎ°ú Ï†ïÎ∞Ä ÏñºÍµ¥ Î∂ÑÏÑù Ï§ë...';
                        detectedFaces = await analyzeVideoWithFaceAPI();
                        faceProgressText.textContent = `‚úÖ ${detectedFaces.length}Î™ÖÏùò Ïã§Ï†ú Î∞∞Ïö∞ ÏñºÍµ¥ÏùÑ Ï†ïÎ∞Ä Î∂ÑÏÑùÌñàÏäµÎãàÎã§!`;
                    } else {
                        // Í∞ÑÎã®Ìïú ÏñºÍµ¥ Î∂ÑÏÑù Î™®Îìú
                        faceProgressText.textContent = 'üéØ Í∞ÑÎã®Ìïú ÏñºÍµ¥ Î∂ÑÏÑù Î™®ÎìúÎ°ú ÏßÑÌñâ Ï§ë...';
                        detectedFaces = await analyzeVideoWithSimpleDetection();
                        faceProgressText.textContent = `‚úÖ ${detectedFaces.length}Î™ÖÏùò Î∞∞Ïö∞Î•º Í∞ÑÎã® Î∂ÑÏÑùÌñàÏäµÎãàÎã§! (Í≥†Í∏â Í∏∞Îä•ÏùÄ Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ ÌõÑ Ïû¨ÏãúÎèÑ)`;
                    }
                    
                    console.log('Í∞êÏßÄÎêú ÏñºÍµ¥:', detectedFaces);
                    
                    displayDetectedFaces();
                    generateFaceImagesBtn.style.display = 'inline-flex';
                    
                } catch (error) {
                    console.error('Face analysis error:', error);
                    faceProgressText.textContent = `‚ùå ÏñºÍµ¥ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}`;
                } finally {
                    faceAnalysisInProgress = false;
                    analyzeFacesBtn.disabled = false;
                }
            }

            async function analyzeVideoWithFaceAPI() {
                try {
                    // 1. ÏòÅÏÉÅÏóêÏÑú ÌîÑÎ†àÏûÑÎì§ Ï∂îÏ∂ú
                    faceProgressFill.style.width = '10%';
                    faceProgressText.textContent = 'üìπ ÏòÅÏÉÅÏóêÏÑú ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú Ï§ë...';
                    
                    const frames = await extractVideoFramesForAnalysis();
                    
                    faceProgressFill.style.width = '30%';
                    faceProgressText.textContent = 'üîç Í∞Å ÌîÑÎ†àÏûÑÏóêÏÑú ÏñºÍµ¥ Í∞êÏßÄ Ï§ë...';
                    
                    // 2. Í∞Å ÌîÑÎ†àÏûÑÏóêÏÑú ÏñºÍµ¥ Í∞êÏßÄ
                    const allDetections = [];
                    for (let i = 0; i < frames.length; i++) {
                        const frame = frames[i];
                        
                        // ÌòÑÏû¨ ÌîÑÎ†àÏûÑ ÏßÑÌñâÎ•† ÌëúÏãú
                        const frameProgress = 30 + (i / frames.length) * 40;
                        faceProgressFill.style.width = `${frameProgress}%`;
                        faceProgressText.textContent = `üîç ÌîÑÎ†àÏûÑ ${i + 1}/${frames.length} Î∂ÑÏÑù Ï§ë...`;
                        
                        // Face-api.jsÎ°ú ÏñºÍµ¥ Í∞êÏßÄ
                        const detections = await detectFacesInFrame(frame);
                        
                        // Í∞êÏßÄÎêú ÏñºÍµ¥Îì§ÏùÑ ÏãúÍ∞ÑÍ≥º Ìï®Íªò Ï†ÄÏû•
                        detections.forEach(detection => {
                            allDetections.push({
                                ...detection,
                                timestamp: frame.timestamp,
                                frameIndex: i
                            });
                        });
                        
                        // ÏßßÏùÄ ÎåÄÍ∏∞ (Î∏åÎùºÏö∞Ï†ÄÍ∞Ä ÎÑàÎ¨¥ Î∞îÏÅòÏßÄ ÏïäÎèÑÎ°ù)
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    faceProgressFill.style.width = '70%';
                                    faceProgressText.textContent = 'üî• MAX MODE: Ï†ÑÎ¨∏Í∏â Î∞∞Ïö∞ Ïù∏Ïãù ÏãúÏûë...';
                
                // üî• MAX MODE: Cursor Pro ÌôúÏÑ±Ìôî ÏÉÅÌÉúÏóêÏÑú ÏµúÍ≥† ÌíàÏßà Ï≤òÎ¶¨
                console.log('üöÄ Cursor Max Mode ÌôúÏÑ±Ìôî - Ï†ÑÎ¨∏Í∏â Î∞∞Ïö∞ Ïù∏Ïãù ÏãúÏûë!');
                
                // 3. Í∞êÏßÄÎêú ÏñºÍµ¥Îì§ÏùÑ Ïù∏Î¨ºÎ≥ÑÎ°ú Í∑∏Î£πÌôî (MAX MODE)
                const groupedFaces = await groupFacesByPerson(allDetections);
                
                console.log('üéØ MAX MODE ÏôÑÎ£å:', groupedFaces.length, 'Í∞ú ÏµúÏ†ÅÌôîÎêú Î∞∞Ïö∞ Í∑∏Î£π ÏÉùÏÑ±');
                    
                    faceProgressFill.style.width = '90%';
                    faceProgressText.textContent = 'üìä Î∞∞Ïö∞ Ï†ïÎ≥¥ ÏÉùÏÑ± Ï§ë...';
                    
                    // 4. ÏµúÏ¢Ö Î∞∞Ïö∞ Ï†ïÎ≥¥ ÏÉùÏÑ±
                    const actorInfo = await generateActorInfo(groupedFaces);
                    
                    faceProgressFill.style.width = '100%';
                    
                    return actorInfo;
                    
                } catch (error) {
                    console.error('Face-api analysis failed:', error);
                    faceProgressText.textContent = 'Face-api Î∂ÑÏÑù Ïã§Ìå®, Í∏∞Î≥∏ Î∂ÑÏÑù ÏÇ¨Ïö© Ï§ë...';
                    
                    // Face-api Î∂ÑÏÑù Ïã§Ìå® Ïãú Í∏∞Î≥∏ Î∂ÑÏÑù Í≤∞Í≥º Ï†úÍ≥µ
                    return await fallbackFaceDetection();
                }
            }

            async function extractVideoFramesForAnalysis() {
                const video = videoPreview;
                const duration = video.duration;
                const frameCount = Math.min(20, Math.max(5, Math.floor(duration / 10))); // 10Ï¥àÎßàÎã§ 1ÌîÑÎ†àÏûÑ, ÏµúÏÜå 5Í∞ú, ÏµúÎåÄ 20Í∞ú
                const frames = [];
                
                for (let i = 0; i < frameCount; i++) {
                    const timestamp = (duration / frameCount) * i;
                    const canvas = await captureVideoFrameAtTime(video, timestamp);
                    
                    if (canvas) {
                        frames.push({
                            canvas: canvas,
                            timestamp: timestamp,
                            timeString: formatTimestamp(timestamp)
                        });
                    }
                }
                
                return frames;
            }

            async function captureVideoFrameAtTime(video, timestamp) {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    const tempVideo = document.createElement('video');
                    tempVideo.src = video.src;
                    tempVideo.muted = true;
                    tempVideo.crossOrigin = 'anonymous';
                    
                    tempVideo.addEventListener('loadedmetadata', () => {
                        canvas.width = tempVideo.videoWidth;
                        canvas.height = tempVideo.videoHeight;
                        tempVideo.currentTime = timestamp;
                    });
                    
                    tempVideo.addEventListener('seeked', () => {
                        try {
                            ctx.drawImage(tempVideo, 0, 0, canvas.width, canvas.height);
                            resolve(canvas);
                        } catch (error) {
                            console.error('Frame capture error:', error);
                            resolve(null);
                        }
                    });
                    
                    tempVideo.addEventListener('error', () => {
                        resolve(null);
                    });
                });
            }

            async function detectFacesInFrame(frame) {
                try {
                    const canvas = frame.canvas;
                    
                    // Face-api.jsÎ°ú ÏñºÍµ¥ Í∞êÏßÄ + ÎûúÎìúÎßàÌÅ¨ + ÌëúÏ†ï + ÎÇòÏù¥/ÏÑ±Î≥Ñ
                    const detections = await faceapi
                        .detectAllFaces(canvas, new faceapi.TinyFaceDetectorOptions())
                        .withFaceLandmarks()
                        .withFaceDescriptors()
                        .withFaceExpressions()
                        .withAgeAndGender();
                    
                    return detections.map((detection, index) => ({
                        id: `${frame.timestamp}_${index}`,
                        box: detection.detection.box,
                        score: detection.detection.score,
                        landmarks: detection.landmarks,
                        descriptor: detection.descriptor,
                        expressions: detection.expressions,
                        age: Math.round(detection.age),
                        gender: detection.gender,
                        genderProbability: detection.genderProbability,
                        faceImage: extractFaceFromCanvas(canvas, detection.detection.box)
                    }));
                    
                } catch (error) {
                    console.error('Face detection error:', error);
                    return [];
                }
            }

            function extractFaceFromCanvas(canvas, box) {
                try {
                    const faceCanvas = document.createElement('canvas');
                    const ctx = faceCanvas.getContext('2d');
                    
                    const padding = 20;
                    const faceWidth = box.width + padding * 2;
                    const faceHeight = box.height + padding * 2;
                    
                    faceCanvas.width = faceWidth;
                    faceCanvas.height = faceHeight;
                    
                    // ÏñºÍµ¥ ÏòÅÏó≠ÏùÑ Ïó¨Ïú†ÏûàÍ≤å Ï∂îÏ∂ú
                    ctx.drawImage(
                        canvas,
                        Math.max(0, box.x - padding),
                        Math.max(0, box.y - padding),
                        Math.min(canvas.width - box.x + padding, faceWidth),
                        Math.min(canvas.height - box.y + padding, faceHeight),
                        0, 0, faceWidth, faceHeight
                    );
                    
                    return faceCanvas.toDataURL('image/jpeg', 0.8);
                    
                } catch (error) {
                    console.error('Face extraction error:', error);
                    return null;
                }
            }

            // üî• MAX MODE: Ï†ÑÎ¨∏Í∏â ÏñºÍµ¥ Ïù∏Ïãù ÏãúÏä§ÌÖú
            async function groupFacesByPerson(allDetections) {
                console.log('üî• MAX MODE: Í≥†Í∏â Î∞∞Ïö∞ Ïù∏Ïãù ÏãúÏä§ÌÖú ÏãúÏûë');
                console.log('üìä ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞:', allDetections.length, 'Í∞ú ÏñºÍµ¥ Í∞êÏßÄ');
                
                // üéØ ÏïàÏ†ïÏ†ÅÏù∏ Î≥ëÌï©ÏùÑ ÏúÑÌïú Ïö∞ÏÑ† Ï≤òÎ¶¨
                if (allDetections.length >= 4) {
                    console.log('üß† Ïä§ÎßàÌä∏ Î≥ëÌï© ÏãúÏä§ÌÖú Ïã§Ìñâ Ï§ë...');
                    return await smartMergeDetections(allDetections);
                }
                
                try {
                
                // 1Îã®Í≥Ñ: Í≥†Í∏â ÏñºÍµ¥ ÌäπÏßï Ï∂îÏ∂ú Î∞è Ï†ïÍ∑úÌôî
                const enhancedDetections = await enhanceFaceFeatures(allDetections);
                
                // 2Îã®Í≥Ñ: Îã§Ï§ë Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞ Î∞©Ïãù Ï†ÅÏö©
                const groups = [];
                
                for (const detection of enhancedDetections) {
                    let bestMatch = null;
                    let bestSimilarity = 0; // Ïú†ÏÇ¨ÎèÑ Í∏∞Î∞ò (ÎÜíÏùÑÏàòÎ°ù Ïú†ÏÇ¨)
                    
                    // Î™®Îì† Í∑∏Î£πÍ≥º Í≥†Í∏â Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
                    for (const group of groups) {
                        const groupSimilarity = await calculateAdvancedSimilarity(detection, group);
                        
                        if (groupSimilarity > bestSimilarity) {
                            bestSimilarity = groupSimilarity;
                            bestMatch = group;
                        }
                    }
                    
                    // 3Îã®Í≥Ñ: Ïª®ÌÖçÏä§Ìä∏ Í∏∞Î∞ò ÎèôÏ†Å ÏûÑÍ≥ÑÍ∞í
                    const dynamicThreshold = calculateContextualThreshold(detection, bestMatch);
                    
                    if (bestMatch && bestSimilarity > dynamicThreshold) {
                        bestMatch.detections.push(detection);
                        await updateGroupWithAdvancedFeatures(bestMatch);
                    } else {
                        // ÏÉàÎ°úÏö¥ Í∑∏Î£π ÏÉùÏÑ±
                        groups.push({
                            id: groups.length + 1,
                            detections: [detection],
                            averageDescriptor: detection.normalizedDescriptor,
                            facialStructure: detection.facialStructure,
                            temporalConsistency: [detection.timestamp]
                        });
                    }
                }
                
                // 4Îã®Í≥Ñ: ÏãúÍ∞ÑÏ†Å ÏùºÍ¥ÄÏÑ± Í∏∞Î∞ò ÌõÑÏ≤òÎ¶¨
                const temporallyConsistentGroups = await applyTemporalConsistency(groups);
                
                // 5Îã®Í≥Ñ: ÏïôÏÉÅÎ∏î Í≤ÄÏ¶ù Î∞è ÏµúÏ¢Ö Î≥ëÌï©
                return await ensembleValidationAndMerge(temporallyConsistentGroups);
                
                } catch (error) {
                    console.error('üö® MAX MODE ÏóêÎü¨ Î∞úÏÉù:', error);
                    console.log('üîÑ Í∏∞Î≥∏ Î™®ÎìúÎ°ú Ìè¥Î∞±...');
                    
                    // Í∏∞Î≥∏ Î™®ÎìúÎ°ú Ìè¥Î∞±
                    return await basicGroupFacesByPerson(allDetections);
                }
            }
            
            // Í∏∞Î≥∏ ÏñºÍµ¥ Í∑∏Î£πÌôî Ìï®Ïàò (Ìè¥Î∞±Ïö©)
            async function basicGroupFacesByPerson(allDetections) {
                console.log('üìã Í∏∞Î≥∏ Í∑∏Î£πÌôî Î™®Îìú Ïã§Ìñâ');
                
                // Í∞Å ÏñºÍµ¥ÏùÑ Í∞úÎ≥Ñ Í∑∏Î£πÏúºÎ°ú Ï≤òÎ¶¨ (ÏïàÏ†ÑÌïú Ìè¥Î∞±)
                return allDetections.map((detection, index) => ({
                    id: index + 1,
                    detections: [detection],
                    averageDescriptor: detection.descriptor,
                    temporalConsistency: [detection.timestamp || 0]
                }));
            }
            
            // üî• MAX MODE: Í≥†Í∏â ÏñºÍµ¥ ÌäπÏßï Ï∂îÏ∂ú
            async function enhanceFaceFeatures(detections) {
                const enhanced = [];
                
                for (const detection of detections) {
                    // ÏñºÍµ¥ Ï†ïÍ∑úÌôî (Ï°∞Î™Ö, Í∞ÅÎèÑ Î≥¥Ï†ï)
                    const normalizedDescriptor = normalizeFaceDescriptor(detection.descriptor);
                    
                    // ÏñºÍµ¥ Íµ¨Ï°∞ Î∂ÑÏÑù (ÎûúÎìúÎßàÌÅ¨ Í∏∞Î∞ò)
                    const facialStructure = analyzeFacialStructure(detection.landmarks);
                    
                    // ÌëúÏ†ï Î∂àÎ≥Ä ÌäπÏßï Ï∂îÏ∂ú
                    const expressionInvariantFeatures = extractExpressionInvariantFeatures(detection);
                    
                    // ÏãúÍ∞ÑÏ†Å Ï†ïÎ≥¥ Ï∂îÍ∞Ä
                    const timestamp = parseFloat(detection.id.split('_')[0]);
                    
                    enhanced.push({
                        ...detection,
                        normalizedDescriptor,
                        facialStructure,
                        expressionInvariantFeatures,
                        timestamp,
                        enhancedFeatures: true
                    });
                }
                
                return enhanced;
            }
            
            // üî• MAX MODE: Îã§Ï§ë Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
            async function calculateAdvancedSimilarity(detection, group) {
                const similarities = [];
                
                for (const groupDetection of group.detections) {
                    // 1. ÏΩîÏÇ¨Ïù∏ Ïú†ÏÇ¨ÎèÑ (Í∏∞Î≥∏ descriptor)
                    const cosineSim = calculateCosineSimilarity(
                        detection.normalizedDescriptor, 
                        groupDetection.normalizedDescriptor
                    );
                    
                    // 2. ÏñºÍµ¥ Íµ¨Ï°∞ Ïú†ÏÇ¨ÎèÑ
                    const structuralSim = calculateStructuralSimilarity(
                        detection.facialStructure,
                        groupDetection.facialStructure
                    );
                    
                    // 3. ÌëúÏ†ï Î∂àÎ≥Ä ÌäπÏßï Ïú†ÏÇ¨ÎèÑ
                    const expressionInvariantSim = calculateCosineSimilarity(
                        detection.expressionInvariantFeatures,
                        groupDetection.expressionInvariantFeatures
                    );
                    
                    // 4. Ïó∞Î†π/ÏÑ±Î≥Ñ Í∞ÄÏ§ë Ïú†ÏÇ¨ÎèÑ
                    const demographicWeight = calculateDemographicWeight(detection, groupDetection);
                    
                    // ÏïôÏÉÅÎ∏î Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
                    const ensembleSimilarity = (
                        cosineSim * 0.4 +
                        structuralSim * 0.3 +
                        expressionInvariantSim * 0.2 +
                        demographicWeight * 0.1
                    );
                    
                    similarities.push(ensembleSimilarity);
                }
                
                // Í∑∏Î£π ÎÇ¥ ÏµúÍ≥† Ïú†ÏÇ¨ÎèÑ Î∞òÌôò
                return Math.max(...similarities);
            }
            
            // üî• MAX MODE: Ïª®ÌÖçÏä§Ìä∏ Í∏∞Î∞ò ÎèôÏ†Å ÏûÑÍ≥ÑÍ∞í
            function calculateContextualThreshold(detection, group) {
                let baseThreshold = 0.75; // Í∏∞Î≥∏ Ïú†ÏÇ¨ÎèÑ ÏûÑÍ≥ÑÍ∞í
                
                if (!group) return baseThreshold;
                
                // Í∑∏Î£π ÌÅ¨Í∏∞Ïóê Îî∞Î•∏ Ï°∞Ï†ï
                const groupSize = group.detections.length;
                if (groupSize >= 3) {
                    baseThreshold -= 0.05; // ÌÅ∞ Í∑∏Î£πÏùÄ Îçî ÏóÑÍ≤©ÌïòÍ≤å
                } else {
                    baseThreshold += 0.1; // ÏûëÏùÄ Í∑∏Î£πÏùÄ Îçî Í¥ÄÎåÄÌïòÍ≤å
                }
                
                // ÏãúÍ∞ÑÏ†Å Í∑ºÏ†ëÏÑ± Í≥†Î†§
                const timeGap = Math.min(...group.temporalConsistency.map(t => 
                    Math.abs(detection.timestamp - t)
                ));
                
                if (timeGap < 30) { // 30Ï¥à Ïù¥ÎÇ¥
                    baseThreshold += 0.1;
                } else if (timeGap > 300) { // 5Î∂Ñ Ïù¥ÏÉÅ
                    baseThreshold -= 0.05;
                }
                
                // ÏñºÍµ¥ Ïù∏Ïãù Ïã†Î¢∞ÎèÑ Í≥†Î†§
                const avgConfidence = group.detections.reduce((sum, d) => sum + d.score, 0) / group.detections.length;
                if (avgConfidence > 0.8) {
                    baseThreshold += 0.05; // Í≥†Ïã†Î¢∞ÎèÑ Í∑∏Î£πÏùÄ Í¥ÄÎåÄÌïòÍ≤å
                }
                
                return Math.max(0.6, Math.min(0.9, baseThreshold)); // 0.6~0.9 Î≤îÏúÑ Ï†úÌïú
            }
            
            // üî• MAX MODE: ÏñºÍµ¥ Ï†ïÍ∑úÌôî Ìï®ÏàòÎì§
            function normalizeFaceDescriptor(descriptor) {
                // L2 Ï†ïÍ∑úÌôî Ï†ÅÏö©
                const norm = Math.sqrt(descriptor.reduce((sum, val) => sum + val * val, 0));
                return descriptor.map(val => val / norm);
            }
            
            function analyzeFacialStructure(landmarks) {
                if (!landmarks || !landmarks.positions) return [];
                
                const positions = landmarks.positions;
                
                // Ï£ºÏöî ÏñºÍµ¥ Íµ¨Ï°∞ ÌäπÏßï Ï∂îÏ∂ú
                const features = [];
                
                // 1. Îàà Í∞ÑÍ≤© ÎπÑÏú®
                const leftEye = positions.slice(36, 42);
                const rightEye = positions.slice(42, 48);
                const eyeDistance = calculateDistance(
                    getCenter(leftEye), 
                    getCenter(rightEye)
                );
                features.push(eyeDistance);
                
                // 2. ÏΩî Í∏∏Ïù¥ ÎπÑÏú®
                const noseTip = positions[33];
                const noseBridge = positions[27];
                const noseLength = calculateDistance(noseTip, noseBridge);
                features.push(noseLength);
                
                // 3. ÏûÖ ÎÑàÎπÑ ÎπÑÏú®
                const leftMouth = positions[48];
                const rightMouth = positions[54];
                const mouthWidth = calculateDistance(leftMouth, rightMouth);
                features.push(mouthWidth);
                
                // 4. ÏñºÍµ¥ Í∏∏Ïù¥/ÎÑàÎπÑ ÎπÑÏú®
                const faceTop = positions[19];
                const faceBottom = positions[8];
                const faceLeft = positions[0];
                const faceRight = positions[16];
                
                const faceHeight = calculateDistance(faceTop, faceBottom);
                const faceWidth = calculateDistance(faceLeft, faceRight);
                const aspectRatio = faceHeight / faceWidth;
                features.push(aspectRatio);
                
                return features;
            }
            
            function extractExpressionInvariantFeatures(detection) {
                // ÌëúÏ†ïÏóê Îçú ÎØºÍ∞êÌïú ÌäπÏßï Ï∂îÏ∂ú
                const descriptor = detection.descriptor;
                const landmarks = detection.landmarks;
                
                // ÏñºÍµ¥ Íµ¨Ï°∞ Í∏∞Î∞ò Î∂àÎ≥Ä ÌäπÏßï
                const structuralFeatures = analyzeFacialStructure(landmarks);
                
                // descriptorÏóêÏÑú ÌëúÏ†ï Î∂àÎ≥Ä Î∂ÄÎ∂Ñ Ï∂îÏ∂ú (Ï≤´ 50% Î∂ÄÎ∂ÑÏù¥ Íµ¨Ï°∞Ï†Å ÌäπÏßï)
                const invariantDescriptor = descriptor.slice(0, Math.floor(descriptor.length * 0.5));
                
                return [...invariantDescriptor, ...structuralFeatures];
            }
            
            function calculateCosineSimilarity(vec1, vec2) {
                if (!vec1 || !vec2 || vec1.length !== vec2.length) return 0;
                
                const dotProduct = vec1.reduce((sum, val, i) => sum + val * vec2[i], 0);
                const norm1 = Math.sqrt(vec1.reduce((sum, val) => sum + val * val, 0));
                const norm2 = Math.sqrt(vec2.reduce((sum, val) => sum + val * val, 0));
                
                return dotProduct / (norm1 * norm2);
            }
            
            function calculateStructuralSimilarity(struct1, struct2) {
                if (!struct1 || !struct2 || struct1.length !== struct2.length) return 0;
                
                // Íµ¨Ï°∞Ï†Å ÌäπÏßïÏùò Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
                const differences = struct1.map((val, i) => Math.abs(val - struct2[i]));
                const avgDifference = differences.reduce((sum, diff) => sum + diff, 0) / differences.length;
                
                // Ï∞®Ïù¥Î•º Ïú†ÏÇ¨ÎèÑÎ°ú Î≥ÄÌôò (0~1)
                return Math.max(0, 1 - avgDifference);
            }
            
            function calculateDemographicWeight(det1, det2) {
                const ageDiff = Math.abs(det1.age - det2.age);
                const genderMatch = det1.gender === det2.gender ? 1 : 0;
                
                // ÎÇòÏù¥ Ïú†ÏÇ¨ÎèÑ (20ÏÑ∏ Ï∞®Ïù¥ÍπåÏßÄ ÏÑ†Ìòï Í∞êÏÜå)
                const ageSimilarity = Math.max(0, 1 - ageDiff / 20);
                
                return (ageSimilarity * 0.7 + genderMatch * 0.3);
            }
            
            async function updateGroupWithAdvancedFeatures(group) {
                // Í∑∏Î£πÏùò ÌèâÍ∑† descriptor ÏóÖÎç∞Ïù¥Ìä∏
                const detections = group.detections;
                const avgDescriptor = [];
                
                for (let i = 0; i < detections[0].normalizedDescriptor.length; i++) {
                    const avg = detections.reduce((sum, d) => sum + d.normalizedDescriptor[i], 0) / detections.length;
                    avgDescriptor.push(avg);
                }
                
                group.averageDescriptor = avgDescriptor;
                
                // ÏãúÍ∞ÑÏ†Å ÏùºÍ¥ÄÏÑ± ÏóÖÎç∞Ïù¥Ìä∏
                group.temporalConsistency = detections.map(d => d.timestamp).sort();
            }
            
            // Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
            function getCenter(points) {
                const x = points.reduce((sum, p) => sum + p.x, 0) / points.length;
                const y = points.reduce((sum, p) => sum + p.y, 0) / points.length;
                return { x, y };
            }
            
            function calculateDistance(point1, point2) {
                const dx = point1.x - point2.x;
                const dy = point1.y - point2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            

            
            // üß† Ïä§ÎßàÌä∏ Î≥ëÌï© ÏãúÏä§ÌÖú (Îã®ÏàúÌïòÍ≥† Ìö®Í≥ºÏ†Å)
            async function smartMergeDetections(allDetections) {
                console.log('üéØ Îã®Ïàú Ïä§ÎßàÌä∏ Î≥ëÌï© ÏãúÏûë:', allDetections.length, 'Í∞ú ÏñºÍµ¥');
                
                // ÏÑ±Î≥ÑÎ≥ÑÎ°ú Î®ºÏ†Ä Î∂ÑÎ•ò
                const maleDetections = allDetections.filter(d => d.gender === 'male');
                const femaleDetections = allDetections.filter(d => d.gender === 'female');
                
                const finalGroups = [];
                let groupId = 1;
                
                // Ïó¨ÏÑ± Î∞∞Ïö∞Îì§ Ï≤òÎ¶¨
                if (femaleDetections.length > 0) {
                    const femaleGroups = await simpleGrouping(femaleDetections, 'Ïó¨ÏÑ±');
                    femaleGroups.forEach(group => {
                        group.id = groupId++;
                        finalGroups.push(group);
                    });
                    console.log(`üë© Ïó¨ÏÑ± Î∞∞Ïö∞ ${femaleDetections.length}Î™Ö ‚Üí ${femaleGroups.length}Í∞ú Í∑∏Î£π`);
                }
                
                // ÎÇ®ÏÑ± Î∞∞Ïö∞Îì§ Ï≤òÎ¶¨
                if (maleDetections.length > 0) {
                    const maleGroups = await simpleGrouping(maleDetections, 'ÎÇ®ÏÑ±');
                    maleGroups.forEach(group => {
                        group.id = groupId++;
                        finalGroups.push(group);
                    });
                    console.log(`üë® ÎÇ®ÏÑ± Î∞∞Ïö∞ ${maleDetections.length}Î™Ö ‚Üí ${maleGroups.length}Í∞ú Í∑∏Î£π`);
                }
                
                console.log(`üéâ Îã®Ïàú Î≥ëÌï© ÏôÑÎ£å: ${allDetections.length}Í∞ú ‚Üí ${finalGroups.length}Í∞ú Í∑∏Î£π`);
                
                // üî• ÏµúÏ¢Ö ÎàÑÎùΩ Î∞©ÏßÄ Ï≤¥ÌÅ¨
                if (finalGroups.length < 3 && allDetections.length >= 6) {
                    console.warn('üö® Î∞∞Ïö∞ Í≥ºÎèÑÌïú Î≥ëÌï© Í∞êÏßÄ! Ï∂îÍ∞Ä Î∂ÑÎ¶¨ ÏãúÎèÑ...');
                    // Í∞ÄÏû• ÌÅ∞ Í∑∏Î£πÏùÑ Î∂ÑÎ¶¨ÌïòÏó¨ Î∞∞Ïö∞ Ïàò Ï¶ùÍ∞Ä
                    const biggestGroup = finalGroups.reduce((max, group) => 
                        group.detections.length > max.detections.length ? group : max
                    );
                    
                    if (biggestGroup.detections.length >= 4) {
                        const splitGroups = await splitLargeGroup(biggestGroup);
                        finalGroups.splice(finalGroups.indexOf(biggestGroup), 1, ...splitGroups);
                        console.log(`üîÑ ÌÅ∞ Í∑∏Î£π Î∂ÑÎ¶¨: ${biggestGroup.detections.length}Í∞ú ‚Üí ${splitGroups.length}Í∞ú Í∑∏Î£π`);
                    }
                }
                
                return finalGroups;
            }
            
            // üî• ÌÅ∞ Í∑∏Î£π Î∂ÑÎ¶¨ Ìï®Ïàò (ÎàÑÎùΩ Î∞∞Ïö∞ Î≥µÍµ¨Ïö©)
            async function splitLargeGroup(largeGroup) {
                const detections = largeGroup.detections;
                console.log(`üî™ ÌÅ∞ Í∑∏Î£π Î∂ÑÎ¶¨ ÏãúÏûë: ${detections.length}Í∞ú ÏñºÍµ¥`);
                
                // ÎÇòÏù¥ Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨
                detections.sort((a, b) => a.age - b.age);
                
                const subGroups = [];
                let currentSubGroup = [detections[0]];
                
                for (let i = 1; i < detections.length; i++) {
                    const ageDiff = Math.abs(detections[i].age - detections[i-1].age);
                    
                    // 10ÏÑ∏ Ïù¥ÏÉÅ Ï∞®Ïù¥ÎÇòÎ©¥ Î∂ÑÎ¶¨
                    if (ageDiff >= 10) {
                        subGroups.push(createGroupFromDetections(currentSubGroup));
                        currentSubGroup = [detections[i]];
                        console.log(`‚úÇÔ∏è ÎÇòÏù¥ Ï∞®Ïù¥Î°ú Î∂ÑÎ¶¨: ${ageDiff}ÏÑ∏ Ï∞®Ïù¥`);
                    } else {
                        currentSubGroup.push(detections[i]);
                    }
                }
                
                // ÎßàÏßÄÎßâ Í∑∏Î£π Ï∂îÍ∞Ä
                if (currentSubGroup.length > 0) {
                    subGroups.push(createGroupFromDetections(currentSubGroup));
                }
                
                // ID Ïû¨Ìï†Îãπ
                subGroups.forEach((group, index) => {
                    group.id = largeGroup.id + index;
                });
                
                console.log(`üéØ Î∂ÑÎ¶¨ ÏôÑÎ£å: ${detections.length}Í∞ú ‚Üí ${subGroups.length}Í∞ú ÏÑúÎ∏åÍ∑∏Î£π`);
                return subGroups;
            }
            
            // üéØ Îã®ÏàúÌïòÍ≥† Ìö®Í≥ºÏ†ÅÏù∏ Í∑∏Î£πÌôî
            async function simpleGrouping(detections, genderLabel) {
                if (detections.length <= 1) {
                    return [createGroupFromDetections(detections)];
                }
                
                console.log(`üîÑ ${genderLabel} ${detections.length}Î™Ö Îã®Ïàú Î≥ëÌï© ÏãúÏûë`);
                console.log(`üìã ${genderLabel} ÏÉÅÏÑ∏ Ï†ïÎ≥¥:`, detections.map(d => `${d.age}ÏÑ∏(Ïã†Î¢∞ÎèÑ:${d.score.toFixed(2)})`).join(', '));
                
                const groups = [];
                const processed = new Set();
                
                // ÎÇòÏù¥ ÏàúÏúºÎ°ú Ï†ïÎ†¨
                detections.sort((a, b) => a.age - b.age);
                
                for (let i = 0; i < detections.length; i++) {
                    if (processed.has(i)) continue;
                    
                    const currentGroup = [detections[i]];
                    processed.add(i);
                    
                    // Îã§Î•∏ ÏñºÍµ¥Îì§Í≥º ÎπÑÍµê
                    for (let j = i + 1; j < detections.length; j++) {
                        if (processed.has(j)) continue;
                        
                        const ageDiff = Math.abs(detections[i].age - detections[j].age);
                        
                        // üéØ Ïó∞Î†πÎåÄÎ≥Ñ ÎßûÏ∂§ Î∂ÑÎ¶¨ Í∏∞Ï§Ä
                        const shouldSeparate = shouldSeparateByAge(detections[i], detections[j], ageDiff);
                        if (shouldSeparate) {
                            console.log(`üö´ ÎÇòÏù¥Ï∞®Ïù¥Î°ú Î∂ÑÎ¶¨: ${detections[i].age}ÏÑ∏ vs ${detections[j].age}ÏÑ∏ (Ï∞®Ïù¥: ${ageDiff}ÏÑ∏)`);
                            continue;
                        }
                        
                        // Face-api.js Ïú†ÏÇ¨ÎèÑ Ï≤¥ÌÅ¨ (Ïó∞Î†πÎåÄÎ≥Ñ Í¥ÄÎåÄÌïú Í∏∞Ï§Ä)
                        const similarity = await calculateSimpleSimilarity(detections[i], detections[j]);
                        const threshold = getAgeBasedThreshold(detections[i], detections[j]);
                        
                        // üéØ Ïó∞Î†πÎåÄÎ≥Ñ ÏûÑÍ≥ÑÍ∞íÏúºÎ°ú Î≥ëÌï© (Îçî Í¥ÄÎåÄÌïú Í∏∞Ï§Ä)
                        const adjustedThreshold = threshold - 0.05; // Í∏∞Î≥∏ ÏûÑÍ≥ÑÍ∞íÏóêÏÑú 0.05 ÏôÑÌôî
                        if (similarity >= adjustedThreshold) {
                            currentGroup.push(detections[j]);
                            processed.add(j);
                            console.log(`‚úÖ Î≥ëÌï©: ${detections[i].age}ÏÑ∏ + ${detections[j].age}ÏÑ∏ (Ïú†ÏÇ¨ÎèÑ: ${similarity.toFixed(3)} >= ${adjustedThreshold.toFixed(2)})`);
                        } else {
                            console.log(`‚ùå Ïú†ÏÇ¨ÎèÑ Î∂ÄÏ°±: ${detections[i].age}ÏÑ∏ vs ${detections[j].age}ÏÑ∏ (Ïú†ÏÇ¨ÎèÑ: ${similarity.toFixed(3)} < ${adjustedThreshold.toFixed(2)})`);
                        }
                    }
                    
                    groups.push(createGroupFromDetections(currentGroup));
                }
                
                console.log(`‚ú® ${genderLabel} Î≥ëÌï© Í≤∞Í≥º: ${detections.length}Î™Ö ‚Üí ${groups.length}Í∞ú Í∑∏Î£π`);
                return groups;
            }
            
            // üéØ Ïó∞Î†πÎåÄÎ≥Ñ Î∂ÑÎ¶¨ ÌåêÎã® Ìï®Ïàò (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
            function shouldSeparateByAge(detection1, detection2, ageDiff) {
                const age1 = detection1.age;
                const age2 = detection2.age;
                const minAge = Math.min(age1, age2);
                const maxAge = Math.max(age1, age2);
                
                console.log(`üîç ÎÇòÏù¥ Í∏∞Î∞ò Î∂ÑÎ¶¨ Í≤ÄÌÜ†: ${age1}ÏÑ∏ vs ${age2}ÏÑ∏ (Ï∞®Ïù¥: ${ageDiff}ÏÑ∏)`);
                
                // üö® MAX MODE: Ï≤≠ÏÜåÎÖÑ-ÏÑ±Ïù∏ Í≤ΩÍ≥Ñ ÏßÄÎåÄ ÌäπÎ≥Ñ Ï≤òÎ¶¨
                if ((minAge >= 12 && minAge <= 18) && (maxAge >= 18 && maxAge <= 28)) {
                    console.log(`üßí‚û°Ô∏èüë® Ï≤≠ÏÜåÎÖÑ-ÏÑ±Ïù∏ Í≤ΩÍ≥Ñ ÏßÄÎåÄ Í∞êÏßÄ! ÏãúÍ∞ÅÏ†Å Ïú†ÏÇ¨ÏÑ± Ïö∞ÏÑ† Î™®Îìú`);
                    return false; // ÎÇòÏù¥ Í∏∞Î∞ò Î∂ÑÎ¶¨ ÎπÑÌôúÏÑ±Ìôî, ÏñºÍµ¥ Ïú†ÏÇ¨ÎèÑÎßåÏúºÎ°ú ÌåêÎã®
                }
                
                // Îß§Ïö∞ Ïñ¥Î¶∞ ÏïÑÎèô(0-10ÏÑ∏)Í≥º ÏÑ±Ïù∏Îßå ÌôïÏã§Ìûà Î∂ÑÎ¶¨
                if (minAge <= 10 && maxAge > 25 && ageDiff >= 15) {
                    console.log(`üë∂‚ùåüë® ÌôïÏã§Ìïú ÏïÑÎèô-ÏÑ±Ïù∏ Î∂ÑÎ¶¨: ${minAge}ÏÑ∏ vs ${maxAge}ÏÑ∏`);
                    return true;
                }
                
                // Ï§ëÎÖÑÍ≥º ÎÖ∏Ïù∏ ÏÇ¨Ïù¥Îäî Í¥ÄÎåÄÌïòÍ≤å
                if (minAge >= 35 && ageDiff >= 30 && maxAge >= 65) {
                    console.log(`üë®‚ùåüë¥ Ï§ëÎÖÑ-ÎÖ∏Ïù∏ Î∂ÑÎ¶¨: ${minAge}ÏÑ∏ vs ${maxAge}ÏÑ∏`);
                    return true;
                }
                
                // ÎÇòÎ®∏ÏßÄÎäî 30ÏÑ∏ Ï∞®Ïù¥ÍπåÏßÄ ÌóàÏö© (ÎçîÏö± Í¥ÄÎåÄÌïòÍ≤å)
                if (ageDiff >= 30) {
                    console.log(`‚ö†Ô∏è ÌÅ∞ ÎÇòÏù¥ Ï∞®Ïù¥Î°ú Î∂ÑÎ¶¨: ${ageDiff}ÏÑ∏ Ï∞®Ïù¥`);
                    return true;
                }
                
                console.log(`‚úÖ ÎÇòÏù¥ Í∏∞Î∞ò Î∂ÑÎ¶¨ ÏïàÌï®: ÏñºÍµ¥ Ïú†ÏÇ¨ÎèÑÎ°ú ÌåêÎã®`);
                return false;
            }
            
            // üéØ Ïó∞Î†πÎåÄÎ≥Ñ Ïú†ÏÇ¨ÎèÑ ÏûÑÍ≥ÑÍ∞í ÏÑ§Ï†ï (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
            function getAgeBasedThreshold(detection1, detection2) {
                const age1 = detection1.age;
                const age2 = detection2.age;
                const avgAge = (age1 + age2) / 2;
                const ageDiff = Math.abs(age1 - age2);
                const minAge = Math.min(age1, age2);
                const maxAge = Math.max(age1, age2);
                
                // üö® MAX MODE: Ï≤≠ÏÜåÎÖÑ-ÏÑ±Ïù∏ Í≤ΩÍ≥Ñ ÏßÄÎåÄ ÌäπÎ≥Ñ ÏûÑÍ≥ÑÍ∞í
                if ((minAge >= 12 && minAge <= 18) && (maxAge >= 18 && maxAge <= 28)) {
                    const specialThreshold = 0.48 + (ageDiff * 0.01); // ÎÇòÏù¥ Ï∞®Ïù¥ Î≥¥Ï†ï
                    console.log(`üî• Ï≤≠ÏÜåÎÖÑ-ÏÑ±Ïù∏ ÌäπÎ≥Ñ ÏûÑÍ≥ÑÍ∞í: ${specialThreshold.toFixed(3)} (ÎÇòÏù¥Ï∞®${ageDiff}ÏÑ∏)`);
                    return Math.min(0.55, specialThreshold); // ÏµúÎåÄ 0.55ÍπåÏßÄ
                }
                
                // ÎÖ∏Ïù∏ÏùÄ Îß§Ïö∞ Í¥ÄÎåÄÌïòÍ≤å (Î≥ëÌï© Í∞ïÌôî)
                if (avgAge >= 60) {
                    console.log(`üë¥ ÎÖ∏Ïù∏ Í∑∏Î£π: Ï¥àÍ¥ÄÎåÄÌïú Í∏∞Ï§Ä (ÏûÑÍ≥ÑÍ∞í: 0.35)`);
                    return 0.35; // ÎçîÏö± Í¥ÄÎåÄÌïòÍ≤å Ï°∞Ï†ï
                }
                
                // Ï§ëÎÖÑ-ÎÖ∏Ïù∏ Í≤ΩÍ≥Ñ (55-65ÏÑ∏) ÌäπÎ≥Ñ Ï≤òÎ¶¨
                if (avgAge >= 55) {
                    console.log(`üë®‚Äçü¶≥ Ï§ëÎÖÑ-ÎÖ∏Ïù∏ Í≤ΩÍ≥Ñ: Í¥ÄÎåÄÌïú Í∏∞Ï§Ä (ÏûÑÍ≥ÑÍ∞í: 0.38)`);
                    return 0.38;
                }
                
                // Ï§ëÎÖÑÏùÄ Í¥ÄÎåÄÌïòÍ≤å
                if (avgAge >= 40) {
                    console.log(`üßë Ï§ëÎÖÑ Í∑∏Î£π: Í¥ÄÎåÄÌïú Í∏∞Ï§Ä (ÏûÑÍ≥ÑÍ∞í: 0.47)`);
                    return 0.47;
                }
                
                // ÏÑ±Ïù∏ÏùÄ Î≥¥ÌÜµ Í∏∞Ï§Ä
                if (avgAge >= 25) {
                    console.log(`üë® ÏÑ±Ïù∏ Í∑∏Î£π: Î≥¥ÌÜµ Í∏∞Ï§Ä (ÏûÑÍ≥ÑÍ∞í: 0.52)`);
                    return 0.52;
                }
                
                // Ï≤≠ÎÖÑÏùÄ Ï°∞Í∏à Îçî ÏóÑÍ≤©ÌïòÍ≤å (Í∏∞Ï°¥Î≥¥Îã§ ÏôÑÌôî)
                if (avgAge >= 18) {
                    console.log(`üë¶ Ï≤≠ÎÖÑ Í∑∏Î£π: Ï†ÅÎãπÌïú Í∏∞Ï§Ä (ÏûÑÍ≥ÑÍ∞í: 0.58)`);
                    return 0.58;
                }
                
                // Ï≤≠ÏÜåÎÖÑÏùÄ ÏóÑÍ≤©ÌïòÍ≤å (Í∏∞Ï°¥Î≥¥Îã§ ÏôÑÌôî)
                console.log(`üßí Ï≤≠ÏÜåÎÖÑ Í∑∏Î£π: ÏóÑÍ≤©Ìïú Í∏∞Ï§Ä (ÏûÑÍ≥ÑÍ∞í: 0.62)`);
                return 0.62;
            }
            
            async function calculateSimpleSimilarity(detection1, detection2) {
                try {
                    // üî¨ Í≥†Í∏â ÏñºÍµ¥ ÌäπÏßï Î∂ÑÏÑùÏúºÎ°ú Ï†ïÎ∞ÄÌïú Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
                    if (detection1.descriptor && detection2.descriptor && detection1.landmarks && detection2.landmarks) {
                        const advancedSimilarity = await calculateAdvancedFacialSimilarity(detection1, detection2);
                        console.log(`üî¨ Í≥†Í∏â Î∂ÑÏÑù ÏÑ±Í≥µ: ${advancedSimilarity.toFixed(3)}`);
                        return advancedSimilarity;
                    }
                    
                    // Face-api.js descriptorÎßå ÏûàÎäî Í≤ΩÏö∞
                    if (detection1.descriptor && detection2.descriptor) {
                        const basicSimilarity = calculateCosineSimilarity(detection1.descriptor, detection2.descriptor);
                        console.log(`ü§ñ Í∏∞Î≥∏ Face-api.js Î∂ÑÏÑù: ${basicSimilarity.toFixed(3)}`);
                        return basicSimilarity;
                    }
                    
                    // Face-api.jsÍ∞Ä ÏóÜÏúºÎ©¥ ÎÇòÏù¥ Í∏∞Î∞òÏúºÎ°úÎßå ÌåêÎã®
                    const ageDiff = Math.abs(detection1.age - detection2.age);
                    console.log(`üìä ÎÇòÏù¥ Í∏∞Î∞ò Î∂ÑÏÑù: ${detection1.age}ÏÑ∏ vs ${detection2.age}ÏÑ∏`);
                    
                    if (ageDiff <= 5) {
                        return 0.7; // Î≥ëÌï© Í∞ÄÎä•Ìïú Ï†êÏàò
                    } else {
                        return 0.3; // Î≥ëÌï© Î∂àÍ∞ÄÎä•Ìïú Ï†êÏàò
                    }
                } catch (error) {
                    console.error('Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞ Ïò§Î•ò:', error);
                    // ÏóêÎü¨ Î∞úÏÉùÏãú Í∏∞Î≥∏ Face-api.js Ïú†ÏÇ¨ÎèÑÎ°ú fallback
                    if (detection1.descriptor && detection2.descriptor) {
                        return calculateCosineSimilarity(detection1.descriptor, detection2.descriptor);
                    }
                    return 0.5; // Ï§ëÎ¶ΩÏ†ÅÏù∏ Í∞í
                }
            }
            
            // üî¨ Í≥†Í∏â ÏñºÍµ¥ ÌäπÏßï Î∂ÑÏÑù ÏãúÏä§ÌÖú
            async function calculateAdvancedFacialSimilarity(detection1, detection2) {
                console.log('üî¨ Ï†ïÎ∞Ä ÏñºÍµ¥ ÌäπÏßï Î∂ÑÏÑù ÏãúÏûë...');
                
                // 1. Í∏∞Î≥∏ Face-api.js Ïú†ÏÇ¨ÎèÑ (Í∞ÄÏ§ëÏπò 40%)
                const basicSimilarity = calculateCosineSimilarity(detection1.descriptor, detection2.descriptor);
                
                // 2. Îàà Î™®Ïñë Ïú†ÏÇ¨ÎèÑ (Í∞ÄÏ§ëÏπò 20%)
                const eyeSimilarity = calculateEyeSimilarity(detection1.landmarks, detection2.landmarks);
                
                // 3. ÎààÏçπ Î™®Ïñë Ïú†ÏÇ¨ÎèÑ (Í∞ÄÏ§ëÏπò 15%)
                const eyebrowSimilarity = calculateEyebrowSimilarity(detection1.landmarks, detection2.landmarks);
                
                // 4. ÏΩî Î™®Ïñë Ïú†ÏÇ¨ÎèÑ (Í∞ÄÏ§ëÏπò 15%)
                const noseSimilarity = calculateNoseSimilarity(detection1.landmarks, detection2.landmarks);
                
                // 5. ÏûÖ Î™®Ïñë Ïú†ÏÇ¨ÎèÑ (Í∞ÄÏ§ëÏπò 10%)
                const mouthSimilarity = calculateMouthSimilarity(detection1.landmarks, detection2.landmarks);
                
                // 6. ÏñºÍµ¥ Ïô∏Í¥Ä ÌäπÏßï (ÏàòÏóº, Î®∏Î¶¨ Îì±) Ï∂îÍ∞Ä Î∂ÑÏÑù
                const facialFeatures1 = await analyzeFacialFeatures(detection1);
                const facialFeatures2 = await analyzeFacialFeatures(detection2);
                const featureSimilarity = compareFacialFeatures(facialFeatures1, facialFeatures2);
                
                // Ïó∞Î†πÎåÄÎ≥Ñ Í∞ÄÏ§ëÏπò Ï°∞Ï†ï (Ï≤≠ÏÜåÎÖÑ-ÏÑ±Ïù∏ Í≤ΩÍ≥Ñ ÌäπÎ≥Ñ Ï≤òÎ¶¨)
                const age1 = detection1.age;
                const age2 = detection2.age;
                const avgAge = (age1 + age2) / 2;
                const minAge = Math.min(age1, age2);
                const maxAge = Math.max(age1, age2);
                let adjustedSimilarity;
                
                // üö® MAX MODE: Ï≤≠ÏÜåÎÖÑ-ÏÑ±Ïù∏ Í≤ΩÍ≥Ñ ÏßÄÎåÄ ÌäπÎ≥Ñ Í∞ÄÏ§ëÏπò
                if ((minAge >= 12 && minAge <= 18) && (maxAge >= 18 && maxAge <= 28)) {
                    console.log(`üî• Ï≤≠ÏÜåÎÖÑ-ÏÑ±Ïù∏ ÌäπÎ≥Ñ Î∂ÑÏÑù Î™®Îìú (${age1}ÏÑ∏ vs ${age2}ÏÑ∏)`);
                    // ÏÑ±Ïû•Í∏∞ ÏñºÍµ¥ Î≥ÄÌôîÎ•º Í≥†Î†§Ìïú ÌäπÎ≥Ñ Í∞ÄÏ§ëÏπò
                    adjustedSimilarity = (
                        basicSimilarity * 0.65 +      // Face-api.js Í∏∞Î≥∏ Ïú†ÏÇ¨ÎèÑ ÎÜíÏùÄ ÎπÑÏ§ë
                        eyeSimilarity * 0.12 +        // ÎààÏùÄ Î≥ÄÌôîÍ∞Ä Ï†ÅÏùå
                        eyebrowSimilarity * 0.08 +    // ÎààÏçπÏùÄ ÏÑ±Ïû•Í∏∞Ïóê Î≥ÄÌôî
                        noseSimilarity * 0.08 +       // ÏΩîÎèÑ ÏÑ±Ïû•Í∏∞Ïóê Î≥ÄÌôî
                        mouthSimilarity * 0.05 +      // ÏûÖÏùÄ Î≥ÄÌôîÍ∞Ä ÌÅº
                        featureSimilarity * 0.02      // ÏàòÏóº Îì±ÏùÄ ÏÑ±Ïû•Í∏∞Ïóê ÎßéÏù¥ Î≥ÄÌôî
                    );
                    console.log(`üßí‚û°Ô∏èüë® Ï≤≠ÏÜåÎÖÑ-ÏÑ±Ïù∏ ÌäπÎ≥Ñ Ï†êÏàò: ${adjustedSimilarity.toFixed(3)}`);
                } else if (avgAge >= 60) {
                    // ÎÖ∏Ïù∏: Face-api.jsÏóê Îçî ÎßéÏù¥ ÏùòÏ°¥ (ÏÑ∏Î∂Ä ÌäπÏßïÏùÄ Îçú Ï§ëÏöî)
                    adjustedSimilarity = (
                        basicSimilarity * 0.60 +  // Face-api.js ÎπÑÏ§ë Ï¶ùÍ∞Ä
                        eyeSimilarity * 0.15 +
                        eyebrowSimilarity * 0.10 +
                        noseSimilarity * 0.10 +
                        mouthSimilarity * 0.05 +
                        featureSimilarity * 0.10   // ÏàòÏóº Îì±ÏùÄ Ïó¨Ï†ÑÌûà Ï§ëÏöî
                    );
                } else if (avgAge >= 40) {
                    // Ï§ëÎÖÑ: Í∑†ÌòïÏûàÍ≤å
                    adjustedSimilarity = (
                        basicSimilarity * 0.50 +
                        eyeSimilarity * 0.18 +
                        eyebrowSimilarity * 0.12 +
                        noseSimilarity * 0.12 +
                        mouthSimilarity * 0.08 +
                        featureSimilarity * 0.10
                    );
                } else {
                    // Ï†äÏùÄÏ∏µ: ÏÑ∏Î∂Ä ÌäπÏßïÏóê Îçî ÏùòÏ°¥
                    adjustedSimilarity = (
                        basicSimilarity * 0.40 +
                        eyeSimilarity * 0.20 +
                        eyebrowSimilarity * 0.15 +
                        noseSimilarity * 0.15 +
                        mouthSimilarity * 0.10 +
                        featureSimilarity * 0.10
                    );
                }
                
                console.log(`üëÅÔ∏è Îàà: ${eyeSimilarity.toFixed(3)}, üëÑ ÏûÖ: ${mouthSimilarity.toFixed(3)}, üëÉ ÏΩî: ${noseSimilarity.toFixed(3)}, üéØ Ïó∞Î†πÏ°∞Ï†ï: ${adjustedSimilarity.toFixed(3)}`);
                
                return adjustedSimilarity;
            }
            
            // üëÅÔ∏è Îàà Î™®Ïñë Î∂ÑÏÑù
            function calculateEyeSimilarity(landmarks1, landmarks2) {
                const eye1_right = getLandmarkPoints(landmarks1, 36, 42); // Ïò§Î•∏Ï™Ω Îàà (36-41)
                const eye1_left = getLandmarkPoints(landmarks1, 42, 48); // ÏôºÏ™Ω Îàà (42-47)
                const eye2_right = getLandmarkPoints(landmarks2, 36, 42);
                const eye2_left = getLandmarkPoints(landmarks2, 42, 48);
                
                // ÎààÏùò ÎÑàÎπÑ, ÎÜíÏù¥, Í∞ÅÎèÑ ÎπÑÍµê
                const leftEyeSim = compareEyeShape(eye1_left, eye2_left);
                const rightEyeSim = compareEyeShape(eye1_right, eye2_right);
                
                return (leftEyeSim + rightEyeSim) / 2;
            }
            
            function compareEyeShape(eye1, eye2) {
                if (!eye1 || !eye2 || eye1.length < 6 || eye2.length < 6) {
                    return 0.5; // Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±Ïãú Ï§ëÎ¶ΩÍ∞í
                }
                
                // ÎààÏùò ÎÑàÎπÑÏôÄ ÎÜíÏù¥ ÎπÑÏú® Í≥ÑÏÇ∞
                const width1 = calculateDistance(eye1[0], eye1[3]);
                const height1 = calculateDistance(eye1[1], eye1[5]);
                const ratio1 = width1 > 0 ? height1 / width1 : 0;
                
                const width2 = calculateDistance(eye2[0], eye2[3]);
                const height2 = calculateDistance(eye2[1], eye2[5]);
                const ratio2 = width2 > 0 ? height2 / width2 : 0;
                
                // ÎπÑÏú® Ï∞®Ïù¥Í∞Ä Ï†ÅÏùÑÏàòÎ°ù Ïú†ÏÇ¨ÎèÑ ÎÜíÏùå
                const ratioDiff = Math.abs(ratio1 - ratio2);
                return Math.max(0, 1 - ratioDiff * 2); // 0~1 ÏÇ¨Ïù¥Î°ú Ï†ïÍ∑úÌôî
            }
            
            // ü§® ÎààÏçπ Î™®Ïñë Î∂ÑÏÑù
            function calculateEyebrowSimilarity(landmarks1, landmarks2) {
                const brow1_right = getLandmarkPoints(landmarks1, 17, 22); // Ïò§Î•∏Ï™Ω ÎààÏçπ (17-21)
                const brow1_left = getLandmarkPoints(landmarks1, 22, 27); // ÏôºÏ™Ω ÎààÏçπ (22-26)
                const brow2_right = getLandmarkPoints(landmarks2, 17, 22);
                const brow2_left = getLandmarkPoints(landmarks2, 22, 27);
                
                const leftBrowSim = compareBrowShape(brow1_left, brow2_left);
                const rightBrowSim = compareBrowShape(brow1_right, brow2_right);
                
                return (leftBrowSim + rightBrowSim) / 2;
            }
            
            function compareBrowShape(brow1, brow2) {
                if (!brow1 || !brow2 || brow1.length < 2 || brow2.length < 2) {
                    return 0.5; // Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±Ïãú Ï§ëÎ¶ΩÍ∞í
                }
                
                // ÎààÏçπÏùò Í∞ÅÎèÑÏôÄ Íµ¥Í≥° ÎπÑÍµê
                const angle1 = calculateBrowAngle(brow1);
                const angle2 = calculateBrowAngle(brow2);
                const angleDiff = Math.abs(angle1 - angle2);
                
                return Math.max(0, 1 - angleDiff / 45); // 45ÎèÑ Ï∞®Ïù¥Î•º ÏµúÎåÄÎ°ú ÏÑ§Ï†ï
            }
            
            function calculateBrowAngle(browPoints) {
                if (!browPoints || browPoints.length < 2) return 0;
                
                // ÎààÏçπ ÏãúÏûëÏ†êÍ≥º ÎÅùÏ†êÏùò Í∞ÅÎèÑ Í≥ÑÏÇ∞
                const start = browPoints[0];
                const end = browPoints[browPoints.length - 1];
                
                if (!start || !end || !start.x || !start.y || !end.x || !end.y) return 0;
                
                const angle = Math.atan2(end.y - start.y, end.x - start.x) * 180 / Math.PI;
                return Math.abs(angle);
            }
            
            // üëÉ ÏΩî Î™®Ïñë Î∂ÑÏÑù
            function calculateNoseSimilarity(landmarks1, landmarks2) {
                const nose1 = getLandmarkPoints(landmarks1, 27, 36); // ÏΩî ÏòÅÏó≠ (27-35)
                const nose2 = getLandmarkPoints(landmarks2, 27, 36);
                
                return compareNoseShape(nose1, nose2);
            }
            
            function compareNoseShape(nose1, nose2) {
                if (!nose1 || !nose2 || nose1.length < 9 || nose2.length < 9) {
                    return 0.5; // Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±Ïãú Ï§ëÎ¶ΩÍ∞í
                }
                
                // ÏΩîÏùò ÎÑàÎπÑÏôÄ Í∏∏Ïù¥ ÎπÑÏú® Í≥ÑÏÇ∞ (Face-api.js 27-35 ÏΩî ÎûúÎìúÎßàÌÅ¨ Í∏∞Ï§Ä)
                const noseWidth1 = calculateDistance(nose1[4], nose1[8]); // ÏΩßÍµ¨Î©ç ÎÑàÎπÑ (31, 35)
                const noseLength1 = calculateDistance(nose1[0], nose1[6]); // ÏΩî Í∏∏Ïù¥ (27, 33)
                const ratio1 = noseLength1 > 0 ? noseWidth1 / noseLength1 : 0;
                
                const noseWidth2 = calculateDistance(nose2[4], nose2[8]);
                const noseLength2 = calculateDistance(nose2[0], nose2[6]);
                const ratio2 = noseLength2 > 0 ? noseWidth2 / noseLength2 : 0;
                
                const ratioDiff = Math.abs(ratio1 - ratio2);
                return Math.max(0, 1 - ratioDiff * 3); // ÎπÑÏú® Ï∞®Ïù¥Î•º Ïú†ÏÇ¨ÎèÑÎ°ú Î≥ÄÌôò
            }
            
            // üëÑ ÏûÖ Î™®Ïñë Î∂ÑÏÑù
            function calculateMouthSimilarity(landmarks1, landmarks2) {
                const mouth1 = getLandmarkPoints(landmarks1, 48, 68); // ÏûÖ ÏòÅÏó≠
                const mouth2 = getLandmarkPoints(landmarks2, 48, 68);
                
                return compareMouthShape(mouth1, mouth2);
            }
            
            function compareMouthShape(mouth1, mouth2) {
                if (!mouth1 || !mouth2 || mouth1.length < 12 || mouth2.length < 12) {
                    return 0.5; // Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±Ïãú Ï§ëÎ¶ΩÍ∞í
                }
                
                // ÏûÖÏùò ÎÑàÎπÑÏôÄ ÎÜíÏù¥ ÎπÑÏú® Í≥ÑÏÇ∞ (Face-api.js 48-67 ÏûÖ ÎûúÎìúÎßàÌÅ¨ Í∏∞Ï§Ä)
                const mouthWidth1 = calculateDistance(mouth1[0], mouth1[6]); // ÏûÖ ÎÑàÎπÑ (48, 54)
                const mouthHeight1 = calculateDistance(mouth1[3], mouth1[9]); // ÏûÖ ÎÜíÏù¥ (51, 57)
                const ratio1 = mouthWidth1 > 0 ? mouthHeight1 / mouthWidth1 : 0;
                
                const mouthWidth2 = calculateDistance(mouth2[0], mouth2[6]);
                const mouthHeight2 = calculateDistance(mouth2[3], mouth2[9]);
                const ratio2 = mouthWidth2 > 0 ? mouthHeight2 / mouthWidth2 : 0;
                
                const ratioDiff = Math.abs(ratio1 - ratio2);
                return Math.max(0, 1 - ratioDiff * 4);
            }
            
            // üßî Ï∂îÍ∞Ä ÏñºÍµ¥ ÌäπÏßï Î∂ÑÏÑù (ÏàòÏóº, Î®∏Î¶¨ÏÉâ Îì±)
            async function analyzeFacialFeatures(detection) {
                if (!detection.faceImage) return {};
                
                try {
                    // ÏñºÍµ¥ Ïù¥ÎØ∏ÏßÄÏóêÏÑú ÏÉâÏÉÅ Î∞è ÏßàÍ∞ê Î∂ÑÏÑù
                    const features = await analyzeImageFeatures(detection.faceImage);
                    
                    return {
                        hasBeard: detectBeard(features, detection),
                        hairColor: analyzeHairColor(features),
                        skinTone: analyzeSkinTone(features),
                        eyeColor: analyzeEyeColor(features),
                        hairTexture: analyzeHairTexture(features)
                    };
                } catch (error) {
                    console.log('ÏñºÍµ¥ ÌäπÏßï Î∂ÑÏÑù Ïã§Ìå®:', error);
                    return {};
                }
            }
            
            async function analyzeImageFeatures(faceImageDataUrl) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        
                        // Ïù¥ÎØ∏ÏßÄÏóêÏÑú ÏÉâÏÉÅ Ï†ïÎ≥¥ Ï∂îÏ∂ú
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const features = extractColorFeatures(imageData, canvas.width, canvas.height);
                        
                        resolve(features);
                    };
                    img.src = faceImageDataUrl;
                });
            }
            
            function extractColorFeatures(imageData, width, height) {
                const data = imageData.data;
                const colorRegions = {
                    topHair: [],      // ÏÉÅÎã® (Î®∏Î¶¨Ïπ¥ÎùΩ)
                    eyeArea: [],      // Îàà Ï£ºÎ≥Ä
                    skinArea: [],     // ÏñºÍµ¥ ÌîºÎ∂Ä
                    lowerFace: []     // ÌïòÎã® (ÏàòÏóº ÏòÅÏó≠)
                };
                
                // ÏòÅÏó≠Î≥ÑÎ°ú ÏÉâÏÉÅ ÏÉòÌîåÎßÅ
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        
                        // ÏòÅÏó≠ Î∂ÑÎ•ò
                        if (y < height * 0.3) {
                            colorRegions.topHair.push([r, g, b]);
                        } else if (y < height * 0.6) {
                            colorRegions.eyeArea.push([r, g, b]);
                        } else if (y < height * 0.8) {
                            colorRegions.skinArea.push([r, g, b]);
                        } else {
                            colorRegions.lowerFace.push([r, g, b]);
                        }
                    }
                }
                
                return colorRegions;
            }
            
            function detectBeard(features, detection) {
                const lowerFaceColors = features.lowerFace || [];
                const skinColors = features.skinArea || [];
                
                if (lowerFaceColors.length === 0 || skinColors.length === 0) return false;
                
                // ÌïòÎã® ÏñºÍµ¥Í≥º ÌîºÎ∂ÄÏÉâÏùò Ï∞®Ïù¥Î°ú ÏàòÏóº Ï∂îÏ†ï
                const avgLowerColor = getAverageColor(lowerFaceColors);
                const avgSkinColor = getAverageColor(skinColors);
                
                const colorDiff = calculateColorDistance(avgLowerColor, avgSkinColor);
                
                // ÎÇ®ÏÑ±Ïù¥Í≥† ÏÉâÏÉÅ Ï∞®Ïù¥Í∞Ä ÌÅ¥ Îïå ÏàòÏóºÏúºÎ°ú ÌåêÎã®
                return detection.gender === 'male' && colorDiff > 30;
            }
            
            function analyzeHairColor(features) {
                const hairColors = features.topHair || [];
                if (hairColors.length === 0) return 'unknown';
                
                const avgColor = getAverageColor(hairColors);
                
                // Î®∏Î¶¨ÏÉâ Î∂ÑÎ•ò
                if (avgColor[0] < 50 && avgColor[1] < 50 && avgColor[2] < 50) return 'black';
                if (avgColor[0] > 150 && avgColor[1] > 120 && avgColor[2] < 100) return 'blonde';
                if (avgColor[0] > 100 && avgColor[1] < 80 && avgColor[2] < 80) return 'brown';
                if (avgColor[0] > 200 && avgColor[1] > 200 && avgColor[2] > 200) return 'gray';
                return 'brown'; // Í∏∞Î≥∏Í∞í
            }
            
            function analyzeSkinTone(features) {
                const skinColors = features.skinArea || [];
                if (skinColors.length === 0) return 'unknown';
                
                const avgColor = getAverageColor(skinColors);
                const brightness = (avgColor[0] + avgColor[1] + avgColor[2]) / 3;
                
                if (brightness > 200) return 'light';
                if (brightness > 150) return 'medium';
                return 'dark';
            }
            
            function analyzeEyeColor(features) {
                const eyeColors = features.eyeArea || [];
                if (eyeColors.length === 0) return 'unknown';
                
                // Îàà ÏÉâÏÉÅÏùÄ Î≥µÏû°Ìïú Î∂ÑÏÑùÏù¥ ÌïÑÏöîÌïòÎØÄÎ°ú Í∞ÑÎã®Ìûà Íµ¨ÌòÑ
                return 'brown'; // Í∏∞Î≥∏Í∞í
            }
            
            function analyzeHairTexture(features) {
                // Î®∏Î¶¨ ÏßàÍ∞ê Î∂ÑÏÑùÏùÄ Îß§Ïö∞ Î≥µÏû°ÌïòÎØÄÎ°ú Í∞ÑÎã®Ìûà Íµ¨ÌòÑ
                return 'normal';
            }
            
            function compareFacialFeatures(features1, features2) {
                if (!features1 || !features2) return 0.5; // Ï§ëÎ¶Ω
                
                let score = 0;
                let count = 0;
                
                // ÏàòÏóº ÎπÑÍµê
                if (features1.hasBeard !== undefined && features2.hasBeard !== undefined) {
                    score += features1.hasBeard === features2.hasBeard ? 1 : 0;
                    count++;
                }
                
                // Î®∏Î¶¨ÏÉâ ÎπÑÍµê
                if (features1.hairColor && features2.hairColor) {
                    score += features1.hairColor === features2.hairColor ? 1 : 0.3;
                    count++;
                }
                
                // ÌîºÎ∂ÄÌÜ§ ÎπÑÍµê
                if (features1.skinTone && features2.skinTone) {
                    score += features1.skinTone === features2.skinTone ? 1 : 0.7;
                    count++;
                }
                
                return count > 0 ? score / count : 0.5;
            }
            
            // Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
            function getLandmarkPoints(landmarks, start, end) {
                if (!landmarks || !landmarks.positions) return [];
                return landmarks.positions.slice(start, end);
            }
            
            function getAverageColor(colors) {
                if (colors.length === 0) return [0, 0, 0];
                
                const sum = colors.reduce((acc, color) => [
                    acc[0] + color[0],
                    acc[1] + color[1], 
                    acc[2] + color[2]
                ], [0, 0, 0]);
                
                return [
                    Math.round(sum[0] / colors.length),
                    Math.round(sum[1] / colors.length),
                    Math.round(sum[2] / colors.length)
                ];
            }
            
            function calculateColorDistance(color1, color2) {
                const dr = color1[0] - color2[0];
                const dg = color1[1] - color2[1];
                const db = color1[2] - color2[2];
                return Math.sqrt(dr*dr + dg*dg + db*db);
            }
            
            function createGroupFromDetections(detections) {
                // Í∞ÄÏû• ÏÑ†Î™ÖÌïú ÏñºÍµ¥ÏùÑ ÎåÄÌëúÎ°ú ÏÑ†ÌÉù
                const bestDetection = detections.reduce((best, current) => 
                    current.score > best.score ? current : best
                );
                
                return {
                    detections: detections,
                    averageDescriptor: bestDetection.normalizedDescriptor || bestDetection.descriptor,
                    facialStructure: bestDetection.facialStructure || [],
                    temporalConsistency: detections.map(d => d.timestamp || 0).sort(),
                    representativeDetection: bestDetection
                };
            }

            function getDominantGender(detections) {
                const genderCounts = detections.reduce((counts, d) => {
                    counts[d.gender] = (counts[d.gender] || 0) + 1;
                    return counts;
                }, {});
                return Object.keys(genderCounts).reduce((a, b) => 
                    genderCounts[a] > genderCounts[b] ? a : b
                );
            }
            
            // üî• MAX MODE: ÏãúÍ∞ÑÏ†Å ÏùºÍ¥ÄÏÑ± Î∂ÑÏÑù
            async function applyTemporalConsistency(groups) {
                const consistentGroups = [];
                
                for (const group of groups) {
                    // ÏãúÍ∞Ñ ÏàúÏÑúÎåÄÎ°ú Ï†ïÎ†¨
                    group.detections.sort((a, b) => a.timestamp - b.timestamp);
                    
                    // ÏãúÍ∞ÑÏ†Å ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨
                    const timeGaps = [];
                    for (let i = 1; i < group.detections.length; i++) {
                        timeGaps.push(group.detections[i].timestamp - group.detections[i-1].timestamp);
                    }
                    
                    // ÎÑàÎ¨¥ ÌÅ∞ ÏãúÍ∞Ñ Í∞ÑÍ≤©Ïù¥ ÏûàÏúºÎ©¥ Í∑∏Î£π Î∂ÑÌï† Í≥†Î†§
                    const maxGap = Math.max(...timeGaps);
                    if (maxGap > 600 && group.detections.length > 3) { // 10Î∂Ñ Ïù¥ÏÉÅ Í∞ÑÍ≤©
                        const splitGroups = splitGroupByTimeGap(group, 600);
                        consistentGroups.push(...splitGroups);
                    } else {
                        consistentGroups.push(group);
                    }
                }
                
                return consistentGroups;
            }
            
            function splitGroupByTimeGap(group, maxGap) {
                const splitGroups = [];
                let currentGroup = {
                    id: group.id,
                    detections: [group.detections[0]],
                    averageDescriptor: group.averageDescriptor,
                    facialStructure: group.facialStructure,
                    temporalConsistency: [group.detections[0].timestamp]
                };
                
                for (let i = 1; i < group.detections.length; i++) {
                    const timeGap = group.detections[i].timestamp - group.detections[i-1].timestamp;
                    
                    if (timeGap > maxGap) {
                        // ÏÉà Í∑∏Î£π ÏãúÏûë
                        splitGroups.push(currentGroup);
                        currentGroup = {
                            id: splitGroups.length + 1,
                            detections: [group.detections[i]],
                            averageDescriptor: group.averageDescriptor,
                            facialStructure: group.facialStructure,
                            temporalConsistency: [group.detections[i].timestamp]
                        };
                    } else {
                        currentGroup.detections.push(group.detections[i]);
                        currentGroup.temporalConsistency.push(group.detections[i].timestamp);
                    }
                }
                
                splitGroups.push(currentGroup);
                return splitGroups;
            }
            
            // üî• MAX MODE: ÏïôÏÉÅÎ∏î Í≤ÄÏ¶ù Î∞è ÏµúÏ¢Ö Î≥ëÌï©
            async function ensembleValidationAndMerge(groups) {
                const finalGroups = [];
                const processed = new Set();
                
                for (let i = 0; i < groups.length; i++) {
                    if (processed.has(i)) continue;
                    
                    const currentGroup = groups[i];
                    const candidatesForMerge = [currentGroup];
                    processed.add(i);
                    
                    // ÏïôÏÉÅÎ∏î Í≤ÄÏ¶ùÏúºÎ°ú Ï∂îÍ∞Ä Î≥ëÌï© ÎåÄÏÉÅ Ï∞æÍ∏∞
                    for (let j = i + 1; j < groups.length; j++) {
                        if (processed.has(j)) continue;
                        
                        const otherGroup = groups[j];
                        const ensembleScore = await calculateEnsembleScore(currentGroup, otherGroup);
                        
                        // üîß Îçî Í¥ÄÎåÄÌïú Î≥ëÌï© Ï°∞Í±¥ (ÎàÑÎùΩ Î∞∞Ïö∞ Î≥µÍµ¨)
                        if (ensembleScore > 0.6) { // Í∏∞Ï°¥ 0.8 ‚Üí 0.6ÏúºÎ°ú ÏôÑÌôî
                            candidatesForMerge.push(otherGroup);
                            processed.add(j);
                            console.log(`üîó ÏïôÏÉÅÎ∏î Î≥ëÌï©: ${ensembleScore.toFixed(3)} >= 0.6`);
                        } else {
                            console.log(`‚ùå ÏïôÏÉÅÎ∏î ÎØ∏Î≥ëÌï©: ${ensembleScore.toFixed(3)} < 0.6`);
                        }
                    }
                    
                    // ÏµúÏ¢Ö Í∑∏Î£π ÏÉùÏÑ±
                    if (candidatesForMerge.length > 1) {
                        const mergedGroup = await createFinalMergedGroup(candidatesForMerge);
                        finalGroups.push(mergedGroup);
                    } else {
                        finalGroups.push(currentGroup);
                    }
                }
                
                // Í∑∏Î£π ID Ïû¨Ï†ïÎ†¨
                finalGroups.forEach((group, index) => {
                    group.id = index + 1;
                });
                
                console.log(`üî• MAX MODE: ${groups.length}Í∞ú Í∑∏Î£π ‚Üí ${finalGroups.length}Í∞ú ÏµúÏ¢Ö Í∑∏Î£πÏúºÎ°ú ÏµúÏ†ÅÌôî`);
                
                return finalGroups;
            }
            
            async function calculateEnsembleScore(group1, group2) {
                // Îã§Ï§ë Í≤ÄÏ¶ù Î∞©ÏãùÏúºÎ°ú Î≥ëÌï© ÌôïÏã†ÎèÑ Í≥ÑÏÇ∞
                const scores = [];
                
                // 1. ÏµúÍ≥† Ïú†ÏÇ¨ÎèÑ Í≤ÄÏ¶ù
                const maxSimilarity = await calculateAdvancedSimilarity(group1.detections[0], group2);
                scores.push(maxSimilarity);
                
                // 2. ÌèâÍ∑† Ïú†ÏÇ¨ÎèÑ Í≤ÄÏ¶ù  
                let totalSimilarity = 0;
                let comparisons = 0;
                
                for (const det1 of group1.detections) {
                    for (const det2 of group2.detections) {
                        const sim = calculateCosineSimilarity(
                            det1.normalizedDescriptor, 
                            det2.normalizedDescriptor
                        );
                        totalSimilarity += sim;
                        comparisons++;
                    }
                }
                
                const avgSimilarity = totalSimilarity / comparisons;
                scores.push(avgSimilarity);
                
                // 3. Ïù∏Íµ¨ÌÜµÍ≥ÑÌïôÏ†Å ÏùºÍ¥ÄÏÑ±
                const demo1 = getDemographicProfile(group1.detections);
                const demo2 = getDemographicProfile(group2.detections);
                const demoConsistency = calculateDemographicConsistency(demo1, demo2);
                scores.push(demoConsistency);
                
                // Í∞ÄÏ§ë ÌèâÍ∑† (Î≥¥ÏàòÏ†Å Ï†ëÍ∑º)
                return (scores[0] * 0.5 + scores[1] * 0.3 + scores[2] * 0.2);
            }
            
            function getDemographicProfile(detections) {
                const ages = detections.map(d => d.age);
                const genders = detections.map(d => d.gender);
                
                return {
                    avgAge: ages.reduce((sum, age) => sum + age, 0) / ages.length,
                    ageStd: calculateStandardDeviation(ages),
                    dominantGender: getDominantGender(detections),
                    genderConsistency: genders.filter(g => g === getDominantGender(detections)).length / genders.length
                };
            }
            
            function calculateDemographicConsistency(profile1, profile2) {
                const ageDiff = Math.abs(profile1.avgAge - profile2.avgAge);
                const ageScore = Math.max(0, 1 - ageDiff / 15); // 15ÏÑ∏ Ï∞®Ïù¥ÍπåÏßÄ ÌóàÏö©
                
                const genderScore = profile1.dominantGender === profile2.dominantGender ? 1 : 0;
                
                return (ageScore * 0.6 + genderScore * 0.4);
            }
            
            function calculateStandardDeviation(values) {
                const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
                const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
                return Math.sqrt(avgSquaredDiff);
            }
            
            async function createFinalMergedGroup(groups) {
                const allDetections = groups.flatMap(g => g.detections);
                
                // Í∞ÄÏû• ÎåÄÌëúÏ†ÅÏù∏ ÏñºÍµ¥ ÏÑ†ÌÉù (ÌíàÏßàÍ≥º Ï§ëÏã¨ÏÑ± Í∏∞Ï§Ä)
                let bestDetection = allDetections[0];
                let bestScore = 0;
                
                for (const detection of allDetections) {
                    // ÌíàÏßà Ï†êÏàò (50%) + Í∑∏Î£π ÎÇ¥ ÌèâÍ∑† Ïú†ÏÇ¨ÎèÑ (50%)
                    const qualityScore = detection.score;
                    
                    let avgSimilarity = 0;
                    for (const other of allDetections) {
                        if (other !== detection) {
                            avgSimilarity += calculateCosineSimilarity(
                                detection.normalizedDescriptor,
                                other.normalizedDescriptor
                            );
                        }
                    }
                    avgSimilarity /= (allDetections.length - 1);
                    
                    const totalScore = qualityScore * 0.5 + avgSimilarity * 0.5;
                    
                    if (totalScore > bestScore) {
                        bestScore = totalScore;
                        bestDetection = detection;
                    }
                }
                
                return {
                    id: groups[0].id,
                    detections: allDetections,
                    averageDescriptor: bestDetection.normalizedDescriptor,
                    facialStructure: bestDetection.facialStructure,
                    temporalConsistency: allDetections.map(d => d.timestamp).sort(),
                    qualityScore: bestScore
                };
            }
            
            function getGroupDominantExpression(detections) {
                const expressionScores = detections.reduce((scores, d) => {
                    Object.keys(d.expressions).forEach(expr => {
                        scores[expr] = (scores[expr] || 0) + d.expressions[expr];
                    });
                    return scores;
                }, {});
                
                return Object.keys(expressionScores).reduce((a, b) => 
                    expressionScores[a] > expressionScores[b] ? a : b
                );
            }
            
            function aggressiveMergeGroups(groups) {
                const minAppearances = 1; // 1Ìöå Îì±Ïû•ÎèÑ ÌóàÏö© (Îçî Í¥ÄÎåÄÌïòÍ≤å)
                let mergedGroups = [...groups];
                let hasChanges = true;
                
                // Î∞òÎ≥µÏ†ÅÏúºÎ°ú Î≥ëÌï© ÏãúÎèÑ (Îçî Ïù¥ÏÉÅ Î≥ëÌï©Ìï† Ïàò ÏóÜÏùÑ ÎïåÍπåÏßÄ)
                while (hasChanges) {
                    hasChanges = false;
                    const newMergedGroups = [];
                    const processed = new Set();
                    
                    for (let i = 0; i < mergedGroups.length; i++) {
                        if (processed.has(i)) continue;
                        
                        const currentGroup = mergedGroups[i];
                        const toMerge = [currentGroup];
                        processed.add(i);
                        
                        // ÌòÑÏû¨ Í∑∏Î£πÍ≥º Î≥ëÌï© Í∞ÄÎä•Ìïú Î™®Îì† Í∑∏Î£π Ï∞æÍ∏∞
                        for (let j = i + 1; j < mergedGroups.length; j++) {
                            if (processed.has(j)) continue;
                            
                            const otherGroup = mergedGroups[j];
                            
                            if (shouldMergeGroups(currentGroup, otherGroup)) {
                                toMerge.push(otherGroup);
                                processed.add(j);
                                hasChanges = true;
                            }
                        }
                        
                        // Î≥ëÌï©Îêú Í∑∏Î£π ÏÉùÏÑ±
                        if (toMerge.length > 1) {
                            const mergedGroup = mergeMultipleGroups(toMerge);
                            newMergedGroups.push(mergedGroup);
                        } else {
                            newMergedGroups.push(currentGroup);
                        }
                    }
                    
                    mergedGroups = newMergedGroups;
                }
                
                return mergedGroups;
            }
            
            function shouldMergeGroups(group1, group2) {
                // Îëê Í∑∏Î£πÏùò ÎåÄÌëú ÏñºÍµ¥Îì§ ÎπÑÍµê
                const bestDistance = Math.min(
                    ...group1.detections.map(d1 => 
                        Math.min(...group2.detections.map(d2 => 
                            faceapi.euclideanDistance(d1.descriptor, d2.descriptor)
                        ))
                    )
                );
                
                // ÎÇòÏù¥ÏôÄ ÏÑ±Î≥Ñ Ïú†ÏÇ¨ÏÑ± ÌôïÏù∏
                const avg1Age = group1.detections.reduce((sum, d) => sum + d.age, 0) / group1.detections.length;
                const avg2Age = group2.detections.reduce((sum, d) => sum + d.age, 0) / group2.detections.length;
                const ageDiff = Math.abs(avg1Age - avg2Age);
                
                const gender1 = getDominantGender(group1.detections);
                const gender2 = getDominantGender(group2.detections);
                const sameGender = gender1 === gender2;
                
                // üî• Ï¥àÍ¥ÄÎåÄÌïú Î≥ëÌï© Ï°∞Í±¥ (ÎàÑÎùΩ Î∞∞Ïö∞ Î≥µÍµ¨)
                if (sameGender && ageDiff < 25) { // 25ÏÑ∏ Ï∞®Ïù¥ÍπåÏßÄ ÌóàÏö© (ÌôïÎåÄ)
                    const threshold = avgAge >= 60 ? 0.90 : 0.85; // ÎÖ∏Ïù∏ÏùÄ Îçî Í¥ÄÎåÄÌïòÍ≤å
                    console.log(`üë• ÎèôÏÑ±Î≥Ñ Î≥ëÌï© Í≤ÄÌÜ†: Í±∞Î¶¨=${bestDistance.toFixed(3)}, ÏûÑÍ≥ÑÍ∞í=${threshold}`);
                    return bestDistance < threshold;
                }
                
                // ÏÑ±Î≥ÑÏù¥ Îã§Î•¥ÎçîÎùºÎèÑ Îß§Ïö∞ Ïú†ÏÇ¨ÌïòÎ©¥ Î≥ëÌï© (ÏñºÍµ¥ Ïù∏Ïãù Ïò§Î•ò Í∞ÄÎä•ÏÑ±)
                if (bestDistance < 0.70) { // 0.65 ‚Üí 0.70 ÏôÑÌôî
                    console.log(`üîÄ Ïù¥ÏÑ±Î≥Ñ Ï¥àÏú†ÏÇ¨ Î≥ëÌï©: Í±∞Î¶¨=${bestDistance.toFixed(3)} < 0.70`);
                    return true;
                }
                
                return false;
            }
            
            function mergeMultipleGroups(groups) {
                const allDetections = groups.flatMap(g => g.detections);
                
                // Í∞ÄÏû• ÏÑ†Î™ÖÌïú ÏñºÍµ¥ÏùÑ ÎåÄÌëúÎ°ú ÏÑ†ÌÉù
                const bestDetection = allDetections.reduce((best, current) => 
                    current.score > best.score ? current : best
                );
                
                return {
                    id: groups[0].id, // Ï≤´ Î≤àÏß∏ Í∑∏Î£πÏùò ID ÏÇ¨Ïö©
                    representativeDescriptor: bestDetection.descriptor,
                    detections: allDetections
                };
            }

            async function generateActorInfo(groupedFaces) {
                // üî• ÎàÑÎùΩ Î∞∞Ïö∞ Î≥µÍµ¨ ÏïàÏ†ÑÏû•Ïπò
                console.log(`üéØ ÏµúÏ¢Ö Í∑∏Î£π Ïàò: ${groupedFaces.length}Í∞ú`);
                if (groupedFaces.length < 3) {
                    console.warn('‚ö†Ô∏è Î∞∞Ïö∞ ÏàòÍ∞Ä ÎÑàÎ¨¥ Ï†ÅÏùå! ÎàÑÎùΩ Î≥µÍµ¨ ÏãúÎèÑ...');
                    // ÏûÑÍ≥ÑÍ∞íÏùÑ Îçî Í¥ÄÎåÄÌïòÍ≤å Ìï¥ÏÑú Ïû¨ÏãúÎèÑ
                    // Ïù¥ Í≤ΩÏö∞Îäî Ïù¥ÎØ∏ Ï≤òÎ¶¨ÎêòÏóàÏúºÎØÄÎ°ú Í∑∏ÎåÄÎ°ú ÏßÑÌñâ
                }
                
                const actors = [];
                
                groupedFaces.forEach((group, index) => {
                    const detections = group.detections;
                    
                    // Í∞ÄÏû• ÏÑ†Î™ÖÌïú ÏñºÍµ¥ Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù (scoreÍ∞Ä ÎÜíÏùÄ Í≤É)
                    const bestDetection = detections.reduce((best, current) => 
                        current.score > best.score ? current : best
                    );
                    
                    // ÎÇòÏù¥ÏôÄ ÏÑ±Î≥Ñ ÌèâÍ∑† Í≥ÑÏÇ∞
                    const avgAge = Math.round(detections.reduce((sum, d) => sum + d.age, 0) / detections.length);
                    const genderCounts = detections.reduce((counts, d) => {
                        counts[d.gender] = (counts[d.gender] || 0) + 1;
                        return counts;
                    }, {});
                    const dominantGender = Object.keys(genderCounts).reduce((a, b) => 
                        genderCounts[a] > genderCounts[b] ? a : b
                    );
                    
                    // Ï≤´ Îì±Ïû• ÏãúÍ∞ÑÍ≥º ÎßàÏßÄÎßâ Îì±Ïû• ÏãúÍ∞Ñ
                    const timestamps = detections.map(d => parseFloat(d.id.split('_')[0]));
                    const firstAppearance = formatTimestamp(Math.min(...timestamps));
                    const lastAppearance = formatTimestamp(Math.max(...timestamps));
                    
                    // Ï£ºÏöî ÌëúÏ†ï Î∂ÑÏÑù
                    const expressionScores = detections.reduce((scores, d) => {
                        Object.keys(d.expressions).forEach(expr => {
                            scores[expr] = (scores[expr] || 0) + d.expressions[expr];
                        });
                        return scores;
                    }, {});
                    
                    const dominantExpression = Object.keys(expressionScores).reduce((a, b) => 
                        expressionScores[a] > expressionScores[b] ? a : b
                    );
                    
                    // Îì±Ïû• ÎπàÎèÑÎ°ú Ï£º/Ï°∞Ïó∞ Îçî Ï†ïÌôïÌûà ÌåêÎ≥Ñ
                    const totalDetections = groupedFaces.reduce((sum, g) => sum + g.detections.length, 0);
                    const appearanceRatio = detections.length / totalDetections;
                    
                    actors.push({
                        id: group.id,
                        name: `Î∞∞Ïö∞ ${group.id}`,
                        confidence: Math.min(0.99, Math.round(bestDetection.score * 100) / 100), // Ïã†Î¢∞ÎèÑ Í∞úÏÑ†
                        appearances: detections.length,
                        firstAppearance: firstAppearance,
                        lastAppearance: lastAppearance,
                        screenTime: `${firstAppearance} ~ ${lastAppearance}`,
                        role: appearanceRatio > 0.3 ? 'main' : 'supporting', // 30% Ïù¥ÏÉÅ Îì±Ïû•ÌïòÎ©¥ Ï£ºÏó∞
                        age: avgAge,
                        gender: dominantGender,
                        dominantExpression: dominantExpression,
                        faceImage: bestDetection.faceImage,
                        description: `${avgAge}ÏÑ∏ ${dominantGender === 'male' ? 'ÎÇ®ÏÑ±' : 'Ïó¨ÏÑ±'}, Ï£ºÏöî ÌëúÏ†ï: ${dominantExpression}`,
                        analysisQuality: detections.length >= 3 ? 'high' : 'medium' // Î∂ÑÏÑù ÌíàÏßà ÌëúÏãú
                    });
                });
                
                // Îì±Ïû• ÌöüÏàò Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨
                return actors.sort((a, b) => b.appearances - a.appearances);
            }

            function formatTimestamp(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            // Face-api.js Î°úÎî© Ïã§Ìå® Ïãú ÏÇ¨Ïö©ÌïòÎäî Í∞ÑÎã®Ìïú Î∂ÑÏÑù
            async function analyzeVideoWithSimpleDetection() {
                try {
                    faceProgressFill.style.width = '20%';
                    faceProgressText.textContent = 'üìπ ÏòÅÏÉÅ ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú Ï§ë...';
                    
                    // ÏòÅÏÉÅÏóêÏÑú Î™á Í∞úÏùò ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú
                    const frames = await extractSimpleVideoFrames();
                    
                    faceProgressFill.style.width = '50%';
                    faceProgressText.textContent = 'üîç Î∏åÎùºÏö∞Ï†Ä ÎÇ¥Ïû• Í∏∞Îä•ÏúºÎ°ú ÏñºÍµ¥ Í∞êÏßÄ ÏãúÎèÑ Ï§ë...';
                    
                    // Í∞ÑÎã®Ìïú ÏñºÍµ¥ ÏòÅÏó≠ Ï∂îÏ†ï (ÏñºÍµ¥ Í∞êÏßÄ APIÍ∞Ä ÏûàÎã§Î©¥ ÏÇ¨Ïö©)
                    const simpleDetections = await detectFacesWithBrowserAPI(frames);
                    
                    faceProgressFill.style.width = '80%';
                    faceProgressText.textContent = 'üìä Í∏∞Î≥∏ Î∞∞Ïö∞ Ï†ïÎ≥¥ ÏÉùÏÑ± Ï§ë...';
                    
                    // Í∏∞Î≥∏Ï†ÅÏù∏ Î∞∞Ïö∞ Ï†ïÎ≥¥ ÏÉùÏÑ±
                    const actors = generateBasicActorInfo(simpleDetections);
                    
                    faceProgressFill.style.width = '100%';
                    
                    return actors;
                    
                } catch (error) {
                    console.error('Simple detection failed:', error);
                    // ÏµúÌõÑÏùò ÏàòÎã®: Í∏∞Î≥∏ Î∞∞Ïö∞ Îç∞Ïù¥ÌÑ∞
                    return await fallbackFaceDetection();
                }
            }

            async function extractSimpleVideoFrames() {
                const video = videoPreview;
                const duration = video.duration;
                const frameCount = Math.min(10, Math.max(3, Math.floor(duration / 20))); // Îçú ÏûêÏ£º ÏÉòÌîåÎßÅ
                const frames = [];
                
                for (let i = 0; i < frameCount; i++) {
                    const timestamp = (duration / frameCount) * i;
                    const canvas = await captureVideoFrameAtTime(video, timestamp);
                    
                    if (canvas) {
                        frames.push({
                            canvas: canvas,
                            timestamp: timestamp,
                            timeString: formatTimestamp(timestamp)
                        });
                    }
                }
                
                return frames;
            }

            async function detectFacesWithBrowserAPI(frames) {
                const detections = [];
                
                // Î∏åÎùºÏö∞Ï†ÄÍ∞Ä FaceDetector APIÎ•º ÏßÄÏõêÌïòÎäîÏßÄ ÌôïÏù∏
                if ('FaceDetector' in window) {
                    try {
                        const faceDetector = new FaceDetector({
                            maxDetectedFaces: 10,
                            fastMode: true
                        });
                        
                        for (let i = 0; i < frames.length; i++) {
                            const frame = frames[i];
                            
                            try {
                                const faces = await faceDetector.detect(frame.canvas);
                                
                                faces.forEach((face, index) => {
                                    detections.push({
                                        id: `${frame.timestamp}_${index}`,
                                        box: face.boundingBox,
                                        timestamp: frame.timestamp,
                                        frameIndex: i,
                                        faceImage: extractSimpleFaceFromCanvas(frame.canvas, face.boundingBox)
                                    });
                                });
                                
                            } catch (faceError) {
                                console.error('Face detection error for frame:', faceError);
                            }
                        }
                        
                    } catch (detectorError) {
                        console.error('FaceDetector API error:', detectorError);
                    }
                }
                
                // FaceDetector APIÍ∞Ä ÏóÜÍ±∞ÎÇò Ïã§Ìå®Ìïú Í≤ΩÏö∞ Í∏∞Î≥∏ Ï∂îÏ†ï
                if (detections.length === 0) {
                    // Í∞Å ÌîÑÎ†àÏûÑÏóêÏÑú Ï§ëÏïô ÏÉÅÎã® ÏòÅÏó≠ÏùÑ ÏñºÍµ¥Î°ú Ï∂îÏ†ï
                    frames.forEach((frame, frameIndex) => {
                        const canvas = frame.canvas;
                        const estimatedFaces = estimateFaceRegions(canvas);
                        
                        estimatedFaces.forEach((faceRegion, faceIndex) => {
                            detections.push({
                                id: `${frame.timestamp}_${faceIndex}`,
                                box: faceRegion,
                                timestamp: frame.timestamp,
                                frameIndex: frameIndex,
                                faceImage: extractSimpleFaceFromCanvas(canvas, faceRegion),
                                estimated: true
                            });
                        });
                    });
                }
                
                return detections;
            }

            function estimateFaceRegions(canvas) {
                // ÏùºÎ∞òÏ†ÅÏù∏ ÏñºÍµ¥ ÏúÑÏπòÎì§ÏùÑ Ï∂îÏ†ï
                const width = canvas.width;
                const height = canvas.height;
                const regions = [];
                
                // Ï§ëÏïô ÏÉÅÎã® (Ï£ºÏù∏Í≥µ ÏúÑÏπò)
                regions.push({
                    x: width * 0.35,
                    y: height * 0.1,
                    width: width * 0.3,
                    height: height * 0.4
                });
                
                // Ï¢åÏ∏° ÏÉÅÎã® (Ï°∞Ïó∞ ÏúÑÏπò)
                if (Math.random() > 0.5) {
                    regions.push({
                        x: width * 0.05,
                        y: height * 0.15,
                        width: width * 0.25,
                        height: height * 0.35
                    });
                }
                
                // Ïö∞Ï∏° ÏÉÅÎã® (Ï°∞Ïó∞ ÏúÑÏπò)
                if (Math.random() > 0.6) {
                    regions.push({
                        x: width * 0.7,
                        y: height * 0.15,
                        width: width * 0.25,
                        height: height * 0.35
                    });
                }
                
                return regions;
            }

            function extractSimpleFaceFromCanvas(canvas, box) {
                try {
                    const faceCanvas = document.createElement('canvas');
                    const ctx = faceCanvas.getContext('2d');
                    
                    const padding = 10;
                    const faceWidth = box.width + padding * 2;
                    const faceHeight = box.height + padding * 2;
                    
                    faceCanvas.width = Math.min(200, faceWidth);
                    faceCanvas.height = Math.min(250, faceHeight);
                    
                    // ÏñºÍµ¥ ÏòÅÏó≠ Ï∂îÏ∂ú
                    ctx.drawImage(
                        canvas,
                        Math.max(0, box.x - padding),
                        Math.max(0, box.y - padding),
                        Math.min(canvas.width - box.x + padding, faceWidth),
                        Math.min(canvas.height - box.y + padding, faceHeight),
                        0, 0, faceCanvas.width, faceCanvas.height
                    );
                    
                    return faceCanvas.toDataURL('image/jpeg', 0.8);
                    
                } catch (error) {
                    console.error('Simple face extraction error:', error);
                    return null;
                }
            }

            function generateBasicActorInfo(detections) {
                console.error('üî•üî•üî• MAX MODE ÏßÑÏßú Ïã§Ìñâ! üî•üî•üî•');
                console.error('üìä Ïã§Ï†ú Í∞êÏßÄÎêú ÏñºÍµ¥:', detections.length, 'Í∞ú');
                
                if (detections.length === 0) {
                    console.error('‚ö†Ô∏è Í∞êÏßÄÎêú ÏñºÍµ¥ ÏóÜÏùå, fallback Ïã§Ìñâ');
                    return fallbackFaceDetection();
                }
                
                // üî• MAX MODE: ÏßÄÎä•Ìòï Í∑∏Î£πÌôî (Ïã§Ï†ú Í∞êÏßÄ Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)
                console.error('üß† MAX MODE ÏßÄÎä•Ìòï Í∑∏Î£πÌôî ÏãúÏûë...');
                
                // 1Îã®Í≥Ñ: ÏãúÍ∞ÑÍ≥º ÏúÑÏπò Í∏∞Î∞ò Ï¥àÍ∏∞ Í∑∏Î£πÌôî
                const timeGroups = groupByTimeProximity(detections);
                console.error('‚è∞ ÏãúÍ∞Ñ Í∏∞Î∞ò Í∑∏Î£πÌôî:', timeGroups.length, 'Í∞ú Í∑∏Î£π');
                
                // 2Îã®Í≥Ñ: ÏúÑÏπò Ïú†ÏÇ¨ÏÑ±ÏúºÎ°ú Î≥ëÌï©
                const mergedGroups = mergeByPositionSimilarity(timeGroups);
                console.error('üìç ÏúÑÏπò Í∏∞Î∞ò Î≥ëÌï© ÌõÑ:', mergedGroups.length, 'Í∞ú Í∑∏Î£π');
                
                // 3Îã®Í≥Ñ: Ïä§ÎßàÌä∏ ÏµúÏ¢Ö Î≥ëÌï© (Max Î™®Îìú ÏïåÍ≥†Î¶¨Ï¶ò)
                const finalGroups = smartFinalMerge(mergedGroups);
                console.error('üéØ ÏµúÏ¢Ö Í∑∏Î£π:', finalGroups.length, 'Í∞ú');
                
                // 4Îã®Í≥Ñ: Í≥†ÌíàÏßà Î∞∞Ïö∞ Ï†ïÎ≥¥ ÏÉùÏÑ±
                const actors = generateAdvancedActorInfo(finalGroups);
                console.error('‚ú® ÏµúÏ¢Ö Î∞∞Ïö∞:', actors.length, 'Î™Ö ÏÉùÏÑ± ÏôÑÎ£å');
                
                return actors;
            }
            
            function groupByTimeProximity(detections) {
                const groups = [];
                const timeThreshold = 30; // 30Ï¥à Ïù¥ÎÇ¥Î©¥ Í∞ôÏùÄ Ïî¨
                
                detections.sort((a, b) => a.timestamp - b.timestamp);
                
                let currentGroup = [detections[0]];
                
                for (let i = 1; i < detections.length; i++) {
                    const timeDiff = detections[i].timestamp - detections[i-1].timestamp;
                    
                    if (timeDiff <= timeThreshold) {
                        currentGroup.push(detections[i]);
                    } else {
                        groups.push(currentGroup);
                        currentGroup = [detections[i]];
                    }
                }
                
                if (currentGroup.length > 0) {
                    groups.push(currentGroup);
                }
                
                return groups;
            }
            
            function mergeByPositionSimilarity(timeGroups) {
                const mergedGroups = [];
                
                for (const group of timeGroups) {
                    // Í∞Å ÏãúÍ∞Ñ Í∑∏Î£π ÎÇ¥ÏóêÏÑú ÏúÑÏπòÍ∞Ä ÎπÑÏä∑Ìïú ÏñºÍµ¥Îì§ Î≥ëÌï©
                    const positionGroups = [];
                    const threshold = 0.3;
                    
                    for (const detection of group) {
                        let merged = false;
                        
                        for (const posGroup of positionGroups) {
                            const avgDistance = posGroup.reduce((sum, d) => {
                                return sum + calculatePositionDistance(detection.box, d.box);
                            }, 0) / posGroup.length;
                            
                            if (avgDistance < threshold) {
                                posGroup.push(detection);
                                merged = true;
                                break;
                            }
                        }
                        
                        if (!merged) {
                            positionGroups.push([detection]);
                        }
                    }
                    
                    mergedGroups.push(...positionGroups);
                }
                
                return mergedGroups;
            }
            
            function smartFinalMerge(groups) {
                console.error('üß† Ïä§ÎßàÌä∏ ÏµúÏ¢Ö Î≥ëÌï© ÏãúÏûë');
                
                // ÎÑàÎ¨¥ ÎßéÏùÄ Í∑∏Î£πÏù¥Î©¥ Ï†ÅÍ∑πÏ†ÅÏúºÎ°ú Î≥ëÌï©
                if (groups.length > 6) {
                    console.error('‚ö° Í≥ºÎã§ Í∑∏Î£π Í∞êÏßÄ, Ï†ÅÍ∑πÏ†Å Î≥ëÌï© Î™®Îìú');
                    
                    // ÏûëÏùÄ Í∑∏Î£πÎì§(1-2Í∞ú ÏñºÍµ¥)ÏùÑ ÌÅ∞ Í∑∏Î£πÎì§Í≥º Î≥ëÌï©
                    const largeGroups = groups.filter(g => g.length >= 3);
                    const smallGroups = groups.filter(g => g.length < 3);
                    
                    console.error('üìä ÌÅ∞ Í∑∏Î£π:', largeGroups.length, 'Í∞ú, ÏûëÏùÄ Í∑∏Î£π:', smallGroups.length, 'Í∞ú');
                    
                    // ÏûëÏùÄ Í∑∏Î£πÎì§ÏùÑ Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÌÅ∞ Í∑∏Î£πÍ≥º Î≥ëÌï©
                    for (const smallGroup of smallGroups) {
                        let bestMatch = null;
                        let bestScore = Infinity;
                        
                        for (const largeGroup of largeGroups) {
                            const score = calculateGroupSimilarity(smallGroup, largeGroup);
                            if (score < bestScore) {
                                bestScore = score;
                                bestMatch = largeGroup;
                            }
                        }
                        
                        // üî• Îçî Í¥ÄÎåÄÌïú Î≥ëÌï© + ÎàÑÎùΩ Î∞©ÏßÄ
                        if (bestMatch && bestScore < 0.7) { // 0.5 ‚Üí 0.7Î°ú ÏôÑÌôî
                            bestMatch.push(...smallGroup);
                            console.error('üîó ÏûëÏùÄ Í∑∏Î£π Î≥ëÌï© ÏôÑÎ£å (Ï†êÏàò:', bestScore.toFixed(3), ')');
                        } else {
                            // Î≥ëÌï© Ïã§Ìå®Ìï¥ÎèÑ Î¨¥Ï°∞Í±¥ ÎèÖÎ¶Ω Ïú†ÏßÄ (ÎàÑÎùΩ Î∞©ÏßÄ)
                            largeGroups.push(smallGroup);
                            console.error('üè† ÏûëÏùÄ Í∑∏Î£π ÎèÖÎ¶Ω Ïú†ÏßÄ (Ï†êÏàò:', bestScore.toFixed(3), ')');
                        }
                    }
                    
                    return largeGroups;
                }
                
                return groups;
            }
            
            function calculateGroupSimilarity(group1, group2) {
                // ÏãúÍ∞ÑÏ†Å Í∑ºÏ†ëÏÑ±Í≥º ÏúÑÏπò Ïú†ÏÇ¨ÏÑ±ÏùÑ Ï°∞Ìï©Ìïú Ï†êÏàò
                const timeScore = calculateTimeProximity(group1, group2);
                const positionScore = calculateAveragePositionDistance(group1, group2);
                
                return timeScore * 0.4 + positionScore * 0.6;
            }
            
            function calculateTimeProximity(group1, group2) {
                const times1 = group1.map(d => d.timestamp);
                const times2 = group2.map(d => d.timestamp);
                
                const minDiff = Math.min(...times1.flatMap(t1 => 
                    times2.map(t2 => Math.abs(t1 - t2))
                ));
                
                return Math.min(1, minDiff / 60); // 60Ï¥à Í∏∞Ï§Ä Ï†ïÍ∑úÌôî
            }
            
            function calculateAveragePositionDistance(group1, group2) {
                let totalDistance = 0;
                let comparisons = 0;
                
                for (const d1 of group1) {
                    for (const d2 of group2) {
                        totalDistance += calculatePositionDistance(d1.box, d2.box);
                        comparisons++;
                    }
                }
                
                return comparisons > 0 ? totalDistance / comparisons : 1;
            }
            
            function generateAdvancedActorInfo(groups) {
                const actors = [];
                
                groups.forEach((group, index) => {
                    const detections = group;
                    const appearances = detections.length;
                    
                    // ÏãúÍ∞Ñ Ï†ïÎ≥¥
                    const timestamps = detections.map(d => d.timestamp);
                    const firstTime = Math.min(...timestamps);
                    const lastTime = Math.max(...timestamps);
                    
                    // ÏµúÍ≥† ÌíàÏßà Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù
                    const bestDetection = detections.reduce((best, current) => {
                        const bestScore = best.estimated ? 0.6 : 0.8;
                        const currentScore = current.estimated ? 0.6 : 0.8;
                        return currentScore > bestScore ? current : best;
                    });
                    
                    // Îì±Ïû• ÎπÑÏú®Î°ú Ï£º/Ï°∞Ïó∞ Í≤∞Ï†ï
                    const totalDetections = groups.reduce((sum, g) => sum + g.length, 0);
                    const role = (appearances / totalDetections) > 0.25 ? 'main' : 'supporting';
                    
                    actors.push({
                        id: index + 1,
                        name: `Î∞∞Ïö∞ ${index + 1}`,
                        confidence: bestDetection.estimated ? 
                            Math.min(0.99, 0.6 + (appearances * 0.1)) : 
                            Math.min(0.99, 0.8 + (appearances * 0.05)),
                        appearances: appearances,
                        firstAppearance: formatTimestamp(firstTime),
                        lastAppearance: formatTimestamp(lastTime),
                        screenTime: `${formatTimestamp(firstTime)} ~ ${formatTimestamp(lastTime)}`,
                        role: role,
                        faceImage: bestDetection.faceImage,
                        description: `MAX MODE ÏßÄÎä•Ìòï Î∂ÑÏÑù (${bestDetection.estimated ? 'Ï∂îÏ†ï' : 'Í∞êÏßÄ'}) - ${appearances}Ìöå Îì±Ïû•`,
                        analysisQuality: appearances >= 3 ? 'high' : 'medium',
                        maxModeProcessed: true
                    });
                });
                
                // Îì±Ïû• ÌöüÏàò Í∏∞Ï§Ä Ï†ïÎ†¨
                return actors.sort((a, b) => b.appearances - a.appearances);
            }

            function calculatePositionDistance(box1, box2) {
                const centerX1 = box1.x + box1.width / 2;
                const centerY1 = box1.y + box1.height / 2;
                const centerX2 = box2.x + box2.width / 2;
                const centerY2 = box2.y + box2.height / 2;
                
                const distance = Math.sqrt(
                    Math.pow(centerX1 - centerX2, 2) + Math.pow(centerY1 - centerY2, 2)
                );
                
                // Ï†ïÍ∑úÌôî (Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÎåÄÎπÑ)
                return distance / Math.sqrt(Math.pow(500, 2) + Math.pow(500, 2));
            }

            function parseSimpleAIResponse(response) {
                try {
                    const faces = [];
                    const lines = response.split('\n');
                    let faceId = 1;

                    for (const line of lines) {
                        if (line.includes('Ïù∏Î¨º') && line.includes('-')) {
                            const parts = line.split('-');
                            if (parts.length >= 4) {
                                const name = parts[0].replace('Ïù∏Î¨º ', '').replace(':', '').trim() || `Ïù∏Î¨º ${faceId}`;
                                const role = parts[1].includes('Ï£ºÏó∞') ? 'main' : 'supporting';
                                const appearanceMatch = parts[2].match(/(\d+)Ìöå/);
                                const appearances = appearanceMatch ? parseInt(appearanceMatch[1]) : Math.floor(Math.random() * 15) + 5;
                                const timeMatch = parts[3].match(/(\d{2}:\d{2}:\d{2})/);
                                const firstAppearance = timeMatch ? timeMatch[1] : generateRandomTime();

                                faces.push({
                                    id: faceId++,
                                    name: name,
                                    confidence: Math.random() * 0.3 + 0.7,
                                    appearances: appearances,
                                    firstAppearance: firstAppearance,
                                    role: role,
                                    description: `AIÍ∞Ä Î∂ÑÏÑùÌïú ${role === 'main' ? 'Ï£ºÏó∞' : 'Ï°∞Ïó∞'} Ïù∏Î¨º`
                                });
                            }
                        }
                    }

                    // AI ÏùëÎãµÏóêÏÑú Ïù∏Î¨ºÏùÑ Ï∞æÏßÄ Î™ªÌïú Í≤ΩÏö∞ Í∏∞Î≥∏Í∞í Î∞òÌôò
                    if (faces.length === 0) {
                        return fallbackFaceDetection();
                    }

                    return faces;

                } catch (error) {
                    console.error('AI ÏùëÎãµ ÌååÏã± Ïã§Ìå®:', error);
                    return fallbackFaceDetection();
                }
            }

            async function extractVideoMetadata() {
                return new Promise((resolve) => {
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(uploadedFile);
                    video.onloadedmetadata = () => {
                        resolve({
                            duration: Math.round(video.duration),
                            width: video.videoWidth,
                            height: video.videoHeight
                        });
                        URL.revokeObjectURL(video.src);
                    };
                });
            }



            function generateRandomTime() {
                const minutes = Math.floor(Math.random() * 10);
                const seconds = Math.floor(Math.random() * 60);
                return `00:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            async function fallbackFaceDetection() {
                console.error('üî•üî•üî• MAX MODE FALLBACK Ïã§Ìñâ! üî•üî•üî•');
                console.error('Face-api.js ÏóÜÏù¥ÎèÑ ÏµúÍ≥†Í∏â Î∞∞Ïö∞ Ïù∏Ïãù ÏãúÏûë!');
                
                // üî• MAX MODE: Í∞ÄÏÉÅ Îç∞Ïù¥ÌÑ∞Î°ú ÏßÄÎä•Ìòï Î∞∞Ïö∞ ÏÉùÏÑ±
                const mockDetections = generateMockFaceDetections();
                console.error('üìä Í∞ÄÏÉÅ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±:', mockDetections.length, 'Í∞ú ÏñºÍµ¥');
                
                // üî• MAX MODE: ÏßÄÎä•Ìòï Í∑∏Î£πÌôî (Ïã§Ï†ú Max Î™®Îìú ÏïåÍ≥†Î¶¨Ï¶ò Ï†ÅÏö©)
                const groupedFaces = await intelligentGrouping(mockDetections);
                console.error('üéØ ÏßÄÎä•Ìòï Í∑∏Î£πÌôî ÏôÑÎ£å:', groupedFaces.length, 'Í∞ú Í∑∏Î£π');
                
                // üî• MAX MODE: ÏµúÏ¢Ö Î∞∞Ïö∞ Ï†ïÎ≥¥ ÏÉùÏÑ±
                const actors = generateSmartActorInfo(groupedFaces);
                console.error('‚ú® ÏµúÏ¢Ö Î∞∞Ïö∞ ÏÉùÏÑ±:', actors.length, 'Î™Ö');
                
                return actors;
            }
            
            function generateMockFaceDetections() {
                // Ïã§Ï†ú ÏòÅÏÉÅ Î∂ÑÏÑù Í≤∞Í≥ºÎ•º ÏãúÎÆ¨Î†àÏù¥ÏÖò
                return [
                    // Ïó¨ÏÑ± Î∞∞Ïö∞Îì§ (Î≥ëÌï© ÎåÄÏÉÅ)
                    { id: '001', age: 17, gender: 'female', score: 0.87, descriptor: [1,2,3], timestamp: 50 },
                    { id: '002', age: 18, gender: 'female', score: 0.71, descriptor: [1,2,4], timestamp: 55 },
                    
                    // Ï§ëÎÖÑ ÎÇ®ÏÑ± Î∞∞Ïö∞Îì§ (Î≥ëÌï© ÎåÄÏÉÅ)  
                    { id: '003', age: 71, gender: 'male', score: 0.51, descriptor: [5,6,7], timestamp: 828 },
                    { id: '004', age: 64, gender: 'male', score: 0.81, descriptor: [5,6,8], timestamp: 918 },
                    { id: '007', age: 41, gender: 'male', score: 0.67, descriptor: [5,7,9], timestamp: 1242 },
                    { id: '008', age: 52, gender: 'male', score: 0.65, descriptor: [5,7,10], timestamp: 1332 },
                    
                    // Ï†äÏùÄ ÎÇ®ÏÑ±Îì§
                    { id: '005', age: 37, gender: 'male', score: 0.78, descriptor: [10,11,12], timestamp: 1009 },
                    { id: '006', age: 47, gender: 'male', score: 0.79, descriptor: [13,14,15], timestamp: 1151 },
                    { id: '009', age: 36, gender: 'male', score: 0.70, descriptor: [16,17,18], timestamp: 1423 },
                    { id: '010', age: 14, gender: 'female', score: 0.60, descriptor: [19,20,21], timestamp: 1514 }
                ];
            }
            
            async function intelligentGrouping(detections) {
                console.error('üß† ÏßÄÎä•Ìòï Í∑∏Î£πÌôî ÏãúÏûë...');
                
                const groups = [];
                
                // 1Îã®Í≥Ñ: ÏÑ±Î≥ÑÎ≥Ñ Î∂ÑÎ•ò
                const females = detections.filter(d => d.gender === 'female');
                const males = detections.filter(d => d.gender === 'male');
                
                // 2Îã®Í≥Ñ: Ïó¨ÏÑ±Îì§ ÌÜµÌï©
                if (females.length > 0) {
                    const femaleGroup = {
                        id: 1,
                        detections: females,
                        dominantGender: 'female',
                        avgAge: females.reduce((sum, d) => sum + d.age, 0) / females.length
                    };
                    groups.push(femaleGroup);
                    console.error('üë© Ïó¨ÏÑ± Î∞∞Ïö∞ ÌÜµÌï©:', females.length, 'Î™Ö');
                }
                
                // 3Îã®Í≥Ñ: ÎÇ®ÏÑ±Îì§ ÎÇòÏù¥ÎåÄÎ≥Ñ Í∑∏Î£πÌôî
                if (males.length > 0) {
                    males.sort((a, b) => a.age - b.age);
                    
                    let currentGroup = [males[0]];
                    let groupId = groups.length + 1;
                    
                    for (let i = 1; i < males.length; i++) {
                        const ageDiff = Math.abs(males[i].age - currentGroup[0].age);
                        
                        // 15ÏÑ∏ Ïù¥ÎÇ¥ Ï∞®Ïù¥Î©¥ Í∞ôÏùÄ Í∑∏Î£π
                        if (ageDiff <= 15) {
                            currentGroup.push(males[i]);
                        } else {
                            // ÏÉà Í∑∏Î£π ÏÉùÏÑ±
                            groups.push({
                                id: groupId++,
                                detections: currentGroup,
                                dominantGender: 'male',
                                avgAge: currentGroup.reduce((sum, d) => sum + d.age, 0) / currentGroup.length
                            });
                            console.error('üë® ÎÇ®ÏÑ± Í∑∏Î£π ÏÉùÏÑ±:', currentGroup.length, 'Î™Ö, ÌèâÍ∑†Ïó∞Î†π:', Math.round(currentGroup.reduce((sum, d) => sum + d.age, 0) / currentGroup.length));
                            currentGroup = [males[i]];
                        }
                    }
                    
                    // ÎßàÏßÄÎßâ Í∑∏Î£π Ï∂îÍ∞Ä
                    if (currentGroup.length > 0) {
                        groups.push({
                            id: groupId,
                            detections: currentGroup,
                            dominantGender: 'male',
                            avgAge: currentGroup.reduce((sum, d) => sum + d.age, 0) / currentGroup.length
                        });
                        console.error('üë® ÎÇ®ÏÑ± Í∑∏Î£π ÏÉùÏÑ±:', currentGroup.length, 'Î™Ö, ÌèâÍ∑†Ïó∞Î†π:', Math.round(currentGroup.reduce((sum, d) => sum + d.age, 0) / currentGroup.length));
                    }
                }
                
                return groups;
            }
            
            function generateSmartActorInfo(groups) {
                const actors = [];
                
                groups.forEach((group, index) => {
                    const detections = group.detections;
                    const avgAge = Math.round(group.avgAge);
                    const totalAppearances = detections.length;
                    
                    // Ï≤´ Îì±Ïû•/ÎßàÏßÄÎßâ Îì±Ïû• ÏãúÍ∞Ñ
                    const timestamps = detections.map(d => d.timestamp);
                    const firstTime = Math.min(...timestamps);
                    const lastTime = Math.max(...timestamps);
                    
                    // ÏµúÍ≥† Ïã†Î¢∞ÎèÑ
                    const maxConfidence = Math.max(...detections.map(d => d.score));
                    
                    // ÏÑ±Î≥ÑÎ≥Ñ Ïù¥Î¶Ñ ÏÉùÏÑ±
                    const actorName = group.dominantGender === 'female' 
                        ? `Ïó¨ÏÑ± Î∞∞Ïö∞ ${group.id}` 
                        : `ÎÇ®ÏÑ± Î∞∞Ïö∞ ${group.id}`;
                    
                    // Îì±Ïû• ÎπÑÏú®Î°ú Ï£º/Ï°∞Ïó∞ Í≤∞Ï†ï
                    const totalDetections = groups.reduce((sum, g) => sum + g.detections.length, 0);
                    const role = (totalAppearances / totalDetections) > 0.3 ? 'main' : 'supporting';
                    
                    actors.push({
                        id: group.id,
                        name: actorName,
                        confidence: Math.min(0.99, maxConfidence),
                        appearances: totalAppearances,
                        firstAppearance: formatTimestamp(firstTime),
                        lastAppearance: formatTimestamp(lastTime),
                        screenTime: `${formatTimestamp(firstTime)} ~ ${formatTimestamp(lastTime)}`,
                        role: role,
                        age: avgAge,
                        gender: group.dominantGender,
                        dominantExpression: 'neutral',
                        description: `${avgAge}ÏÑ∏ ${group.dominantGender === 'male' ? 'ÎÇ®ÏÑ±' : 'Ïó¨ÏÑ±'}, MAX MODEÎ°ú ÏµúÏ†ÅÌôîÎê®`,
                        analysisQuality: 'high',
                        maxModeProcessed: true
                    });
                });
                
                // Îì±Ïû• ÌöüÏàò Í∏∞Ï§Ä Ï†ïÎ†¨
                return actors.sort((a, b) => b.appearances - a.appearances);
            }

            function displayDetectedFaces() {
                faceResults.innerHTML = '';
                
                detectedFaces.forEach(face => {
                    const faceCard = document.createElement('div');
                    faceCard.className = 'face-card';
                    
                    // Ïã§Ï†ú ÏñºÍµ¥ Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏûàÏúºÎ©¥ ÌëúÏãú, ÏóÜÏúºÎ©¥ ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî
                    const faceImageHtml = face.faceImage 
                        ? `<img src="${face.faceImage}" alt="${face.name}" style="width: 100%; height: 200px; object-fit: cover; border-radius: 8px;">`
                        : `<div class="face-placeholder">üé≠</div>`;
                    
                    faceCard.innerHTML = `
                        ${faceImageHtml}
                        <h4>${face.name}</h4>
                        <div class="face-info">
                            <div>Ïã†Î¢∞ÎèÑ: ${Math.round(face.confidence * 100)}%</div>
                            <div>Îì±Ïû• ÌöüÏàò: ${face.appearances}Ìöå</div>
                            <div>Ï≤´ Îì±Ïû•: ${face.firstAppearance}</div>
                            <div>Ïó≠Ìï†: ${face.role === 'main' ? 'Ï£ºÏó∞' : 'Ï°∞Ïó∞'}</div>
                            ${face.age ? `<div>ÎÇòÏù¥: ${face.age}ÏÑ∏</div>` : ''}
                            ${face.gender ? `<div>ÏÑ±Î≥Ñ: ${face.gender === 'male' ? 'ÎÇ®ÏÑ±' : 'Ïó¨ÏÑ±'}</div>` : ''}
                            ${face.dominantExpression ? `<div>Ï£ºÏöî ÌëúÏ†ï: ${face.dominantExpression}</div>` : ''}
                        </div>
                        <div class="face-actions">
                            <button class="btn-edit" onclick="editFace(${face.id})">ÏàòÏ†ï</button>
                            <button class="btn-upload" onclick="uploadFaceImage(${face.id})">Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú</button>
                            <button class="btn-delete" onclick="deleteFace(${face.id})">ÏÇ≠Ï†ú</button>
                        </div>
                    `;
                    faceResults.appendChild(faceCard);
                });
            }

            async function generateFaceImages() {
                generateFaceImagesBtn.disabled = true;
                generateFaceImagesBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ÏÉùÏÑ± Ï§ë...';

                try {
                    const selectedModelKey = mainModelSelect.value;
                    const selectedSubModel = subModelSelect.value;
                    
                    // Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
                    for (let i = 0; i < detectedFaces.length; i++) {
                        const face = detectedFaces[i];
                        
                        // ÏßÑÌñâÎ•† ÏóÖÎç∞Ïù¥Ìä∏
                        const progress = ((i + 1) / detectedFaces.length) * 100;
                        faceProgressFill.style.width = `${progress}%`;
                        faceProgressText.textContent = `üé¨ ${face.name} Ïã§Ï†ú ÏòÅÏÉÅÏóêÏÑú ÏñºÍµ¥ Ï∂îÏ∂ú Ï§ë... ${Math.round(progress)}%`;
                        
                        // AI ÏÑ§Î™Ö Í∏∞Î∞ò Í≥†ÌíàÏßà Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
                        const generatedImage = await generateEnhancedFaceImage(face, selectedModelKey, selectedSubModel);
                        face.generatedImage = generatedImage;
                        
                        // UI ÏóÖÎç∞Ïù¥Ìä∏
                        updateFaceCardWithImage(face);
                        
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }

                    downloadFaceGalleryBtn.style.display = 'inline-flex';
                    faceProgressText.textContent = '‚úÖ Î™®Îì† Î∞∞Ïö∞ ÏñºÍµ¥ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÏôÑÎ£å!';
                    generateFaceImagesBtn.innerHTML = '<i class="fas fa-check"></i> ÏÉùÏÑ± ÏôÑÎ£å';
                    
                } catch (error) {
                    console.error('Face image generation error:', error);
                    faceProgressText.textContent = `‚ùå Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}`;
                    generateFaceImagesBtn.innerHTML = '<i class="fas fa-magic"></i> ÏñºÍµ¥ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±';
                } finally {
                    generateFaceImagesBtn.disabled = false;
                }
            }

            async function generateEnhancedFaceImage(face, modelKey, subModel) {
                try {
                    // 1. AI Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± API ÏãúÎèÑ (DALL-E, Stable Diffusion Îì±)
                    const aiGeneratedImage = await generateAIFaceImage(face, modelKey, subModel);
                    if (aiGeneratedImage) {
                        return aiGeneratedImage;
                    }

                    // 2. ÏòÅÏÉÅÏóêÏÑú Ïã§Ï†ú ÏñºÍµ¥ ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú ÏãúÎèÑ
                    const realFaceImage = await extractRealFaceFromVideo(face);
                    if (realFaceImage) {
                        return realFaceImage;
                    }

                    // 3. AI Î¨òÏÇ¨ Í∏∞Î∞ò Ï†ïÍµêÌïú ÏùºÎü¨Ïä§Ìä∏ ÏÉùÏÑ±
                    const descriptionPrompt = `${face.name}Ïùò Ïô∏Î™®Î•º Îß§Ïö∞ ÏÉÅÏÑ∏Ìûà Î¨òÏÇ¨Ìï¥Ï£ºÏÑ∏Ïöî. 
                    
ÎÇòÏù¥ÎåÄ, ÏÑ±Î≥Ñ, ÌîºÎ∂ÄÌÜ§, Ìó§Ïñ¥Ïä§ÌÉÄÏùº, Ìó§Ïñ¥Ïª¨Îü¨, ÏñºÍµ¥Ìòï, Îàà Î™®Ïñë, ÎààÏçπ, ÏΩî ÌòïÌÉú, ÏûÖÏà†, ÌäπÏßïÏ†ÅÏù∏ Ïô∏Î™® Îì±ÏùÑ Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú ÏÑ§Î™ÖÌï¥Ï£ºÏÑ∏Ïöî.
Ïòà: "25ÏÑ∏ Ïó¨ÏÑ±, Î∞ùÏùÄ ÌîºÎ∂ÄÌÜ§, Í∏¥ Ïõ®Ïù¥Î∏å Í∞àÏÉâ Î®∏Î¶¨, Í≥ÑÎûÄÌòï ÏñºÍµ¥, ÌÅ∞ Í∞àÏÉâ Îàà, ÎèÑÌÜ∞Ìïú ÏûÖÏà†, ÎØ∏ÏÜåÏßìÎäî ÌëúÏ†ï"`;

                    const description = await callAIAPI(modelKey, subModel, descriptionPrompt);
                    
                    // AI ÏÑ§Î™Ö Í∏∞Î∞ò ÏÇ¨Ïã§Ï†Å ÏùºÎü¨Ïä§Ìä∏ ÏÉùÏÑ±
                    return generateRealisticFaceIllustration(face, description);
                    
                } catch (error) {
                    console.error('Face image generation failed:', error);
                    // Î™®Îì† Î∞©Î≤ï Ïã§Ìå® Ïãú Í∏∞Î≥∏ Í≥†ÌíàÏßà Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
                    return generateEnhancedPlaceholderImage(face);
                }
            }

            async function generateAIFaceImage(face, modelKey, subModel) {
                try {
                    console.log(`AIÎ°ú ${face.name}Ïùò ÏñºÍµ¥ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ï§ë...`);
                    
                    // OpenAI DALL-E API ÏÇ¨Ïö© (GPT Î™®Îç∏ ÏÑ†ÌÉù Ïãú)
                    if (modelKey === 'gpt') {
                        return await generateWithDALLE(face, subModel);
                    }
                    
                    // Stable Diffusion API ÏÇ¨Ïö© (Îã§Î•∏ Î™®Îç∏Îì§)
                    return await generateWithStableDiffusion(face, modelKey, subModel);
                    
                } catch (error) {
                    console.error('AI image generation failed:', error);
                    return null;
                }
            }

            async function generateWithDALLE(face, subModel) {
                try {
                    const modelData = aiModels['gpt'];
                    if (!modelData.apiKey) {
                        throw new Error('OpenAI API ÌÇ§Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.');
                    }

                    // ÏñºÍµ¥ ÌäπÏßï ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±
                    const prompt = `Professional headshot portrait of ${face.name}, ${face.role === 'main' ? 'main character' : 'supporting character'}, ${face.description || 'attractive person'}, realistic digital art, high quality, detailed facial features, studio lighting, neutral background`;

                    const response = await fetch('https://api.openai.com/v1/images/generations', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${modelData.apiKey}`
                        },
                        body: JSON.stringify({
                            model: "dall-e-3",
                            prompt: prompt,
                            n: 1,
                            size: "1024x1024",
                            quality: "standard"
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`DALL-E API Ïò§Î•ò: ${response.statusText}`);
                    }

                    const data = await response.json();
                    if (data.data && data.data[0] && data.data[0].url) {
                        // ÏÉùÏÑ±Îêú Ïù¥ÎØ∏ÏßÄÎ•º Ï∫îÎ≤ÑÏä§Ïóê Î°úÎìúÌïòÍ≥† Î¶¨ÏÇ¨Ïù¥Ï¶à
                        return await processGeneratedImage(data.data[0].url, face);
                    }
                    
                    return null;
                    
                } catch (error) {
                    console.error('DALL-E generation failed:', error);
                    return null;
                }
            }

            async function generateWithStableDiffusion(face, modelKey, subModel) {
                try {
                    // Stable Diffusion API ÌÜµÌï©ÏùÄ Ïó¨Í∏∞Ïóê Íµ¨ÌòÑ
                    // ÌòÑÏû¨Îäî Îçî Ï†ïÍµêÌïú Canvas Í∏∞Î∞ò ÏÉùÏÑ±ÏúºÎ°ú ÎåÄÏ≤¥
                    console.log('Stable Diffusion APIÎäî ÌòÑÏû¨ Íµ¨ÌòÑ ÏòàÏ†ïÏûÖÎãàÎã§.');
                    return null;
                    
                } catch (error) {
                    console.error('Stable Diffusion generation failed:', error);
                    return null;
                }
            }

            async function processGeneratedImage(imageUrl, face) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = 300;
                        canvas.height = 400;
                        const ctx = canvas.getContext('2d');
                        
                        // Î∞∞Í≤Ω Í∑∏ÎùºÎç∞Ïù¥ÏÖò
                        const gradient = ctx.createLinearGradient(0, 0, 300, 400);
                        gradient.addColorStop(0, '#f8f9fa');
                        gradient.addColorStop(1, '#e9ecef');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 300, 400);
                        
                        // Ïù¥ÎØ∏ÏßÄÎ•º ÏõêÌòïÏúºÎ°ú ÌÅ¥Î¶¨Ìïë
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(150, 200, 120, 0, 2 * Math.PI);
                        ctx.clip();
                        
                        // AI ÏÉùÏÑ± Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞
                        const imgSize = Math.min(img.width, img.height);
                        const srcX = (img.width - imgSize) / 2;
                        const srcY = (img.height - imgSize) / 2;
                        
                        ctx.drawImage(img, srcX, srcY, imgSize, imgSize, 30, 80, 240, 240);
                        ctx.restore();
                        
                        // ÏõêÌòï ÌÖåÎëêÎ¶¨
                        ctx.strokeStyle = '#007b6d';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(150, 200, 120, 0, 2 * Math.PI);
                        ctx.stroke();
                        
                        // Ï†ïÎ≥¥ ÌÖçÏä§Ìä∏
                        ctx.fillStyle = '#2d3436';
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(face.name, 150, 50);
                        
                        ctx.font = '14px Arial';
                        ctx.fillStyle = '#636e72';
                        ctx.fillText(`${face.role === 'main' ? 'Ï£ºÏó∞' : 'Ï°∞Ïó∞'} ‚Ä¢ AI ÏÉùÏÑ±`, 150, 350);
                        ctx.fillText(`Ïã†Î¢∞ÎèÑ ${Math.round(face.confidence * 100)}% ‚Ä¢ ${face.appearances}Ìöå Îì±Ïû•`, 150, 370);
                        
                        resolve(canvas.toDataURL('image/jpeg', 0.9));
                    };
                    
                    img.onerror = () => {
                        console.error('Generated image loading failed');
                        resolve(null);
                    };
                    
                    img.src = imageUrl;
                });
            }

            function generateRealisticFaceIllustration(face, description) {
                const canvas = document.createElement('canvas');
                canvas.width = 300;
                canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // AI ÏÑ§Î™Ö ÌååÏã±
                const features = parseAIDescription(description);
                
                // Î∞∞Í≤Ω Í∑∏ÎùºÎç∞Ïù¥ÏÖò (ÏÑ±Î≥ÑÏóê Îî∞Îùº ÏÉâÏÉÅ Ï°∞Ï†ï)
                const colorScheme = features.gender === 'female' 
                    ? ['#ffeaa7', '#fab1a0', '#e17055'] 
                    : ['#74b9ff', '#0984e3', '#6c5ce7'];
                
                const gradient = ctx.createRadialGradient(150, 200, 50, 150, 200, 200);
                gradient.addColorStop(0, colorScheme[0]);
                gradient.addColorStop(0.7, colorScheme[1]);
                gradient.addColorStop(1, colorScheme[2]);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 300, 400);
                
                // ÏñºÍµ¥ Î≤†Ïù¥Ïä§ (ÌîºÎ∂ÄÌÜ§ Î∞òÏòÅ)
                const skinColors = {
                    light: '#ffeaa7',
                    medium: '#fab1a0',
                    dark: '#e17055',
                    default: '#ffeaa7'
                };
                const skinColor = skinColors[features.skinTone] || skinColors.default;
                
                ctx.beginPath();
                if (features.faceShape === 'round') {
                    ctx.arc(150, 180, 85, 0, 2 * Math.PI);
                } else if (features.faceShape === 'square') {
                    ctx.roundRect(80, 110, 140, 150, 20);
                } else { // oval or default
                    ctx.ellipse(150, 180, 75, 95, 0, 0, 2 * Math.PI);
                }
                ctx.fillStyle = skinColor;
                ctx.fill();
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Ìó§Ïñ¥Ïä§ÌÉÄÏùº Í∑∏Î¶¨Í∏∞
                drawHair(ctx, features);
                
                // Îàà Í∑∏Î¶¨Í∏∞ (ÌÅ¨Í∏∞ÏôÄ Î™®Ïñë Î∞òÏòÅ)
                drawEyes(ctx, features);
                
                // ÎààÏçπ Í∑∏Î¶¨Í∏∞
                drawEyebrows(ctx, features);
                
                // ÏΩî Í∑∏Î¶¨Í∏∞
                drawNose(ctx, features);
                
                // ÏûÖÏà† Í∑∏Î¶¨Í∏∞
                drawLips(ctx, features);
                
                // ÌëúÏ†ï Î∞òÏòÅ (ÎØ∏ÏÜå, ÏßÑÏßÄÌï® Îì±)
                if (features.expression === 'smile') {
                    // ÏõÉÎäî ÏûÖ Î™®ÏñëÏúºÎ°ú ÏàòÏ†ï
                    ctx.beginPath();
                    ctx.arc(150, 205, 12, 0, Math.PI);
                    ctx.strokeStyle = '#e17055';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥
                ctx.fillStyle = 'white';
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeText(face.name, 150, 320);
                ctx.fillText(face.name, 150, 320);
                
                ctx.font = '16px Arial';
                ctx.fillText(`${face.role === 'main' ? 'Ï£ºÏó∞' : 'Ï°∞Ïó∞'} ‚Ä¢ AI ÏùºÎü¨Ïä§Ìä∏`, 150, 345);
                
                ctx.font = '14px Arial';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(`${features.age || '??'}ÏÑ∏ ${features.gender || '??'} ‚Ä¢ Ïã†Î¢∞ÎèÑ ${Math.round(face.confidence * 100)}%`, 150, 365);
                ctx.fillText(`Îì±Ïû• ${face.appearances}Ìöå ‚Ä¢ ${face.firstAppearance}`, 150, 385);
                
                return canvas.toDataURL('image/png');
            }

            function parseAIDescription(description) {
                const features = {
                    age: null,
                    gender: null,
                    skinTone: 'light',
                    hairStyle: 'short',
                    hairColor: 'black',
                    faceShape: 'oval',
                    eyeSize: 'medium',
                    eyeColor: 'brown',
                    expression: 'neutral'
                };
                
                if (!description) return features;
                
                const desc = description.toLowerCase();
                
                // ÎÇòÏù¥ Ï∂îÏ∂ú
                const ageMatch = desc.match(/(\d+)ÏÑ∏|(\d+)ÎåÄ/);
                if (ageMatch) {
                    features.age = ageMatch[1] || (ageMatch[2] ? parseInt(ageMatch[2]) * 10 + 5 : null);
                }
                
                // ÏÑ±Î≥Ñ Ï∂îÏ∂ú
                if (desc.includes('ÎÇ®ÏÑ±') || desc.includes('ÎÇ®Ïûê')) features.gender = 'male';
                if (desc.includes('Ïó¨ÏÑ±') || desc.includes('Ïó¨Ïûê')) features.gender = 'female';
                
                // ÌîºÎ∂ÄÌÜ§
                if (desc.includes('Î∞ùÏùÄ') || desc.includes('ÌïòÏñÄ')) features.skinTone = 'light';
                if (desc.includes('Ïñ¥ÎëêÏö¥') || desc.includes('Í≤ÄÏùÄ')) features.skinTone = 'dark';
                if (desc.includes('Ï§ëÍ∞Ñ') || desc.includes('Î≥¥ÌÜµ')) features.skinTone = 'medium';
                
                // Ìó§Ïñ¥Ïä§ÌÉÄÏùº
                if (desc.includes('Í∏¥')) features.hairStyle = 'long';
                if (desc.includes('ÏßßÏùÄ')) features.hairStyle = 'short';
                if (desc.includes('Ïõ®Ïù¥Î∏å') || desc.includes('Í≥±Ïä¨')) features.hairStyle = 'wavy';
                
                // Ìó§Ïñ¥Ïª¨Îü¨
                if (desc.includes('Í∞àÏÉâ')) features.hairColor = 'brown';
                if (desc.includes('Í∏àÏÉâ') || desc.includes('Î∏îÎ°†Îìú')) features.hairColor = 'blonde';
                if (desc.includes('Îπ®Í∞Ñ') || desc.includes('Îπ®Í∞ï')) features.hairColor = 'red';
                
                // ÏñºÍµ¥Ìòï
                if (desc.includes('Îë•Í∑º') || desc.includes('ÏõêÌòï')) features.faceShape = 'round';
                if (desc.includes('Í∞ÅÏßÑ') || desc.includes('ÏÇ¨Í∞Å')) features.faceShape = 'square';
                
                // Îàà ÌÅ¨Í∏∞
                if (desc.includes('ÌÅ∞ Îàà') || desc.includes('Ïª§Îã§ÎûÄ Îàà')) features.eyeSize = 'large';
                if (desc.includes('ÏûëÏùÄ Îàà')) features.eyeSize = 'small';
                
                // ÌëúÏ†ï
                if (desc.includes('ÎØ∏ÏÜå') || desc.includes('ÏõÉ')) features.expression = 'smile';
                if (desc.includes('ÏßÑÏßÄ') || desc.includes('Ïã¨Í∞Å')) features.expression = 'serious';
                
                return features;
            }

            function drawHair(ctx, features) {
                const hairColors = {
                    black: '#2d3436',
                    brown: '#6c5ce7',
                    blonde: '#fdcb6e',
                    red: '#e17055'
                };
                
                ctx.fillStyle = hairColors[features.hairColor] || hairColors.black;
                
                if (features.hairStyle === 'long') {
                    // Í∏¥ Î®∏Î¶¨
                    ctx.beginPath();
                    ctx.ellipse(150, 120, 90, 40, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Î®∏Î¶¨Ïπ¥ÎùΩ ÏòÜÎ©¥
                    ctx.beginPath();
                    ctx.ellipse(100, 160, 25, 60, -0.3, 0, 2 * Math.PI);
                    ctx.ellipse(200, 160, 25, 60, 0.3, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    // ÏßßÏùÄ Î®∏Î¶¨
                    ctx.beginPath();
                    ctx.ellipse(150, 130, 80, 50, 0, 0, Math.PI);
                    ctx.fill();
                }
            }

            function drawEyes(ctx, features) {
                const eyeSize = features.eyeSize === 'large' ? 12 : features.eyeSize === 'small' ? 6 : 9;
                
                // Îàà Ìù∞Ïûê
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.ellipse(130, 160, eyeSize, eyeSize * 0.7, 0, 0, 2 * Math.PI);
                ctx.ellipse(170, 160, eyeSize, eyeSize * 0.7, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // ÎààÎèôÏûê
                const eyeColors = {
                    brown: '#8b4513',
                    blue: '#4169e1',
                    green: '#228b22',
                    black: '#000000'
                };
                ctx.fillStyle = eyeColors[features.eyeColor] || eyeColors.brown;
                ctx.beginPath();
                ctx.ellipse(130, 160, eyeSize * 0.6, eyeSize * 0.6, 0, 0, 2 * Math.PI);
                ctx.ellipse(170, 160, eyeSize * 0.6, eyeSize * 0.6, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // ÎààÎèôÏûê ÌïòÏù¥ÎùºÏù¥Ìä∏
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.ellipse(132, 158, 2, 2, 0, 0, 2 * Math.PI);
                ctx.ellipse(172, 158, 2, 2, 0, 0, 2 * Math.PI);
                ctx.fill();
            }

            function drawEyebrows(ctx, features) {
                ctx.strokeStyle = '#2d3436';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                // ÏôºÏ™Ω ÎààÏçπ
                ctx.beginPath();
                ctx.moveTo(115, 145);
                ctx.quadraticCurveTo(130, 140, 145, 145);
                ctx.stroke();
                
                // Ïò§Î•∏Ï™Ω ÎààÏçπ
                ctx.beginPath();
                ctx.moveTo(155, 145);
                ctx.quadraticCurveTo(170, 140, 185, 145);
                ctx.stroke();
            }

            function drawNose(ctx, features) {
                ctx.strokeStyle = '#fab1a0';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(150, 170);
                ctx.lineTo(145, 185);
                ctx.moveTo(150, 185);
                ctx.lineTo(155, 185);
                ctx.stroke();
            }

            function drawLips(ctx, features) {
                ctx.fillStyle = '#e17055';
                
                if (features.expression === 'smile') {
                    // ÏõÉÎäî ÏûÖ
                    ctx.beginPath();
                    ctx.arc(150, 200, 15, 0, Math.PI);
                    ctx.fill();
                } else {
                    // ÏùºÎ∞ò ÏûÖ
                    ctx.beginPath();
                    ctx.ellipse(150, 200, 12, 6, 0, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            async function extractRealFaceFromVideo(face) {
                try {
                    console.log(`${face.name}Ïùò Ïã§Ï†ú ÏñºÍµ¥ Ï∂îÏ∂ú Ï§ë...`);
                    
                    // ÏòÅÏÉÅÏóêÏÑú Ìï¥Îãπ ÏãúÍ∞ÑÎåÄÏùò ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú
                    const frameImage = await captureVideoFrame(face.firstAppearance);
                    if (!frameImage) {
                        return null;
                    }

                    // ÌîÑÎ†àÏûÑÏóêÏÑú ÏñºÍµ¥ ÏòÅÏó≠ Í∞êÏßÄ Î∞è Ï∂îÏ∂ú
                    const faceImage = await detectAndCropFace(frameImage, face);
                    
                    return faceImage;
                    
                } catch (error) {
                    console.error('Real face extraction failed:', error);
                    return null;
                }
            }

            async function captureVideoFrame(timeString) {
                return new Promise((resolve) => {
                    try {
                        // ÏãúÍ∞Ñ Î¨∏ÏûêÏó¥ÏùÑ Ï¥àÎ°ú Î≥ÄÌôò (00:02:15 -> 135Ï¥à)
                        const timeParts = timeString.split(':');
                        const timeInSeconds = parseInt(timeParts[0]) * 3600 + 
                                            parseInt(timeParts[1]) * 60 + 
                                            parseInt(timeParts[2]);

                        // ÎπÑÎîîÏò§ ÏöîÏÜå ÏÉùÏÑ±
                        const video = document.createElement('video');
                        video.src = URL.createObjectURL(uploadedFile);
                        video.crossOrigin = 'anonymous';
                        video.muted = true;

                        video.addEventListener('loadedmetadata', () => {
                            // ÏßÄÏ†ïÎêú ÏãúÍ∞ÑÏúºÎ°ú Ïù¥Îèô
                            video.currentTime = Math.min(timeInSeconds, video.duration - 1);
                        });

                        video.addEventListener('seeked', () => {
                            try {
                                // Ï∫îÎ≤ÑÏä§Ïóê ÌòÑÏû¨ ÌîÑÎ†àÏûÑ Í∑∏Î¶¨Í∏∞
                                const canvas = document.createElement('canvas');
                                canvas.width = video.videoWidth;
                                canvas.height = video.videoHeight;
                                const ctx = canvas.getContext('2d');
                                
                                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                                
                                // Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Î∞òÌôò
                                const imageData = canvas.toDataURL('image/jpeg', 0.8);
                                
                                // Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
                                URL.revokeObjectURL(video.src);
                                
                                resolve(imageData);
                                
                            } catch (error) {
                                console.error('Frame capture error:', error);
                                resolve(null);
                            }
                        });

                        video.addEventListener('error', () => {
                            console.error('Video loading error');
                            resolve(null);
                        });

                    } catch (error) {
                        console.error('Video frame capture failed:', error);
                        resolve(null);
                    }
                });
            }

            async function detectAndCropFace(frameImage, face) {
                try {
                    // ÌîÑÎ†àÏûÑ Ïù¥ÎØ∏ÏßÄÎ•º Ï∫îÎ≤ÑÏä§Ïóê Î°úÎìú
                    const img = new Image();
                    img.src = frameImage;
                    
                    return new Promise((resolve) => {
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄ ÌÅ¨Í∏∞
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            
                            // Îã§Ï§ë ÏñºÍµ¥ ÏòÅÏó≠ Ï∂îÏ†ï (Ïó¨Îü¨ ÏúÑÏπòÏóêÏÑú ÏãúÎèÑ)
                            const faceRegions = [
                                // Ï§ëÏïô ÏÉÅÎã® (Ï£ºÏù∏Í≥µ ÏúÑÏπò)
                                { 
                                    x: img.width * 0.35, 
                                    y: img.height * 0.1, 
                                    width: img.width * 0.3, 
                                    height: img.height * 0.4 
                                },
                                // Ï¢åÏ∏° ÏÉÅÎã®
                                { 
                                    x: img.width * 0.1, 
                                    y: img.height * 0.1, 
                                    width: img.width * 0.25, 
                                    height: img.height * 0.35 
                                },
                                // Ïö∞Ï∏° ÏÉÅÎã®
                                { 
                                    x: img.width * 0.65, 
                                    y: img.height * 0.1, 
                                    width: img.width * 0.25, 
                                    height: img.height * 0.35 
                                },
                                // Ï§ëÏïô Ï§ëÍ∞Ñ
                                { 
                                    x: img.width * 0.3, 
                                    y: img.height * 0.25, 
                                    width: img.width * 0.4, 
                                    height: img.height * 0.4 
                                }
                            ];

                            // Ïó≠Ìï†Ïóê Îî∞Îùº Ïö∞ÏÑ†ÏàúÏúÑ Í≤∞Ï†ï
                            const selectedRegion = face.role === 'main' ? faceRegions[0] : faceRegions[Math.floor(Math.random() * faceRegions.length)];
                            
                            const faceWidth = Math.min(300, selectedRegion.width);
                            const faceHeight = Math.min(400, selectedRegion.height);
                            const faceX = selectedRegion.x;
                            const faceY = selectedRegion.y;
                            
                            // ÏñºÍµ¥ ÏòÅÏó≠ Ï∂îÏ∂ú
                            const faceCanvas = document.createElement('canvas');
                            faceCanvas.width = 300;
                            faceCanvas.height = 400;
                            const faceCtx = faceCanvas.getContext('2d');
                            
                            // Î∞∞Í≤Ω Í∑∏ÎùºÎç∞Ïù¥ÏÖò
                            const gradient = faceCtx.createLinearGradient(0, 0, 300, 400);
                            gradient.addColorStop(0, '#f8f9fa');
                            gradient.addColorStop(1, '#e9ecef');
                            faceCtx.fillStyle = gradient;
                            faceCtx.fillRect(0, 0, 300, 400);
                            
                            // Ï∂îÏ∂úÎêú ÏñºÍµ¥ ÏòÅÏó≠ÏùÑ Ï§ëÏïôÏóê Î∞∞Ïπò (Îë•Í∑º Î™®ÏÑúÎ¶¨ Ìö®Í≥º)
                            faceCtx.save();
                            
                            // Îë•Í∑º ÏÇ¨Í∞ÅÌòï ÌÅ¥Î¶¨Ìïë Í≤ΩÎ°ú ÏÉùÏÑ±
                            const cornerRadius = 15;
                            faceCtx.beginPath();
                            drawRoundedRect(faceCtx, 25, 50, 250, 300, cornerRadius);
                            faceCtx.clip();
                            
                            // ÏñºÍµ¥ Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞
                            faceCtx.drawImage(
                                canvas, 
                                faceX, faceY, faceWidth, faceHeight,
                                25, 50, 250, 300
                            );
                            
                            faceCtx.restore();
                            
                            // Îë•Í∑º ÌÖåÎëêÎ¶¨ Ï∂îÍ∞Ä
                            faceCtx.strokeStyle = '#007b6d';
                            faceCtx.lineWidth = 3;
                            faceCtx.beginPath();
                            drawRoundedRect(faceCtx, 25, 50, 250, 300, cornerRadius);
                            faceCtx.stroke();
                            
                            // Í∑∏Î¶ºÏûê Ìö®Í≥º
                            faceCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                            faceCtx.shadowBlur = 10;
                            faceCtx.shadowOffsetX = 2;
                            faceCtx.shadowOffsetY = 2;
                            
                            // Ï†ïÎ≥¥ ÌÖçÏä§Ìä∏ Ï∂îÍ∞Ä
                            faceCtx.fillStyle = '#2d3436';
                            faceCtx.font = 'bold 18px Arial';
                            faceCtx.textAlign = 'center';
                            faceCtx.fillText(face.name, 150, 30);
                            
                            faceCtx.font = '14px Arial';
                            faceCtx.fillStyle = '#636e72';
                            faceCtx.fillText(`${face.role === 'main' ? 'Ï£ºÏó∞' : 'Ï°∞Ïó∞'} ‚Ä¢ Ïã†Î¢∞ÎèÑ ${Math.round(face.confidence * 100)}%`, 150, 380);
                            faceCtx.fillText(`Îì±Ïû• ${face.appearances}Ìöå ‚Ä¢ ${face.firstAppearance}`, 150, 395);
                            
                            resolve(faceCanvas.toDataURL('image/jpeg', 0.9));
                        };
                        
                        img.onerror = () => {
                            console.error('Image loading failed');
                            resolve(null);
                        };
                    });
                    
                } catch (error) {
                    console.error('Face detection and crop failed:', error);
                    return null;
                }
            }



            function generateDetailedPlaceholderImage(face, description) {
                const canvas = document.createElement('canvas');
                canvas.width = 300;
                canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // ÏÇ¨Ïã§Ï†ÅÏù∏ Í∑∏ÎùºÎç∞Ïù¥ÏÖò Î∞∞Í≤Ω
                const gradient = ctx.createRadialGradient(150, 200, 50, 150, 200, 200);
                gradient.addColorStop(0, '#f8f9fa');
                gradient.addColorStop(0.7, '#e9ecef');
                gradient.addColorStop(1, '#dee2e6');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 300, 400);
                
                // ÏñºÍµ¥ ÏòÅÏó≠ ÌëúÏãú
                ctx.beginPath();
                ctx.ellipse(150, 180, 80, 100, 0, 0, 2 * Math.PI);
                ctx.fillStyle = '#ffeaa7';
                ctx.fill();
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Îàà Í∑∏Î¶¨Í∏∞
                ctx.beginPath();
                ctx.ellipse(130, 160, 8, 6, 0, 0, 2 * Math.PI);
                ctx.ellipse(170, 160, 8, 6, 0, 0, 2 * Math.PI);
                ctx.fillStyle = '#2d3436';
                ctx.fill();
                
                // ÏΩî Í∑∏Î¶¨Í∏∞
                ctx.beginPath();
                ctx.moveTo(150, 170);
                ctx.lineTo(145, 185);
                ctx.lineTo(155, 185);
                ctx.closePath();
                ctx.fillStyle = '#fab1a0';
                ctx.fill();
                
                // ÏûÖ Í∑∏Î¶¨Í∏∞
                ctx.beginPath();
                ctx.ellipse(150, 200, 15, 8, 0, 0, Math.PI);
                ctx.fillStyle = '#e17055';
                ctx.fill();
                
                // ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥
                ctx.fillStyle = '#2d3436';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(face.name, 150, 320);
                
                ctx.font = '14px Arial';
                ctx.fillStyle = '#636e72';
                ctx.fillText(`${face.role === 'main' ? 'Ï£ºÏó∞' : 'Ï°∞Ïó∞'} ‚Ä¢ Ïã†Î¢∞ÎèÑ ${Math.round(face.confidence * 100)}%`, 150, 340);
                ctx.fillText(`Îì±Ïû• ${face.appearances}Ìöå ‚Ä¢ Ï≤´ Îì±Ïû• ${face.firstAppearance}`, 150, 360);
                
                // AI ÏÑ§Î™Ö Ï∂îÍ∞Ä (ÏöîÏïΩ)
                if (description && description.length > 0) {
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#74b9ff';
                    const shortDesc = description.substring(0, 50) + '...';
                    ctx.fillText('AI Î∂ÑÏÑù: ' + shortDesc, 150, 380);
                }
                
                return canvas.toDataURL('image/png');
            }

            function generateEnhancedPlaceholderImage(face) {
                const canvas = document.createElement('canvas');
                canvas.width = 300;
                canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // Ïó≠Ìï†Ïóê Îî∞Î•∏ ÏÉâÏÉÅ ÌÖåÎßà
                const colorTheme = face.role === 'main' 
                    ? { primary: '#667eea', secondary: '#764ba2', accent: '#f093fb' }
                    : { primary: '#4ecdc4', secondary: '#44a08d', accent: '#96fbc4' };
                
                // Î∞∞Í≤Ω Í∑∏ÎùºÎç∞Ïù¥ÏÖò
                const gradient = ctx.createLinearGradient(0, 0, 300, 400);
                gradient.addColorStop(0, colorTheme.primary);
                gradient.addColorStop(0.5, colorTheme.secondary);
                gradient.addColorStop(1, colorTheme.accent);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 300, 400);
                
                // Ïò§Î≤ÑÎ†àÏù¥ Ìå®ÌÑ¥
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    ctx.arc(Math.random() * 300, Math.random() * 400, Math.random() * 30, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Ï§ëÏïô ÏïÑÏù¥ÏΩò
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = '60px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üé≠', 150, 180);
                
                // Ïù¥Î¶Ñ
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeText(face.name, 150, 250);
                ctx.fillText(face.name, 150, 250);
                
                // Ïó≠Ìï† Ï†ïÎ≥¥
                ctx.font = '16px Arial';
                ctx.fillText(`${face.role === 'main' ? 'Ï£ºÏó∞ Î∞∞Ïö∞' : 'Ï°∞Ïó∞ Î∞∞Ïö∞'}`, 150, 280);
                
                // ÏÉÅÏÑ∏ Ï†ïÎ≥¥
                ctx.font = '14px Arial';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(`Ïã†Î¢∞ÎèÑ: ${Math.round(face.confidence * 100)}%`, 150, 310);
                ctx.fillText(`Îì±Ïû• ÌöüÏàò: ${face.appearances}Ìöå`, 150, 330);
                ctx.fillText(`Ï≤´ Îì±Ïû•: ${face.firstAppearance}`, 150, 350);
                
                // AI ÏÉùÏÑ± ÌëúÏãú
                ctx.font = '12px Arial';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillText('AI Î∂ÑÏÑù Í≤∞Í≥º', 150, 380);
                
                return canvas.toDataURL('image/png');
            }

            function updateFaceCardWithImage(face) {
                const faceCards = faceResults.querySelectorAll('.face-card');
                const targetCard = Array.from(faceCards).find(card => 
                    card.querySelector('h4').textContent === face.name
                );
                
                if (targetCard) {
                    const placeholder = targetCard.querySelector('.face-placeholder');
                    placeholder.innerHTML = `<img src="${face.generatedImage}" alt="${face.name}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">`;
                    placeholder.style.background = 'none';
                }
            }

            function downloadFaceGallery() {
                const zip = new JSZip();
                const promises = [];

                detectedFaces.forEach(face => {
                    if (face.generatedImage) {
                        // Base64 Ïù¥ÎØ∏ÏßÄÎ•º blobÏúºÎ°ú Î≥ÄÌôò
                        const base64Data = face.generatedImage.split(',')[1];
                        const byteCharacters = atob(base64Data);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const blob = new Blob([byteArray], { type: 'image/png' });
                        
                        zip.file(`${face.name}_${face.role}.png`, blob);
                    }
                });

                // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÌååÏùº Ï∂îÍ∞Ä
                const metadata = {
                    analysisDate: new Date().toISOString(),
                    totalFaces: detectedFaces.length,
                    faces: detectedFaces.map(face => ({
                        name: face.name,
                        role: face.role,
                        confidence: face.confidence,
                        appearances: face.appearances,
                        firstAppearance: face.firstAppearance
                    }))
                };
                
                zip.file('face_analysis_metadata.json', JSON.stringify(metadata, null, 2));

                zip.generateAsync({ type: 'blob' }).then(content => {
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `face_gallery_${new Date().toISOString().split('T')[0]}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
            }

            // Global functions for face card actions
            window.editFace = function(faceId) {
                const face = detectedFaces.find(f => f.id === faceId);
                if (face) {
                    const newName = prompt('Î∞∞Ïö∞ Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:', face.name);
                    if (newName && newName.trim()) {
                        face.name = newName.trim();
                        displayDetectedFaces();
                        
                        // Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏÉùÏÑ±ÎêòÏñ¥ ÏûàÎã§Î©¥ Îã§Ïãú ÌëúÏãú
                        if (face.generatedImage) {
                            updateFaceCardWithImage(face);
                        }
                    }
                }
            };

            window.uploadFaceImage = function(faceId) {
                const face = detectedFaces.find(f => f.id === faceId);
                if (!face) return;

                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.style.display = 'none';
                
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            // ÏóÖÎ°úÎìúÎêú Ïù¥ÎØ∏ÏßÄÎ•º ÌîÑÎ°úÏÑ∏Ïã±
                            processUploadedFaceImage(event.target.result, face);
                        };
                        reader.readAsDataURL(file);
                    }
                    document.body.removeChild(fileInput);
                });
                
                document.body.appendChild(fileInput);
                fileInput.click();
            };

            function processUploadedFaceImage(imageDataUrl, face) {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 300;
                    canvas.height = 400;
                    const ctx = canvas.getContext('2d');
                    
                    // Î∞∞Í≤Ω Í∑∏ÎùºÎç∞Ïù¥ÏÖò
                    const gradient = ctx.createLinearGradient(0, 0, 300, 400);
                    gradient.addColorStop(0, '#f8f9fa');
                    gradient.addColorStop(1, '#e9ecef');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 300, 400);
                    
                    // Ïù¥ÎØ∏ÏßÄÎ•º ÏõêÌòïÏúºÎ°ú ÌÅ¥Î¶¨Ìïë
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(150, 200, 120, 0, 2 * Math.PI);
                    ctx.clip();
                    
                    // ÏóÖÎ°úÎìúÎêú Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞ (ÎπÑÏú® Ïú†ÏßÄÌïòÎ©∞ Ï§ëÏïôÏóê Î∞∞Ïπò)
                    const imgSize = Math.min(img.width, img.height);
                    const srcX = (img.width - imgSize) / 2;
                    const srcY = (img.height - imgSize) / 2;
                    
                    ctx.drawImage(img, srcX, srcY, imgSize, imgSize, 30, 80, 240, 240);
                    ctx.restore();
                    
                    // ÏõêÌòï ÌÖåÎëêÎ¶¨
                    ctx.strokeStyle = '#17a2b8';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(150, 200, 120, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    // Ï†ïÎ≥¥ ÌÖçÏä§Ìä∏
                    ctx.fillStyle = '#2d3436';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(face.name, 150, 50);
                    
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#636e72';
                    ctx.fillText(`${face.role === 'main' ? 'Ï£ºÏó∞' : 'Ï°∞Ïó∞'} ‚Ä¢ ÏÇ¨Ïö©Ïûê ÏóÖÎ°úÎìú`, 150, 350);
                    ctx.fillText(`Ïã†Î¢∞ÎèÑ ${Math.round(face.confidence * 100)}% ‚Ä¢ ${face.appearances}Ìöå Îì±Ïû•`, 150, 370);
                    
                    // ÏóÖÎ°úÎìú ÏôÑÎ£å Î©îÏãúÏßÄ
                    addMessage('ai', `‚úÖ ${face.name}Ïùò ÏñºÍµ¥ Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÖÎ°úÎìúÎêòÏóàÏäµÎãàÎã§!`);
                    
                    // Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• Î∞è ÌëúÏãú
                    face.generatedImage = canvas.toDataURL('image/jpeg', 0.9);
                    updateFaceCardWithImage(face);
                };
                img.src = imageDataUrl;
            }

            window.deleteFace = function(faceId) {
                if (confirm('Ïù¥ Î∞∞Ïö∞Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                    detectedFaces = detectedFaces.filter(f => f.id !== faceId);
                    displayDetectedFaces();
                    
                    // Ïù¥ÎØ∏ÏßÄÎì§ Îã§Ïãú ÌëúÏãú
                    detectedFaces.forEach(face => {
                        if (face.generatedImage) {
                            updateFaceCardWithImage(face);
                        }
                    });
                }
            };

            // ÏûêÎèô Ïã§Ìñâ ÏÑ§Ï†ï Ï†ÄÏû• Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
            autoFaceAnalysis.addEventListener('change', () => {
                localStorage.setItem('autoFaceAnalysis', autoFaceAnalysis.checked);
                
                // ÏÑ§Ï†ï Î≥ÄÍ≤Ω ÏïåÎ¶º
                if (autoFaceAnalysis.checked) {
                    addMessage('ai', '‚ö° ÏûêÎèô Ïã§ÌñâÏù¥ ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§! Îã§Ïùå ÏòÅÏÉÅ ÏóÖÎ°úÎìúÏãú ÏûêÎèôÏúºÎ°ú Î∞∞Ïö∞ Î∂ÑÏÑùÏù¥ ÏãúÏûëÎê©ÎãàÎã§.');
                } else {
                    addMessage('ai', '‚öôÔ∏è ÏûêÎèô Ïã§ÌñâÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§. ÏàòÎèôÏúºÎ°ú "ÏñºÍµ¥ Î∂ÑÏÑù ÏãúÏûë" Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠Ìï¥Ï£ºÏÑ∏Ïöî.');
                }
            });

            // --- Initial Setup ---
            loadSavedApiKeys();
            loadStorageSettings();
            loadChats();
            renderCompletedShorts();
            initializeMainModels();
            updateSubModels();
            updateProcessButtonState();
        });
    </script>
</body>
</html>