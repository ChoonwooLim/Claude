<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìˆì¸  ìë™í™” í”„ë¡œê·¸ë¨ - UI</title>
    <link rel="stylesheet" href="css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Face-api.js for real face detection -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
</head>
<body>
    <div class="main-layout">
        <!-- ì™¼ìª½ íŒ¨ë„: ì„¤ì • ë° ì»¨íŠ¸ë¡¤ -->
        <div class="left-panel">
            <div class="header">
                <img src="image/TwinverseLogo.png" alt="Twinverse Logo" class="header-logo">
                <div class="title-box">
                    <h1>ğŸ¬ ìˆì¸  ìë™í™” í”„ë¡œê·¸ë¨</h1>
                </div>
                <div class="header-actions">
                    <button id="loadNewVideoButton" class="upload-btn">ìƒˆ ì˜ìƒ ë¶ˆëŸ¬ì˜¤ê¸° ğŸ“‚</button>
                    <button id="theme-toggle">ğŸŒ™</button>
                </div>
            </div>

            <!-- íŒŒì¼ ì—…ë¡œë“œ ì„¹ì…˜ -->
            <div class="upload-section" id="uploadContainer">
                <div class="upload-icon">ğŸ“</div>
                <h3>ì˜ìƒ íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì—…ë¡œë“œ</h3>
                <p>MP4, AVI, MOV íŒŒì¼ ì§€ì›</p>
                <input type="file" id="file-input" class="file-input" accept="video/*">
                <div class="file-info" id="fileInfo">
                    <p id="fileName"></p>
                    <p id="fileSize"></p>
                </div>
            </div>

            <!-- ì›ë³¸ ì˜ìƒ ë¯¸ë¦¬ë³´ê¸° (ì—…ë¡œë“œ í›„ í‘œì‹œ) -->
            <div class="video-preview-section" id="videoPreviewSection">
                <h3>ğŸ“¹&nbsp;ì›ë³¸ ì˜ìƒ ë¯¸ë¦¬ë³´ê¸°</h3>
                <div class="video-container" id="originalVideoContainer">
                    <div class="video-placeholder">
                        ì˜ìƒì„ ì—…ë¡œë“œí•˜ë©´ ì—¬ê¸°ì—ì„œ ë¯¸ë¦¬ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤
                    </div>
                </div>
                <div class="video-controls">
                    <button class="control-btn" id="playBtn" disabled>â–¶ï¸ ì¬ìƒ</button>
                    <button class="control-btn" id="pauseBtn" disabled>â¸ï¸ ì¼ì‹œì •ì§€</button>
                    <button class="control-btn" id="rewindBtn" disabled>âª ë˜ê°ê¸°</button>
                </div>
            </div>
            
            <!-- ì²˜ë¦¬ ì˜µì…˜ ì„¹ì…˜ -->
            <div id="videoEditorContainer" style="display: none;">
                <video id="videoPreview" controls></video>
            </div>

            <div class="options-section">
                <div class="option-group">
                    <h3>ğŸ“¼ ì˜ìƒ ì²˜ë¦¬</h3>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="autoHighlight" name="video_processing" value="highlight" checked>
                            <label for="autoHighlight">ìë™ í•˜ì´ë¼ì´íŠ¸ ì¶”ì¶œ</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="autoCrop" name="video_processing" value="crop" checked>
                            <label for="autoCrop">ìë™ í¬ë¡­</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="colorCorrection" name="video_processing" value="color" checked>
                            <label for="colorCorrection">ìƒ‰ìƒ ë³´ì •</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="videoStabilization" name="video_processing" value="stabilize">
                            <label for="videoStabilization">ì˜ìƒ ì•ˆì •í™”</label>
                        </div>
                    </div>
                </div>

                <div class="option-group">
                    <h3>ğŸ”Š ì˜¤ë””ì˜¤ ì²˜ë¦¬</h3>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="removeSilence" name="audio_processing" value="silence" checked>
                            <label for="removeSilence">ë¬´ìŒ êµ¬ê°„ ì œê±°</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="enhanceAudio" name="audio_processing" value="enhance" checked>
                            <label for="enhanceAudio">ì˜¤ë””ì˜¤ í–¥ìƒ</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="noiseReduction" name="audio_processing" value="noise" checked>
                            <label for="noiseReduction">ë…¸ì´ì¦ˆ ê°ì†Œ</label>
                        </div>
                    </div>
                </div>

                <div class="option-group">
                    <h3>ğŸ“&nbsp;ì¶”ê°€ ê¸°ëŠ¥</h3>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="addTitle" name="features" value="title">
                            <label for="addTitle">íƒ€ì´í‹€ ì¶”ê°€</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="addSubtitles" name="features" value="subtitles">
                            <label for="addSubtitles">ìë§‰ ì¶”ê°€</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="addEffects" name="features" value="effects">
                            <label for="addEffects">ì˜ìƒíš¨ê³¼ ì¶”ê°€</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="faceAnalysis" name="features" value="face_analysis">
                            <label for="faceAnalysis">ğŸ­ ë°°ìš° ì–¼êµ´ ë¶„ì„ ë° ê°¤ëŸ¬ë¦¬ ìƒì„±</label>
                        </div>
                    </div>
                </div>

                <div class="option-group">
                    <h3>âš™ï¸&nbsp;ìˆì¸  ìƒì„± ì„¤ì •</h3>
                    <div class="setting-item">
                        <label for="shortsLength">ì˜ìƒ ê¸¸ì´</label>
                        <select id="shortsLength" class="setting-input">
                            <option value="15">15ì´ˆ</option>
                            <option value="30">30ì´ˆ</option>
                            <option value="45">45ì´ˆ</option>
                            <option value="60" selected>60ì´ˆ</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label for="shortsCount">ìƒì„± ê°œìˆ˜</label>
                        <input type="number" id="shortsCount" class="setting-input" value="1" min="1" max="10">
                    </div>
                </div>

                <div class="option-group">
                    <h3>ğŸ“&nbsp;ì €ì¥ ê´€ë¦¬</h3>
                    <div class="setting-item">
                        <label for="outputFolder">ì €ì¥ í´ë”</label>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <input type="text" id="outputFolder" class="setting-input" placeholder="í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”" readonly style="flex: 1;">
                            <button id="selectFolderBtn" class="control-btn" style="padding: 0.5rem;">ğŸ“</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label for="autoSave">ìë™ ì €ì¥</label>
                        <input type="checkbox" id="autoSave" checked>
                    </div>
                    <div class="setting-item">
                        <label for="fileNaming">íŒŒì¼ëª… í˜•ì‹</label>
                        <select id="fileNaming" class="setting-input">
                            <option value="timestamp">íƒ€ì„ìŠ¤íƒ¬í”„ (20241220_143022)</option>
                            <option value="sequential">ìˆœì°¨ë²ˆí˜¸ (shorts_001, shorts_002)</option>
                            <option value="custom">ì‚¬ìš©ì ì •ì˜</option>
                        </select>
                    </div>
                    <div class="setting-item" id="customNameContainer" style="display: none;">
                        <label for="customName">ì‚¬ìš©ì ì •ì˜ëª…</label>
                        <input type="text" id="customName" class="setting-input" placeholder="ì˜ˆ: MyShorts">
                    </div>
                </div>
            </div>

            <div class="chat-area">
                <div class="chat-list-panel">
                    <div class="chat-list-header">
                        <h3>ëŒ€í™” ëª©ë¡</h3>
                        <input type="checkbox" id="selectAllChats" title="ì „ì²´ ì„ íƒ">
                    </div>
                    <div class="chat-list" id="chatList">
                        <!-- Populated by JavaScript -->
                    </div>
                    <div class="chat-list-actions">
                        <button id="saveChatsBtn" title="ëª¨ë“  ëŒ€í™” ì €ì¥">ğŸ’¾ ì €ì¥</button>
                        <button id="loadChatsBtn" title="íŒŒì¼ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°">ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸°</button>
                        <input type="file" id="loadChatsInput" style="display: none;" accept=".json">
                        <button id="deleteChatsBtn" title="ì„ íƒ ëŒ€í™” ì‚­ì œ">ğŸ—‘ï¸ ì‚­ì œ</button>
                    </div>
                </div>

                <div class="chat-panel">
                    <div class="chat-header">
                        <h3>AI ì–´ì‹œìŠ¤í„´íŠ¸</h3>
                        <button id="newChatBtn">ìƒˆ ëŒ€í™”</button>
                    </div>
                    <div class="chat-history" id="chatHistory">
                        <!-- Chat messages will be appended here -->
                    </div>
                </div>
            </div>

            <div class="selection-container">
                <div class="dark-selection-box">
                    <h3>ğŸŒ&nbsp;í”Œë«í¼ ì„ íƒ</h3>
                    <div class="platform-group">
                        <div class="platform-card" data-platform="youtube_shorts">
                            <div class="platform-icon">ğŸ“º</div>
                            YouTube Shorts
                        </div>
                        <div class="platform-card" data-platform="instagram_reels">
                            <div class="platform-icon">ğŸ“¸</div>
                            Instagram Reels
                        </div>
                        <div class="platform-card" data-platform="tiktok">
                            <div class="platform-icon">ğŸµ</div>
                            TikTok
                        </div>
                        <div class="platform-card" data-platform="naver">
                            <div class="platform-icon">KR</div>
                            ë„¤ì´ë²„
                        </div>
                        <div class="platform-card" data-platform="facebook_reels">
                            <div class="platform-icon">ğŸ‘¥</div>
                            Facebook Reels
                        </div>
                    </div>
                </div>
    
                <div class="dark-selection-box ai-model-box">
                    <div class="chat-input-area">
                        <textarea id="chatInput" placeholder="AIì—ê²Œ ì˜ìƒ ì²˜ë¦¬ë¥¼ ìš”ì²­í•˜ì„¸ìš”..." rows="1"></textarea>
                        <button id="sendChatBtn" disabled>ì „ì†¡</button>
                    </div>
                    <div class="ai-model-container">
                        <select id="mainModelSelect" class="setting-input"></select>
                        <select id="subModelSelect" class="setting-input"></select>
                        <button class="settings-btn" id="apiSettingsBtn" title="API í‚¤ ì„¤ì •">âš™ï¸</button>
                    </div>
                </div>
            </div>

            <div class="process-section">
                <button id="processBtn" class="process-btn" disabled>ğŸš€&nbsp;ì˜ìƒ ì²˜ë¦¬ ì‹œì‘</button>
            </div>

            <!-- ë°°ìš° ì–¼êµ´ ê°¤ëŸ¬ë¦¬ ì„¹ì…˜ -->
            <div class="face-gallery-container" id="faceGalleryContainer" style="display: none;">
                <h3>ğŸ­ ë°°ìš° ì–¼êµ´ ê°¤ëŸ¬ë¦¬</h3>
                <div class="face-gallery-controls">
                    <button class="btn btn-secondary" id="analyzeFacesBtn">
                        ğŸ” ì–¼êµ´ ë¶„ì„ ì‹œì‘
                    </button>
                    <button class="btn btn-primary" id="generateFaceImagesBtn" style="display: none;">
                        ğŸ¨ AI ì–¼êµ´ ê·¸ë¦¬ê¸°
                    </button>
                    <button class="btn btn-success" id="downloadFaceGalleryBtn" style="display: none;">
                        ğŸ“¥ ê°¤ëŸ¬ë¦¬ ë‹¤ìš´ë¡œë“œ
                    </button>
                </div>
                <div style="text-align: center; margin-bottom: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                    ğŸ¯ <strong>ì‹¤ì œ ì–¼êµ´ ì¸ì‹ ì‹œìŠ¤í…œ:</strong><br>
                    â€¢ <span style="color: #00bcd4;">Face-api.js</span>ë¡œ ì˜ìƒì—ì„œ ì‹¤ì œ ë°°ìš° ì–¼êµ´ ê°ì§€<br>
                    â€¢ <span style="color: #ff9800;">ë‚˜ì´, ì„±ë³„, í‘œì •</span> ìë™ ë¶„ì„<br>
                    â€¢ <span style="color: #4caf50;">ì–¼êµ´ë³„ ë“±ì¥ íšŸìˆ˜</span> ë° ì‹œê°„ ì¶”ì <br>
                    â€¢ <span style="color: #9c27b0;">ê°™ì€ ì¸ë¬¼ ìë™ ê·¸ë£¹í™”</span> (AI ìœ ì‚¬ë„ ê³„ì‚°)
                </div>
                <div class="analysis-progress" id="analysisProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="faceProgressFill"></div>
                    </div>
                    <div class="progress-text" id="faceProgressText">ì–¼êµ´ ë¶„ì„ ì¤‘...</div>
                </div>
                <div class="face-results" id="faceResults">
                    <!-- ë¶„ì„ëœ ì–¼êµ´ë“¤ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                </div>
            </div>

            <!-- ì§„í–‰ë¥  í‘œì‹œ -->
            <div class="progress-section" id="progressSection">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="status-text" id="statusText">ì²˜ë¦¬ ì¤‘...</div>
            </div>
        </div>

        <!-- ì˜¤ë¥¸ìª½ íŒ¨ë„: ê²°ê³¼ -->
        <div class="right-panel">
            <div id="resultsContainer">
                <div class="title-box">
                    <h3>âœ… ì™„ì„±ëœ ìˆì¸  ì˜ìƒ</h3>
                </div>
                <div class="shorts-carousel">
                    <button class="carousel-btn prev" id="prevShortBtn">â€¹</button>
                    <div class="shorts-viewport">
                        <div id="shortsTrack">
                            <!-- JS will populate this -->
                        </div>
                    </div>
                    <button class="carousel-btn next" id="nextShortBtn">â€º</button>
                </div>
                <div id="shorts-counter"></div>
                <div id="completedShortsGrid" style="display: none;">
                    <!-- This is now unused, but kept for safety, will be controlled by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- ì—…ë¡œë“œ ëª¨ë‹¬ -->
    <div class="upload-modal" id="uploadModal">
        <div class="upload-modal-content">
            <h3 id="modalTitle">í”Œë«í¼ ì—…ë¡œë“œ</h3>
            <form class="upload-form" id="uploadForm">
                <div class="form-group">
                    <label for="videoTitle">ì œëª©</label>
                    <input type="text" id="videoTitle" required>
                </div>
                <div class="form-group">
                    <label for="videoDescription">ì„¤ëª…</label>
                    <textarea id="videoDescription" placeholder="ì˜ìƒì— ëŒ€í•œ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”..."></textarea>
                </div>
                <div class="form-group">
                    <label for="videoTags">íƒœê·¸ (ì‰¼í‘œë¡œ êµ¬ë¶„)</label>
                    <input type="text" id="videoTags" placeholder="ì˜ˆ: ìˆì¸ , ìœ íŠœë¸Œ, ì¬ë¯¸ìˆëŠ”">
                </div>
            </form>
            <div class="modal-actions">
                <button class="modal-btn cancel" id="cancelUpload">ì·¨ì†Œ</button>
                <button class="modal-btn upload" id="confirmUpload">ì—…ë¡œë“œ</button>
            </div>
        </div>
    </div>

    <!-- API Key Modal -->
    <div id="apiKeyModal" class="api-key-modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h3 id="apiKeyModalTitle">API í‚¤ ì„¤ì •</h3>
            <div class="form-group">
                <div class="form-label-group">
                    <label for="apiKeyInput">API í‚¤</label>
                    <a href="#" id="apiKeyLink" target="_blank" rel="noopener noreferrer">API í‚¤ ë°œê¸‰ë°›ê¸° &nearr;</a>
                </div>
                <input type="password" id="apiKeyInput" class="form-group-input">
            </div>
            <div class="modal-actions">
                <button id="cancelApiKey" class="btn btn-secondary">ì·¨ì†Œ</button>
                <button id="saveApiKey" class="btn btn-primary">ì €ì¥</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const themeToggle = document.getElementById('theme-toggle');
            
            // Upload related
            const uploadContainer = document.getElementById('uploadContainer');
            const fileInput = document.getElementById('file-input');

            // Video Preview related
            const videoEditorContainer = document.getElementById('videoEditorContainer');
            const videoPreview = document.getElementById('videoPreview');
            
            // Controls and buttons
            const processBtn = document.getElementById('processBtn');
            const platformCards = document.querySelectorAll('.platform-card');
            const loadNewVideoButton = document.getElementById('loadNewVideoButton');
            
            // Storage management elements
            const selectFolderBtn = document.getElementById('selectFolderBtn');
            const outputFolder = document.getElementById('outputFolder');
            const autoSave = document.getElementById('autoSave');
            const fileNaming = document.getElementById('fileNaming');
            const customName = document.getElementById('customName');
            const customNameContainer = document.getElementById('customNameContainer');
            
            // Results related
            const resultsContainer = document.getElementById('resultsContainer');
            const completedShortsGrid = document.getElementById('completedShortsGrid');
            const shortsTrack = document.getElementById('shortsTrack');
            const prevShortBtn = document.getElementById('prevShortBtn');
            const nextShortBtn = document.getElementById('nextShortBtn');
            const shortsCounter = document.getElementById('shorts-counter');

            // Chat panel elements
            const chatHistory = document.getElementById('chatHistory');
            const chatInput = document.getElementById('chatInput');
            const sendChatBtn = document.getElementById('sendChatBtn');
            const newChatBtn = document.getElementById('newChatBtn');

            // Chat List elements
            const chatList = document.getElementById('chatList');
            const selectAllChats = document.getElementById('selectAllChats');
            const saveChatsBtn = document.getElementById('saveChatsBtn');
            const loadChatsBtn = document.getElementById('loadChatsBtn');
            const loadChatsInput = document.getElementById('loadChatsInput');
            const deleteChatsBtn = document.getElementById('deleteChatsBtn');

            // Face Gallery elements
            const faceGalleryContainer = document.getElementById('faceGalleryContainer');
            const faceAnalysisCheckbox = document.getElementById('faceAnalysis');
            const analyzeFacesBtn = document.getElementById('analyzeFacesBtn');
            const generateFaceImagesBtn = document.getElementById('generateFaceImagesBtn');
            const downloadFaceGalleryBtn = document.getElementById('downloadFaceGalleryBtn');
            const analysisProgress = document.getElementById('analysisProgress');
            const faceProgressFill = document.getElementById('faceProgressFill');
            const faceProgressText = document.getElementById('faceProgressText');
            const faceResults = document.getElementById('faceResults');

            let uploadedFile = null;
            let chats = [];
            let currentChatId = null;
            let allGeneratedShorts = [];
            let currentShortIndex = 0;
            let outputFolderHandle = null;
            let savedShortsCount = 0;
            let detectedFaces = [];
            let faceAnalysisInProgress = false;
            let faceApiModelsLoaded = false;
            let videoFrames = [];
            let faceDescriptors = [];

            // --- AI Model Data & Logic ---
            const aiModels = {
                claude: { 
                    name: "Claude", 
                    subModels: [
                        "Claude 3.5 Sonnet", 
                        "Claude 3.5 Haiku", 
                        "Claude 3 Opus", 
                        "Claude 3 Sonnet", 
                        "Claude 3 Haiku"
                    ], 
                    apiKey: "", 
                    apiKeyUrl: "https://console.anthropic.com/settings/keys",
                    endpoint: "https://api.anthropic.com/v1/messages"
                },
                gpt: { 
                    name: "OpenAI GPT", 
                    subModels: [
                        "GPT-4o", 
                        "GPT-4o mini", 
                        "GPT-4 Turbo", 
                        "GPT-4", 
                        "GPT-3.5 Turbo", 
                        "GPT-3.5 Turbo 16k"
                    ], 
                    apiKey: "", 
                    apiKeyUrl: "https://platform.openai.com/api-keys",
                    endpoint: "https://api.openai.com/v1/chat/completions"
                },
                gemini: { 
                    name: "Google Gemini", 
                    subModels: [
                        "Gemini 2.0 Flash", 
                        "Gemini 1.5 Pro", 
                        "Gemini 1.5 Flash", 
                        "Gemini 1.5 Flash-8B", 
                        "Gemini 1.0 Pro"
                    ], 
                    apiKey: "", 
                    apiKeyUrl: "https://aistudio.google.com/app/api-keys",
                    endpoint: "https://generativelanguage.googleapis.com/v1beta/models"
                },
                groq: { 
                    name: "Groq", 
                    subModels: [
                        "Llama 3.3 70B", 
                        "Llama 3.1 405B", 
                        "Llama 3.1 70B", 
                        "Llama 3.1 8B", 
                        "Llama 3 70B", 
                        "Llama 3 8B", 
                        "Mixtral 8x7B", 
                        "Gemma 2 9B", 
                        "Gemma 7B"
                    ], 
                    apiKey: "", 
                    apiKeyUrl: "https://console.groq.com/keys",
                    endpoint: "https://api.groq.com/openai/v1/chat/completions"
                },
                perplexity: {
                    name: "Perplexity",
                    subModels: [
                        "Llama 3.1 Sonar Large",
                        "Llama 3.1 Sonar Small", 
                        "Llama 3.1 70B",
                        "Llama 3.1 8B"
                    ],
                    apiKey: "",
                    apiKeyUrl: "https://www.perplexity.ai/settings/api",
                    endpoint: "https://api.perplexity.ai/chat/completions"
                },
                cohere: {
                    name: "Cohere",
                    subModels: [
                        "Command R+",
                        "Command R",
                        "Command",
                        "Command Light"
                    ],
                    apiKey: "",
                    apiKeyUrl: "https://dashboard.cohere.com/api-keys",
                    endpoint: "https://api.cohere.ai/v1/chat"
                }
            };

            const mainModelSelect = document.getElementById('mainModelSelect');
            const subModelSelect = document.getElementById('subModelSelect');
            const apiSettingsBtn = document.getElementById('apiSettingsBtn');
            
            // API Key Modal Elements
            const apiKeyModal = document.getElementById('apiKeyModal');
            const apiKeyModalTitle = document.getElementById('apiKeyModalTitle');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const apiKeyLink = document.getElementById('apiKeyLink');
            const saveApiKeyBtn = document.getElementById('saveApiKey');
            const cancelApiKeyBtn = document.getElementById('cancelApiKey');
            const closeBtn = apiKeyModal.querySelector('.close-button');
            let currentEditingModel = null;

            function initializeMainModels() {
                mainModelSelect.innerHTML = '';
                for (const key in aiModels) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = aiModels[key].name;
                    mainModelSelect.appendChild(option);
                }
            }

            function updateSubModels() {
                const selectedModelKey = mainModelSelect.value;
                const subModels = aiModels[selectedModelKey].subModels;
                
                subModelSelect.innerHTML = '';
                subModels.forEach(modelName => {
                    const option = document.createElement('option');
                    option.value = modelName;
                    option.textContent = modelName;
                    subModelSelect.appendChild(option);
                });
            }
            
            mainModelSelect.addEventListener('change', updateSubModels);

            // --- API Key Modal Logic ---
            apiSettingsBtn.addEventListener('click', () => {
                const selectedModelKey = mainModelSelect.value;
                const modelData = aiModels[selectedModelKey];
                
                apiKeyModalTitle.textContent = `${modelData.name} API í‚¤ ì„¤ì •`;
                apiKeyInput.value = modelData.apiKey || '';
                apiKeyLink.href = modelData.apiKeyUrl;

                apiKeyModal.style.display = 'block';
                
                currentEditingModel = selectedModelKey;
            });

            function closeApiKeyModal() {
                 apiKeyModal.style.display = 'none';
            }

            closeBtn.addEventListener('click', closeApiKeyModal);
            cancelApiKeyBtn.addEventListener('click', closeApiKeyModal);
            
            saveApiKeyBtn.addEventListener('click', () => {
                if (currentEditingModel) {
                    aiModels[currentEditingModel].apiKey = apiKeyInput.value;
                    localStorage.setItem(`apiKey_${currentEditingModel}`, apiKeyInput.value);
                    console.log(`${aiModels[currentEditingModel].name} API Key saved.`); // For debugging
                    alert(`${aiModels[currentEditingModel].name} API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    closeApiKeyModal();
                }
            });

            // Load saved API keys
            function loadSavedApiKeys() {
                for (const modelKey in aiModels) {
                    const savedKey = localStorage.getItem(`apiKey_${modelKey}`);
                    if (savedKey) {
                        aiModels[modelKey].apiKey = savedKey;
                    }
                }
            }

            // --- Storage Management Functions ---
            async function selectOutputFolder() {
                try {
                    if ('showDirectoryPicker' in window) {
                        outputFolderHandle = await window.showDirectoryPicker();
                        const folderName = outputFolderHandle.name;
                        outputFolder.value = folderName;
                        localStorage.setItem('outputFolderName', folderName);
                        
                        // í´ë” ì„ íƒ í›„ ì‹œê°ì  ìƒíƒœ ì—…ë°ì´íŠ¸
                        updateFolderStatus(true, folderName);
                        addMessage('ai', `âœ… ì €ì¥ í´ë”ê°€ "${folderName}"ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ ì˜ìƒ ì²˜ë¦¬ ì™„ë£Œ í›„ ìë™ìœ¼ë¡œ ì´ í´ë”ì— ì €ì¥ë©ë‹ˆë‹¤.`);
                    } else {
                        // Fallback for browsers that don't support File System Access API
                        const folderPath = prompt('ì €ì¥í•  í´ë” ê²½ë¡œë¥¼ ì…ë ¥í•˜ì„¸ìš”:', 'C:\\AutoShorts\\Output');
                        if (folderPath) {
                            outputFolder.value = folderPath;
                            localStorage.setItem('outputFolderPath', folderPath);
                            
                            // í´ë” ì„ íƒ í›„ ì‹œê°ì  ìƒíƒœ ì—…ë°ì´íŠ¸
                            updateFolderStatus(true, folderPath);
                            addMessage('ai', `âœ… ì €ì¥ ê²½ë¡œê°€ "${folderPath}"ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ ì˜ìƒ ì²˜ë¦¬ ì™„ë£Œ í›„ ìë™ìœ¼ë¡œ ì´ í´ë”ì— ì €ì¥ë©ë‹ˆë‹¤.`);
                        }
                    }
                } catch (error) {
                    console.error('Folder selection error:', error);
                    addMessage('ai', 'âŒ í´ë” ì„ íƒì´ ì·¨ì†Œë˜ì—ˆê±°ë‚˜ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                }
            }

            function generateFileName(index, originalName = 'video') {
                const namingType = fileNaming.value;
                const now = new Date();
                
                switch (namingType) {
                    case 'timestamp':
                        const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
                        return `shorts_${timestamp}_${index}.mp4`;
                    
                    case 'sequential':
                        const paddedIndex = String(savedShortsCount + index).padStart(3, '0');
                        return `shorts_${paddedIndex}.mp4`;
                    
                    case 'custom':
                        const customPrefix = customName.value.trim() || 'MyShorts';
                        const paddedCustomIndex = String(index).padStart(3, '0');
                        return `${customPrefix}_${paddedCustomIndex}.mp4`;
                    
                    default:
                        return `shorts_${index}.mp4`;
                }
            }

            async function saveVideoFile(videoElement, fileName) {
                try {
                    // Create download link for the video
                    const link = document.createElement('a');
                    link.href = videoElement.src;
                    link.download = fileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    return true;
                } catch (error) {
                    console.error('Save error:', error);
                    return false;
                }
            }

            async function autoSaveShorts() {
                if (!autoSave.checked) return;
                
                // ì €ì¥ í´ë” í™•ì¸
                const currentFolder = outputFolder.value;
                if (!currentFolder) {
                    addMessage('ai', 'âš ï¸ ì €ì¥ í´ë”ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¨¼ì € ì €ì¥ í´ë”ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    updateFolderStatus(false);
                    return;
                }
                
                let savedCount = 0;
                const totalShorts = allGeneratedShorts.length;
                
                addMessage('ai', `ğŸ’¾ ${totalShorts}ê°œì˜ ìˆì¸ ë¥¼ "${currentFolder}" í´ë”ì— ìë™ ì €ì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤...`);
                
                for (let i = 0; i < allGeneratedShorts.length; i++) {
                    const shortElement = allGeneratedShorts[i];
                    const video = shortElement.querySelector('video');
                    const fileName = generateFileName(i + 1);
                    
                    const success = await saveVideoFile(video, fileName);
                    if (success) {
                        savedCount++;
                        // Update UI to show saved status
                        const shortInfo = shortElement.querySelector('.short-info');
                        const savedBadge = document.createElement('span');
                        savedBadge.innerHTML = 'ğŸ’¾ ì €ì¥ë¨';
                        savedBadge.style.cssText = 'font-size: 0.75rem; color: var(--success-text); margin-left: 0.5rem;';
                        shortInfo.appendChild(savedBadge);
                    }
                }
                
                savedShortsCount += savedCount;
                localStorage.setItem('savedShortsCount', savedShortsCount.toString());
                
                if (savedCount === totalShorts) {
                    addMessage('ai', `âœ… ${savedCount}ê°œì˜ ìˆì¸ ê°€ ëª¨ë‘ "${currentFolder}" í´ë”ì— ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!`);
                } else {
                    addMessage('ai', `âš ï¸ ${savedCount}/${totalShorts}ê°œì˜ ìˆì¸ ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤. ${totalShorts - savedCount}ê°œëŠ” ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`);
                }
            }

            // Individual download function
            window.downloadSingleShort = function(button, index) {
                // ì €ì¥ í´ë” í™•ì¸
                const currentFolder = outputFolder.value;
                if (!currentFolder) {
                    addMessage('ai', 'âš ï¸ ì €ì¥ í´ë”ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¨¼ì € ì €ì¥ í´ë”ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    updateFolderStatus(false);
                    return;
                }
                
                const shortElement = button.closest('.short-item');
                const video = shortElement.querySelector('video');
                const fileName = generateFileName(index);
                
                saveVideoFile(video, fileName).then(success => {
                    if (success) {
                        addMessage('ai', `ğŸ’¾ ìˆì¸  #${index}ê°€ "${currentFolder}" í´ë”ì— "${fileName}" ì´ë¦„ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                        
                        // Add saved badge if not already present
                        const shortInfo = shortElement.querySelector('.short-info');
                        if (!shortInfo.querySelector('.saved-badge')) {
                            const savedBadge = document.createElement('span');
                            savedBadge.className = 'saved-badge';
                            savedBadge.innerHTML = 'ğŸ’¾ ì €ì¥ë¨';
                            savedBadge.style.cssText = 'font-size: 0.75rem; color: var(--success-text); margin-left: 0.5rem;';
                            shortInfo.appendChild(savedBadge);
                        }
                    } else {
                        addMessage('ai', `âŒ ìˆì¸  #${index} ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`);
                    }
                });
            };

            // Event listeners for storage management
            selectFolderBtn.addEventListener('click', selectOutputFolder);
            
            fileNaming.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    customNameContainer.style.display = 'flex';
                } else {
                    customNameContainer.style.display = 'none';
                }
            });

            // Load saved settings
            function loadStorageSettings() {
                const savedFolderName = localStorage.getItem('outputFolderName');
                const savedFolderPath = localStorage.getItem('outputFolderPath');
                const savedCount = localStorage.getItem('savedShortsCount');
                
                // ì²˜ìŒ ì‹¤í–‰ì‹œ ë¹ˆ ìƒíƒœë¡œ í‘œì‹œ
                if (savedFolderName) {
                    outputFolder.value = savedFolderName;
                    updateFolderStatus(true, savedFolderName);
                    // ê¸°ì¡´ í´ë” ì„¤ì • ì•Œë¦¼
                    setTimeout(() => {
                        addMessage('ai', `ğŸ“ ì´ì „ì— ì„¤ì •í•œ ì €ì¥ í´ë” "${savedFolderName}"ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤. ì˜ìƒ ì²˜ë¦¬ ì™„ë£Œ í›„ ìë™ìœ¼ë¡œ ì´ í´ë”ì— ì €ì¥ë©ë‹ˆë‹¤.`);
                    }, 1000);
                } else if (savedFolderPath) {
                    outputFolder.value = savedFolderPath;
                    updateFolderStatus(true, savedFolderPath);
                    // ê¸°ì¡´ í´ë” ì„¤ì • ì•Œë¦¼
                    setTimeout(() => {
                        addMessage('ai', `ğŸ“ ì´ì „ì— ì„¤ì •í•œ ì €ì¥ ê²½ë¡œ "${savedFolderPath}"ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤. ì˜ìƒ ì²˜ë¦¬ ì™„ë£Œ í›„ ìë™ìœ¼ë¡œ ì´ ê²½ë¡œì— ì €ì¥ë©ë‹ˆë‹¤.`);
                    }, 1000);
                } else {
                    // ì²˜ìŒ ì‹¤í–‰ - ë¹ˆ ìƒíƒœ ëª…ì‹œì  í‘œì‹œ
                    outputFolder.value = '';
                    outputFolder.placeholder = 'ğŸ“ ì €ì¥ í´ë”ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”';
                    updateFolderStatus(false);
                    // í´ë” ì„ íƒ ì•ˆë‚´ ë©”ì‹œì§€
                    setTimeout(() => {
                        addMessage('ai', 'ğŸ‘‹ í™˜ì˜í•©ë‹ˆë‹¤! ì˜ìƒ ì²˜ë¦¬ë¥¼ ì‹œì‘í•˜ê¸° ì „ì— ì €ì¥ í´ë”ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”. ğŸ“ ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ í´ë”ë¥¼ ì§€ì •í•˜ë©´ ë‹¤ìŒë¶€í„°ëŠ” ìë™ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.');
                    }, 1500);
                }
                
                if (savedCount) {
                    savedShortsCount = parseInt(savedCount, 10);
                }
            }

            // í´ë” ì„ íƒ ìƒíƒœë¥¼ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œí•˜ëŠ” í•¨ìˆ˜
            function updateFolderStatus(isSelected, folderName = '') {
                const selectFolderBtn = document.getElementById('selectFolderBtn');
                const outputFolder = document.getElementById('outputFolder');
                
                if (isSelected && folderName) {
                    // í´ë”ê°€ ì„ íƒëœ ìƒíƒœ
                    outputFolder.className = 'setting-input folder-selected';
                    selectFolderBtn.className = 'control-btn folder-selected';
                    selectFolderBtn.innerHTML = 'âœ…';
                    selectFolderBtn.title = `í˜„ì¬ í´ë”: ${folderName}`;
                    outputFolder.placeholder = `í˜„ì¬ ì„ íƒ: ${folderName}`;
                } else {
                    // í´ë”ê°€ ì„ íƒë˜ì§€ ì•Šì€ ìƒíƒœ (ì²˜ìŒ ì‹¤í–‰)
                    outputFolder.className = 'setting-input folder-not-selected';
                    selectFolderBtn.className = 'control-btn folder-not-selected';
                    selectFolderBtn.innerHTML = 'ğŸ“';
                    selectFolderBtn.title = 'ì €ì¥ í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš” (í•„ìˆ˜)';
                    outputFolder.placeholder = 'ğŸ“ ì €ì¥ í´ë”ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”';
                }
            }

            // --- Video Analysis Functions ---
            async function extractVideoFrames(videoElement, numFrames = 5) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const frames = [];
                
                canvas.width = 640;
                canvas.height = 360;
                
                const duration = videoElement.duration;
                const interval = duration / numFrames;
                
                for (let i = 0; i < numFrames; i++) {
                    const time = i * interval;
                    await seekToTime(videoElement, time);
                    
                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                    const frameData = canvas.toDataURL('image/jpeg', 0.8);
                    frames.push({
                        time: time,
                        data: frameData
                    });
                }
                
                return frames;
            }
            
            function seekToTime(videoElement, time) {
                return new Promise((resolve) => {
                    const onSeeked = () => {
                        videoElement.removeEventListener('seeked', onSeeked);
                        resolve();
                    };
                    videoElement.addEventListener('seeked', onSeeked);
                    videoElement.currentTime = time;
                });
            }

            // í˜„ì¬ ì„ íƒëœ ëª¨ë“  ì˜µì…˜ì„ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜
            function getCurrentOptions() {
                const selectedPlatforms = Array.from(getSelectedPlatforms()).map(p => p.dataset.platform);
                const platformNames = {
                    'youtube_shorts': 'YouTube Shorts',
                    'instagram_reels': 'Instagram Reels',
                    'tiktok': 'TikTok',
                    'naver': 'ë„¤ì´ë²„',
                    'facebook_reels': 'Facebook Reels'
                };

                return {
                    // ì˜ìƒ ì²˜ë¦¬ ì˜µì…˜
                    videoProcessing: {
                        autoHighlight: document.getElementById('autoHighlight').checked,
                        autoCrop: document.getElementById('autoCrop').checked,
                        colorCorrection: document.getElementById('colorCorrection').checked,
                        videoStabilization: document.getElementById('videoStabilization').checked
                    },
                    // ì˜¤ë””ì˜¤ ì²˜ë¦¬ ì˜µì…˜
                    audioProcessing: {
                        removeSilence: document.getElementById('removeSilence').checked,
                        enhanceAudio: document.getElementById('enhanceAudio').checked,
                        noiseReduction: document.getElementById('noiseReduction').checked
                    },
                    // ì¶”ê°€ ê¸°ëŠ¥
                    features: {
                        addTitle: document.getElementById('addTitle').checked,
                        addSubtitles: document.getElementById('addSubtitles').checked,
                        addEffects: document.getElementById('addEffects').checked
                    },
                    // ìˆì¸  ì„¤ì •
                    settings: {
                        shortsLength: parseInt(document.getElementById('shortsLength').value),
                        shortsCount: parseInt(document.getElementById('shortsCount').value)
                    },
                    // ì„ íƒëœ í”Œë«í¼
                    platforms: selectedPlatforms.map(p => platformNames[p] || p),
                    // AI ëª¨ë¸ ì •ë³´
                    aiModel: {
                        provider: mainModelSelect.options[mainModelSelect.selectedIndex].text,
                        model: subModelSelect.options[subModelSelect.selectedIndex].text
                    },
                    // ì €ì¥ ê´€ë¦¬ ì„¤ì •
                    storage: {
                        autoSave: document.getElementById('autoSave').checked,
                        outputFolder: document.getElementById('outputFolder').value,
                        fileNaming: document.getElementById('fileNaming').value,
                        customName: document.getElementById('customName').value
                    }
                };
            }

            // ì˜µì…˜ì„ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
            function formatOptionsForAI(options) {
                let optionsText = "\nğŸ“‹ í˜„ì¬ ì„ íƒëœ ì˜µì…˜ë“¤:\n\n";
                
                // í”Œë«í¼ ì •ë³´
                if (options.platforms.length > 0) {
                    optionsText += `ğŸŒ íƒ€ê²Ÿ í”Œë«í¼: ${options.platforms.join(', ')}\n`;
                } else {
                    optionsText += `âš ï¸ í”Œë«í¼ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n`;
                }
                
                // ìˆì¸  ì„¤ì •
                optionsText += `â±ï¸ ìˆì¸  ê¸¸ì´: ${options.settings.shortsLength}ì´ˆ\n`;
                optionsText += `ğŸ”¢ ìƒì„± ê°œìˆ˜: ${options.settings.shortsCount}ê°œ\n\n`;
                
                // ì˜ìƒ ì²˜ë¦¬ ì˜µì…˜
                const videoOptions = [];
                if (options.videoProcessing.autoHighlight) videoOptions.push("ìë™ í•˜ì´ë¼ì´íŠ¸ ì¶”ì¶œ");
                if (options.videoProcessing.autoCrop) videoOptions.push("ìë™ í¬ë¡­");
                if (options.videoProcessing.colorCorrection) videoOptions.push("ìƒ‰ìƒ ë³´ì •");
                if (options.videoProcessing.videoStabilization) videoOptions.push("ì˜ìƒ ì•ˆì •í™”");
                
                if (videoOptions.length > 0) {
                    optionsText += `ğŸ“¼ ì˜ìƒ ì²˜ë¦¬: ${videoOptions.join(', ')}\n`;
                }
                
                // ì˜¤ë””ì˜¤ ì²˜ë¦¬ ì˜µì…˜
                const audioOptions = [];
                if (options.audioProcessing.removeSilence) audioOptions.push("ë¬´ìŒ êµ¬ê°„ ì œê±°");
                if (options.audioProcessing.enhanceAudio) audioOptions.push("ì˜¤ë””ì˜¤ í–¥ìƒ");
                if (options.audioProcessing.noiseReduction) audioOptions.push("ë…¸ì´ì¦ˆ ê°ì†Œ");
                
                if (audioOptions.length > 0) {
                    optionsText += `ğŸ”Š ì˜¤ë””ì˜¤ ì²˜ë¦¬: ${audioOptions.join(', ')}\n`;
                }
                
                // ì¶”ê°€ ê¸°ëŠ¥
                const features = [];
                if (options.features.addTitle) features.push("íƒ€ì´í‹€ ì¶”ê°€");
                if (options.features.addSubtitles) features.push("ìë§‰ ì¶”ê°€");
                if (options.features.addEffects) features.push("ì˜ìƒíš¨ê³¼ ì¶”ê°€");
                
                if (features.length > 0) {
                    optionsText += `âœ¨ ì¶”ê°€ ê¸°ëŠ¥: ${features.join(', ')}\n`;
                }
                
                optionsText += `\nğŸ¤– ì‚¬ìš© ì¤‘ì¸ AI: ${options.aiModel.provider} - ${options.aiModel.model}\n`;
                
                // ì €ì¥ ê´€ë¦¬ ì„¤ì •
                if (options.storage.outputFolder) {
                    optionsText += `ğŸ“ ì €ì¥ í´ë”: ${options.storage.outputFolder}\n`;
                }
                optionsText += `ğŸ’¾ ìë™ ì €ì¥: ${options.storage.autoSave ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}\n`;
                optionsText += `ğŸ“ íŒŒì¼ëª… í˜•ì‹: ${options.storage.fileNaming === 'timestamp' ? 'íƒ€ì„ìŠ¤íƒ¬í”„' : options.storage.fileNaming === 'sequential' ? 'ìˆœì°¨ë²ˆí˜¸' : 'ì‚¬ìš©ì ì •ì˜'}\n`;
                
                return optionsText;
            }

            async function analyzeVideoContent(message) {
                if (!uploadedFile || !videoPreview.src) {
                    return "ì˜ìƒì´ ì—…ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¨¼ì € ì˜ìƒì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.";
                }
                
                try {
                    // Extract frames from video
                    const frames = await extractVideoFrames(videoPreview, 3);
                    
                    // Get video metadata
                    const videoInfo = {
                        duration: Math.round(videoPreview.duration),
                        width: videoPreview.videoWidth,
                        height: videoPreview.videoHeight,
                        aspectRatio: (videoPreview.videoWidth / videoPreview.videoHeight).toFixed(2)
                    };
                    
                    // í˜„ì¬ ì„ íƒëœ ì˜µì…˜ë“¤ ê°€ì ¸ì˜¤ê¸°
                    const currentOptions = getCurrentOptions();
                    const optionsText = formatOptionsForAI(currentOptions);
                    
                    const analysisPrompt = `
ì˜ìƒ ë¶„ì„ ë° ìˆì¸  ì œì‘ ìš”ì²­: ${message}

ğŸ“¹ ì˜ìƒ ì •ë³´:
- ê¸¸ì´: ${videoInfo.duration}ì´ˆ
- í•´ìƒë„: ${videoInfo.width}x${videoInfo.height}
- í™”ë©´ë¹„: ${videoInfo.aspectRatio}:1

${optionsText}

ğŸ¯ ìš”ì²­ì‚¬í•­:
1. í˜„ì¬ ì„ íƒëœ ì˜µì…˜ë“¤ì„ ëª¨ë‘ ê³ ë ¤í•˜ì—¬ ì˜ìƒì„ ë¶„ì„í•´ì£¼ì„¸ìš”.
2. ì„ íƒëœ í”Œë«í¼(${currentOptions.platforms.join(', ')})ì— ìµœì í™”ëœ í¸ì§‘ ë°©ë²•ì„ ì œì•ˆí•´ì£¼ì„¸ìš”.
3. ${currentOptions.settings.shortsCount}ê°œì˜ ${currentOptions.settings.shortsLength}ì´ˆ ìˆì¸ ë¥¼ ë§Œë“¤ê¸° ìœ„í•œ ìµœì ì˜ êµ¬ê°„ì„ ì¶”ì²œí•´ì£¼ì„¸ìš”.
4. ì„ íƒëœ ì²˜ë¦¬ ì˜µì…˜ë“¤(í•˜ì´ë¼ì´íŠ¸ ì¶”ì¶œ, í¬ë¡­, ìƒ‰ìƒë³´ì • ë“±)ì˜ ì ìš© ë°©ë²•ì„ êµ¬ì²´ì ìœ¼ë¡œ ì„¤ëª…í•´ì£¼ì„¸ìš”.
5. ë§Œì•½ ì‚¬ìš©ìê°€ ìˆì¸  ì œì‘ì„ ìš”ì²­í–ˆë‹¤ë©´, ë§ˆì§€ë§‰ì— "âœ… ë¶„ì„ ì™„ë£Œ! ì§€ê¸ˆ ë°”ë¡œ ìˆì¸  ì œì‘ì„ ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤."ë¼ê³  ë§í•´ì£¼ì„¸ìš”.

ì‚¬ìš©ìì˜ ìš”ì²­ê³¼ í˜„ì¬ ì„¤ì •ì„ ë°”íƒ•ìœ¼ë¡œ ì „ë¬¸ì ì´ê³  êµ¬ì²´ì ì¸ ì¡°ì–¸ì„ ì œê³µí•´ì£¼ì„¸ìš”.`;
                    
                    // ì§ì ‘ AI API í˜¸ì¶œ (sendToAI ëŒ€ì‹ )
                    const selectedModelKey = mainModelSelect.value;
                    const selectedSubModel = subModelSelect.value;
                    const modelData = aiModels[selectedModelKey];
                    
                    if (!modelData.apiKey) {
                        throw new Error(`${modelData.name} API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
                    }

                    const systemPrompt = `ë‹¹ì‹ ì€ ìˆì¸  ì˜ìƒ ì œì‘ì„ ë„ì™€ì£¼ëŠ” AI ì–´ì‹œìŠ¤í„´íŠ¸ì…ë‹ˆë‹¤. 
ì‚¬ìš©ìê°€ ì˜ìƒ í¸ì§‘ê³¼ ê´€ë ¨ëœ ì§ˆë¬¸ì„ í•˜ë©´ ì¹œì ˆí•˜ê³  ì „ë¬¸ì ìœ¼ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”.
ì˜ìƒ ì²˜ë¦¬, í¸ì§‘, í”Œë«í¼ë³„ ìµœì í™”ì— ëŒ€í•œ ì¡°ì–¸ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì‚¬ìš©ìê°€ êµ¬ì²´ì ì¸ ì‘ì—…ì„ ìš”ì²­í•˜ë©´ ë‹¨ê³„ë³„ë¡œ ì•ˆë‚´í•´ì£¼ì„¸ìš”.`;

                    switch (selectedModelKey) {
                        case 'claude':
                            return await callClaudeAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        case 'gpt':
                            return await callOpenAIAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        case 'gemini':
                            return await callGeminiAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        case 'groq':
                            return await callGroqAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        case 'perplexity':
                            return await callPerplexityAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        case 'cohere':
                            return await callCohereAPI(analysisPrompt, systemPrompt, modelData, selectedSubModel);
                        default:
                            throw new Error('ì§€ì›í•˜ì§€ ì•ŠëŠ” AI ëª¨ë¸ì…ë‹ˆë‹¤.');
                    }
                    
                } catch (error) {
                    console.error('Video analysis error:', error);
                    return `ì˜ìƒ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`;
                }
            }

            // --- AI API Functions ---
            async function sendToAI(message) {
                const selectedModelKey = mainModelSelect.value;
                const selectedSubModel = subModelSelect.value;
                const modelData = aiModels[selectedModelKey];
                
                if (!modelData.apiKey) {
                    throw new Error(`${modelData.name} API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì • ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.`);
                }

                // Check if this is a video analysis request
                const videoAnalysisKeywords = ['ì˜ìƒ', 'ë¹„ë””ì˜¤', 'ë¶„ì„', 'í•˜ì´ë¼ì´íŠ¸', 'í¸ì§‘', 'í¬ë¡­', 'ìë§‰', 'íš¨ê³¼'];
                const isVideoAnalysis = videoAnalysisKeywords.some(keyword => message.includes(keyword)) && uploadedFile;
                
                if (isVideoAnalysis) {
                    return await analyzeVideoContent(message);
                }

                // í˜„ì¬ ì„ íƒëœ ì˜µì…˜ë“¤ë„ ì¼ë°˜ ëŒ€í™”ì— í¬í•¨
                const currentOptions = getCurrentOptions();
                const optionsText = formatOptionsForAI(currentOptions);
                
                const systemPrompt = `ë‹¹ì‹ ì€ ìˆì¸  ì˜ìƒ ì œì‘ì„ ë„ì™€ì£¼ëŠ” AI ì–´ì‹œìŠ¤í„´íŠ¸ì…ë‹ˆë‹¤. 
ì‚¬ìš©ìê°€ ì˜ìƒ í¸ì§‘ê³¼ ê´€ë ¨ëœ ì§ˆë¬¸ì„ í•˜ë©´ ì¹œì ˆí•˜ê³  ì „ë¬¸ì ìœ¼ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”.
ì˜ìƒ ì²˜ë¦¬, í¸ì§‘, í”Œë«í¼ë³„ ìµœì í™”ì— ëŒ€í•œ ì¡°ì–¸ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì‚¬ìš©ìê°€ êµ¬ì²´ì ì¸ ì‘ì—…ì„ ìš”ì²­í•˜ë©´ ë‹¨ê³„ë³„ë¡œ ì•ˆë‚´í•´ì£¼ì„¸ìš”.

${optionsText}

í˜„ì¬ ì„ íƒëœ ì˜µì…˜ë“¤ì„ í•­ìƒ ê³ ë ¤í•˜ì—¬ ë§ì¶¤í˜• ì¡°ì–¸ì„ ì œê³µí•´ì£¼ì„¸ìš”.
ë§Œì•½ ì‚¬ìš©ìê°€ ìˆì¸  ì œì‘ì„ ìš”ì²­í•˜ë©´ "âœ… ë¶„ì„ ì™„ë£Œ! ì§€ê¸ˆ ë°”ë¡œ ìˆì¸  ì œì‘ì„ ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤."ë¼ê³  ì‘ë‹µí•´ì£¼ì„¸ìš”.`;

                switch (selectedModelKey) {
                    case 'claude':
                        return await callClaudeAPI(message, systemPrompt, modelData, selectedSubModel);
                    case 'gpt':
                        return await callOpenAIAPI(message, systemPrompt, modelData, selectedSubModel);
                    case 'gemini':
                        return await callGeminiAPI(message, systemPrompt, modelData, selectedSubModel);
                    case 'groq':
                        return await callGroqAPI(message, systemPrompt, modelData, selectedSubModel);
                    case 'perplexity':
                        return await callPerplexityAPI(message, systemPrompt, modelData, selectedSubModel);
                    case 'cohere':
                        return await callCohereAPI(message, systemPrompt, modelData, selectedSubModel);
                    default:
                        throw new Error('ì§€ì›í•˜ì§€ ì•ŠëŠ” AI ëª¨ë¸ì…ë‹ˆë‹¤.');
                }
            }

            async function callClaudeAPI(message, systemPrompt, modelData, subModel) {
                // API í‚¤ ê²€ì¦
                if (!modelData.apiKey || modelData.apiKey.trim() === '') {
                    throw new Error('Claude API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. API ì„¤ì •ì—ì„œ í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                }

                if (!modelData.apiKey.startsWith('sk-ant-')) {
                    throw new Error('Claude API í‚¤ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. API í‚¤ëŠ” "sk-ant-"ë¡œ ì‹œì‘í•´ì•¼ í•©ë‹ˆë‹¤.');
                }

                const modelMap = {
                    "Claude 3.5 Sonnet": "claude-3-5-sonnet-20241022",
                    "Claude 3.5 Haiku": "claude-3-5-haiku-20241022",
                    "Claude 3 Opus": "claude-3-opus-20240229",
                    "Claude 3 Sonnet": "claude-3-sonnet-20240229", 
                    "Claude 3 Haiku": "claude-3-haiku-20240307"
                };

                const requestBody = {
                    model: modelMap[subModel] || "claude-3-5-sonnet-20241022",
                    max_tokens: 1000,
                    system: systemPrompt,
                    messages: [{ role: "user", content: message }]
                };

                // CORS ìš°íšŒë¥¼ ìœ„í•œ í”„ë¡ì‹œ ì„œë²„ ì‚¬ìš©
                try {
                    console.log('Claude API í˜¸ì¶œ ì‹œë„ - í”„ë¡ì‹œ ì‚¬ìš©');
                    
                    // CORS Anywhere í”„ë¡ì‹œ ì„œë²„ ì‚¬ìš© (ë” ê°„ë‹¨í•œ ë°©ì‹)
                    const proxyUrl = `https://cors-anywhere.herokuapp.com/${modelData.endpoint}`;
                    
                    const response = await fetch(proxyUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': modelData.apiKey,
                            'anthropic-version': '2023-06-01',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('í”„ë¡ì‹œ ì—ëŸ¬ ì‘ë‹µ:', errorText);
                        throw new Error(`Claude API ì˜¤ë¥˜ (${response.status}): ${errorText}`);
                    }

                    const claudeResponse = await response.json();
                    console.log('Claude API ì‘ë‹µ:', claudeResponse);

                    // Claude API ì—ëŸ¬ ì‘ë‹µ ì²˜ë¦¬
                    if (claudeResponse.error) {
                        throw new Error(`Claude API ì˜¤ë¥˜: ${claudeResponse.error.message || claudeResponse.error.type || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
                    }

                    // ì •ìƒ ì‘ë‹µ ì²˜ë¦¬
                    if (claudeResponse.content && claudeResponse.content[0] && claudeResponse.content[0].text) {
                        console.log('Claude API ì„±ê³µ (í”„ë¡ì‹œ ê²½ìœ )');
                        return claudeResponse.content[0].text;
                    } else {
                        console.error('ì˜ˆìƒí•˜ì§€ ëª»í•œ ì‘ë‹µ í˜•ì‹:', claudeResponse);
                        throw new Error('Claude API ì‘ë‹µ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                    }

                } catch (error) {
                    console.error('Claude API í˜¸ì¶œ ì‹¤íŒ¨:', error);
                    
                    // ë” ì¹œê·¼í•œ ì—ëŸ¬ ë©”ì‹œì§€ ì œê³µ
                    if (error.message.includes('CORS') || error.name === 'TypeError' || error.message.includes('Failed to fetch')) {
                        throw new Error(`ğŸš« Claude API ì—°ê²° ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n\nğŸ’¡ ê°„ë‹¨í•œ í•´ê²° ë°©ë²•:\n1. ğŸ¤– ë‹¤ë¥¸ AI ëª¨ë¸ ì‚¬ìš© (GPT, Gemini ë“± - ì¶”ì²œ!)\n2. ğŸ”§ ë¸Œë¼ìš°ì € í™•ì¥ í”„ë¡œê·¸ë¨: "CORS Unblock" ì„¤ì¹˜\n3. ğŸŒ ë„¤íŠ¸ì›Œí¬ ì—°ê²° ìƒíƒœ í™•ì¸\n\nâœ¨ GPTë‚˜ GeminiëŠ” ë°”ë¡œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤!`);
                    }
                    
                    throw error;
                }
            }

            async function callOpenAIAPI(message, systemPrompt, modelData, subModel) {
                const modelMap = {
                    "GPT-4o": "gpt-4o",
                    "GPT-4o mini": "gpt-4o-mini",
                    "GPT-4 Turbo": "gpt-4-turbo",
                    "GPT-4": "gpt-4",
                    "GPT-3.5 Turbo": "gpt-3.5-turbo",
                    "GPT-3.5 Turbo 16k": "gpt-3.5-turbo-16k"
                };

                const response = await fetch(modelData.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${modelData.apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelMap[subModel] || "gpt-4o-mini",
                        messages: [
                            {
                                role: "system",
                                content: systemPrompt
                            },
                            {
                                role: "user", 
                                content: message
                            }
                        ],
                        max_tokens: 1000,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`OpenAI API ì˜¤ë¥˜: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            async function callGeminiAPI(message, systemPrompt, modelData, subModel) {
                const modelMap = {
                    "Gemini 2.0 Flash": "gemini-2.0-flash-exp",
                    "Gemini 1.5 Pro": "gemini-1.5-pro-latest",
                    "Gemini 1.5 Flash": "gemini-1.5-flash-latest",
                    "Gemini 1.5 Flash-8B": "gemini-1.5-flash-8b-latest",
                    "Gemini 1.0 Pro": "gemini-pro"
                };
                
                const modelName = modelMap[subModel] || "gemini-pro";
                const url = `${modelData.endpoint}/${modelName}:generateContent?key=${modelData.apiKey}`;

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `${systemPrompt}\n\nì‚¬ìš©ì ì§ˆë¬¸: ${message}`
                            }]
                        }],
                        generationConfig: {
                            maxOutputTokens: 1000,
                            temperature: 0.7
                        }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Gemini API ì˜¤ë¥˜: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            }

            async function callGroqAPI(message, systemPrompt, modelData, subModel) {
                const modelMap = {
                    "Llama 3.3 70B": "llama-3.3-70b-versatile",
                    "Llama 3.1 405B": "llama-3.1-405b-reasoning",
                    "Llama 3.1 70B": "llama-3.1-70b-versatile",
                    "Llama 3.1 8B": "llama-3.1-8b-instant",
                    "Llama 3 70B": "llama3-70b-8192",
                    "Llama 3 8B": "llama3-8b-8192",
                    "Mixtral 8x7B": "mixtral-8x7b-32768",
                    "Gemma 2 9B": "gemma2-9b-it",
                    "Gemma 7B": "gemma-7b-it"
                };

                const response = await fetch(modelData.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${modelData.apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelMap[subModel] || "llama-3.1-8b-instant",
                        messages: [
                            {
                                role: "system",
                                content: systemPrompt
                            },
                            {
                                role: "user",
                                content: message
                            }
                        ],
                        max_tokens: 1000,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Groq API ì˜¤ë¥˜: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            async function callPerplexityAPI(message, systemPrompt, modelData, subModel) {
                const modelMap = {
                    "Llama 3.1 Sonar Large": "llama-3.1-sonar-large-128k-online",
                    "Llama 3.1 Sonar Small": "llama-3.1-sonar-small-128k-online",
                    "Llama 3.1 70B": "llama-3.1-70b-instruct",
                    "Llama 3.1 8B": "llama-3.1-8b-instruct"
                };

                const response = await fetch(modelData.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${modelData.apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelMap[subModel] || "llama-3.1-sonar-small-128k-online",
                        messages: [
                            {
                                role: "system",
                                content: systemPrompt
                            },
                            {
                                role: "user",
                                content: message
                            }
                        ],
                        max_tokens: 1000,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Perplexity API ì˜¤ë¥˜: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            async function callCohereAPI(message, systemPrompt, modelData, subModel) {
                const modelMap = {
                    "Command R+": "command-r-plus",
                    "Command R": "command-r",
                    "Command": "command",
                    "Command Light": "command-light"
                };

                const response = await fetch(modelData.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${modelData.apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelMap[subModel] || "command-r",
                        message: message,
                        preamble: systemPrompt,
                        max_tokens: 1000,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Cohere API ì˜¤ë¥˜: ${errorData.message || response.statusText}`);
                }

                const data = await response.json();
                return data.text;
            }

            // --- Theme Switching ---
            function applyInitialTheme() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                document.body.classList.toggle('dark-mode', savedTheme === 'dark');
                themeToggle.textContent = savedTheme === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
            }

            themeToggle.addEventListener('click', () => {
                document.body.classList.toggle('dark-mode');
                const isDarkMode = document.body.classList.contains('dark-mode');
                localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
                themeToggle.textContent = isDarkMode ? 'â˜€ï¸' : 'ğŸŒ™';
            });

            loadNewVideoButton.addEventListener('click', () => {
                fileInput.click();
            });

            applyInitialTheme();

            // --- File Upload Logic ---
            function handleFile(file) {
                if (!file || !file.type.startsWith('video/')) {
                    alert('ìœ íš¨í•œ ë¹„ë””ì˜¤ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    return;
                }
                uploadedFile = file;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    videoPreview.src = e.target.result;
                    videoPreview.load();
                };
                reader.readAsDataURL(file);

                uploadContainer.style.display = 'none';
                videoEditorContainer.style.display = 'block';
                updateProcessButtonState();
            }
            
            uploadContainer.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) handleFile(e.target.files[0]);
            });

            uploadContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadContainer.classList.add('dragover');
            });
            uploadContainer.addEventListener('dragleave', () => {
                uploadContainer.classList.remove('dragover');
            });
            uploadContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadContainer.classList.remove('dragover');
                if (e.dataTransfer.files.length > 0) handleFile(e.dataTransfer.files[0]);
            });

            // --- Platform Selection ---
            platformCards.forEach(card => {
                card.addEventListener('click', () => {
                    card.classList.toggle('selected');
                    updateProcessButtonState();
                });
            });

            function getSelectedPlatforms() {
                return document.querySelectorAll('.platform-card.selected');
            }

            // --- Process Button State ---
            function updateProcessButtonState() {
                const platformsSelected = getSelectedPlatforms().length > 0;
                processBtn.disabled = !uploadedFile || !platformsSelected;
                sendChatBtn.disabled = chatInput.value.trim() === '';
            }

            // --- Chat Panel Logic ---
            function renderChatHistory() {
                chatHistory.innerHTML = '';
                const currentChat = chats.find(chat => chat.id === currentChatId);
                if (!currentChat) return;

                currentChat.messages.forEach(msg => {
                    const messageElement = document.createElement('div');
                    messageElement.classList.add('chat-message', `${msg.sender}-message`);

                    const avatar = `<div class="avatar">${msg.sender === 'ai' ? 'ğŸ¤–' : 'ğŸ‘¤'}</div>`;
                    const content = `<div class="message-content"><p>${msg.text}</p></div>`;
                    
                    messageElement.innerHTML = avatar + content;
                    chatHistory.appendChild(messageElement);
                });
                chatHistory.scrollTop = chatHistory.scrollHeight;
            }

            function addMessage(sender, text) {
                const currentChat = chats.find(chat => chat.id === currentChatId);
                if (currentChat) {
                    currentChat.messages.push({ sender, text });
                    saveChats();
                    renderChatHistory();
                }
            }

            async function handleSendMessage() {
                const text = chatInput.value.trim();
                if (text) {
                    addMessage('user', text);
                    chatInput.value = '';
                    updateProcessButtonState();
                    
                    // Show typing indicator
                    addMessage('ai', 'ğŸ¤” ìƒê°ì¤‘...');
                    
                    try {
                        const aiResponse = await sendToAI(text);
                        // Remove typing indicator
                        const currentChat = chats.find(chat => chat.id === currentChatId);
                        if (currentChat && currentChat.messages.length > 0) {
                            currentChat.messages.pop(); // Remove typing indicator
                        }
                        addMessage('ai', aiResponse);
                        
                        // Check if AI suggests processing or analysis is complete
                        if (aiResponse.includes("âœ… ë¶„ì„ ì™„ë£Œ! ì§€ê¸ˆ ë°”ë¡œ ìˆì¸  ì œì‘ì„ ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤.") || 
                            aiResponse.includes("ì˜ìƒ ì²˜ë¦¬ë¥¼ ì‹œì‘") || 
                            text.includes("ì²˜ë¦¬ ì‹œì‘") || 
                            text.includes("ë§Œë“¤ì–´ì¤˜") ||
                            text.includes("ìˆì¸  ë§Œë“¤ì–´") ||
                            text.includes("ìˆì¸  ìƒì„±") ||
                            text.includes("ì œì‘í•´")) {
                            
                            // í”Œë«í¼ì´ ì„ íƒë˜ì§€ ì•Šì€ ê²½ìš° ê²½ê³ 
                            const selectedPlatforms = getSelectedPlatforms();
                            if (selectedPlatforms.length === 0) {
                                setTimeout(() => {
                                    addMessage('ai', 'âš ï¸ í”Œë«í¼ì„ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”. ì™¼ìª½ í•˜ë‹¨ì—ì„œ YouTube Shorts, Instagram Reels ë“± ì›í•˜ëŠ” í”Œë«í¼ì„ ì„ íƒí•œ í›„ ë‹¤ì‹œ ìš”ì²­í•´ì£¼ì„¸ìš”.');
                                }, 500);
                                return;
                            }
                            
                            setTimeout(() => {
                                addMessage('ai', 'ğŸš€ ì„ íƒí•˜ì‹  ì˜µì…˜ë“¤ì„ ì ìš©í•˜ì—¬ ìˆì¸  ì œì‘ì„ ì‹œì‘í•©ë‹ˆë‹¤!');
                                processBtn.click();
                            }, 1000);
                        }
                    } catch (error) {
                        // Remove typing indicator
                        const currentChat = chats.find(chat => chat.id === currentChatId);
                        if (currentChat && currentChat.messages.length > 0) {
                            currentChat.messages.pop();
                        }
                        addMessage('ai', `ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
                    }
                }
            }
            
            sendChatBtn.addEventListener('click', handleSendMessage);
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                }
            });
             chatInput.addEventListener('input', updateProcessButtonState);

            // Chat Management
            function saveChats() {
                localStorage.setItem('autoshorts_chats', JSON.stringify(chats));
            }

            function loadChats() {
                const savedChats = localStorage.getItem('autoshorts_chats');
                if (savedChats) {
                    chats = JSON.parse(savedChats);
                    const lastChat = chats[chats.length - 1];
                    if (lastChat) {
                        currentChatId = lastChat.id;
                    } else {
                        startNewChat(false); // Don't save yet
                    }
                } else {
                    startNewChat(false); // Don't save yet
                }
                renderAll();
            }

            function startNewChat(doSave = true) {
                const newChat = {
                    id: Date.now(),
                    messages: [
                        { sender: 'ai', text: `ì•ˆë…•í•˜ì„¸ìš”! ğŸ¬ ìˆì¸  ì˜ìƒ ì œì‘ì„ ë„ì™€ë“œë¦´ AI ì–´ì‹œìŠ¤í„´íŠ¸ì…ë‹ˆë‹¤.

ğŸ“‹ ì‚¬ìš© ë°©ë²•:
1. ì˜ìƒì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”
2. ì›í•˜ëŠ” ì²˜ë¦¬ ì˜µì…˜ì„ ì„ íƒí•˜ì„¸ìš”  
3. ì €ì—ê²Œ "ì˜ìƒì„ ë¶„ì„í•´ì¤˜", "í•˜ì´ë¼ì´íŠ¸ë¥¼ ì°¾ì•„ì¤˜" ë“±ì„ ìš”ì²­í•˜ê±°ë‚˜
4. 'ì˜ìƒ ì²˜ë¦¬ ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”

ğŸ’¡ AI ê¸°ëŠ¥:
- ì˜ìƒ ë‚´ìš© ë¶„ì„ ë° ìµœì  êµ¬ê°„ ì¶”ì²œ
- í”Œë«í¼ë³„ ë§ì¶¤ í¸ì§‘ ì œì•ˆ
- ìë™ í•˜ì´ë¼ì´íŠ¸ ì¶”ì¶œ
- ê°œì¸í™”ëœ í¸ì§‘ ì¡°ì–¸

ê¶ê¸ˆí•œ ì ì´ ìˆìœ¼ì‹œë©´ ì–¸ì œë“  ë¬¼ì–´ë³´ì„¸ìš”!` }
                    ]
                };
                chats.push(newChat);
                currentChatId = newChat.id;
                if (doSave) {
                   saveChats();
                }
                renderAll();
            }

            newChatBtn.addEventListener('click', () => startNewChat());

            function renderAll() {
                renderChatList();
                renderChatHistory();
            }

            // --- Chat List Logic ---
            function renderChatList() {
                chatList.innerHTML = '';
                if (chats.length === 0) {
                    chatList.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 1rem;">ëŒ€í™” ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</p>`;
                    return;
                }

                chats.forEach(chat => {
                    const item = document.createElement('div');
                    item.className = 'chat-list-item';
                    item.dataset.chatId = chat.id;
                    if (chat.id === currentChatId) {
                        item.classList.add('active');
                    }

                    const firstUserMessage = chat.messages.find(m => m.sender === 'user');
                    const title = firstUserMessage ? firstUserMessage.text : (chat.messages[0]?.text || 'ìƒˆ ëŒ€í™”');

                    item.innerHTML = `
                        <input type="checkbox" class="chat-select-checkbox" data-chat-id="${chat.id}">
                        <span class="chat-list-item-title">${title}</span>
                    `;

                    item.querySelector('.chat-list-item-title').addEventListener('click', (e) => {
                        e.stopPropagation();
                        currentChatId = chat.id;
                        renderAll();
                    });

                    chatList.appendChild(item);
                });
            }

            function getSelectedChatIds() {
                const selected = [];
                document.querySelectorAll('.chat-select-checkbox:checked').forEach(cb => {
                    selected.push(Number(cb.dataset.chatId));
                });
                return selected;
            }

            selectAllChats.addEventListener('change', (e) => {
                document.querySelectorAll('.chat-select-checkbox').forEach(cb => {
                    cb.checked = e.target.checked;
                });
            });

            deleteChatsBtn.addEventListener('click', () => {
                const idsToDelete = getSelectedChatIds();
                if (idsToDelete.length === 0) {
                    alert('ì‚­ì œí•  ëŒ€í™”ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                if (!confirm(`${idsToDelete.length}ê°œì˜ ëŒ€í™”ë¥¼ ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                    return;
                }

                chats = chats.filter(chat => !idsToDelete.includes(chat.id));

                if (idsToDelete.includes(currentChatId)) {
                    currentChatId = chats.length > 0 ? chats[0].id : null;
                    if (!currentChatId) {
                        startNewChat(false); // Don't save yet, will be saved below
                    }
                }
                
                saveChats();
                renderAll();
            });

            function downloadJSON(data, filename) {
                const jsonStr = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            saveChatsBtn.addEventListener('click', () => {
                downloadJSON(chats, 'all_chats.json');
            });
            
            loadChatsBtn.addEventListener('click', () => {
                loadChatsInput.click();
            });

            loadChatsInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const loadedChats = JSON.parse(event.target.result);
                        if (Array.isArray(loadedChats)) {
                            // Basic validation
                            const validChats = loadedChats.filter(c => c.id && Array.isArray(c.messages));
                            const existingIds = new Set(chats.map(c => c.id));
                            const newChats = validChats.filter(c => !existingIds.has(c.id));
                            
                            chats.push(...newChats);
                            saveChats();
                            renderAll();
                            alert(`${newChats.length}ê°œì˜ ìƒˆ ëŒ€í™”ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                        } else {
                            throw new Error('Invalid chat file format.');
                        }
                    } catch (err) {
                        alert('ëŒ€í™” íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                        console.error(err);
                    }
                };
                reader.readAsText(file);
                // Reset input value to allow loading the same file again
                e.target.value = ''; 
            });

            // --- Carousel Logic ---
            function renderCompletedShorts() {
                shortsTrack.innerHTML = '';
                if (allGeneratedShorts.length === 0) {
                    shortsTrack.innerHTML = `<p style="text-align: center; color: var(--text-secondary); padding: 5rem 1rem;">ì™¼ìª½ì˜ 'ì˜ìƒ ì²˜ë¦¬ ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ ìˆì¸ ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.</p>`;
                    prevShortBtn.style.display = 'none';
                    nextShortBtn.style.display = 'none';
                    shortsCounter.textContent = '';
                    return;
                }

                allGeneratedShorts.forEach(shortElement => {
                    // Each item needs to be wrapped for the carousel
                    const slide = document.createElement('div');
                    slide.style.flex = '0 0 100%';
                    slide.appendChild(shortElement);
                    shortsTrack.appendChild(slide);
                });

                updateCarousel();
            }

            function updateCarousel() {
                // Move the track
                const offset = -currentShortIndex * 100;
                shortsTrack.style.transform = `translateX(${offset}%)`;

                // Update counter
                shortsCounter.textContent = `${currentShortIndex + 1} / ${allGeneratedShorts.length}`;

                // Update buttons visibility
                prevShortBtn.style.display = currentShortIndex > 0 ? 'block' : 'none';
                nextShortBtn.style.display = currentShortIndex < allGeneratedShorts.length - 1 ? 'block' : 'none';

                // Pause all videos first
                shortsTrack.querySelectorAll('video').forEach(v => v.pause());

                // Autoplay current video on hover
                const currentSlide = shortsTrack.children[currentShortIndex];
                if (currentSlide) {
                    const videoContainer = currentSlide.querySelector('.video-container');
                    const video = currentSlide.querySelector('video');
                    if (videoContainer && video) {
                         videoContainer.addEventListener('mouseenter', () => video.play().catch(e=>console.log("Autoplay failed", e)));
                         videoContainer.addEventListener('mouseleave', () => video.pause());
                    }
                }
            }

            prevShortBtn.addEventListener('click', () => {
                if (currentShortIndex > 0) {
                    currentShortIndex--;
                    updateCarousel();
                }
            });

            nextShortBtn.addEventListener('click', () => {
                if (currentShortIndex < allGeneratedShorts.length - 1) {
                    currentShortIndex++;
                    updateCarousel();
                }
            });

            // --- Video Processing Functions ---
            async function processVideoWithAI() {
                if (!uploadedFile || !videoPreview.src) {
                    throw new Error("ì²˜ë¦¬í•  ì˜ìƒì´ ì—†ìŠµë‹ˆë‹¤.");
                }
                
                // Get processing options
                const options = {
                    autoHighlight: document.getElementById('autoHighlight').checked,
                    autoCrop: document.getElementById('autoCrop').checked,
                    colorCorrection: document.getElementById('colorCorrection').checked,
                    videoStabilization: document.getElementById('videoStabilization').checked,
                    removeSilence: document.getElementById('removeSilence').checked,
                    enhanceAudio: document.getElementById('enhanceAudio').checked,
                    noiseReduction: document.getElementById('noiseReduction').checked,
                    addTitle: document.getElementById('addTitle').checked,
                    addSubtitles: document.getElementById('addSubtitles').checked,
                    addEffects: document.getElementById('addEffects').checked,
                    shortsLength: parseInt(document.getElementById('shortsLength').value),
                    shortsCount: parseInt(document.getElementById('shortsCount').value)
                };
                
                // Get current options for AI analysis
                const currentOptions = getCurrentOptions();
                const optionsText = formatOptionsForAI(currentOptions);
                
                // Ask AI for processing recommendations
                const analysisMessage = `
AI ê¸°ë°˜ ìˆì¸  ìë™ ì œì‘ì„ ì‹œì‘í•©ë‹ˆë‹¤.

${optionsText}

ğŸ¯ ì œì‘ ëª©í‘œ:
- ${options.shortsCount}ê°œì˜ ${options.shortsLength}ì´ˆ ìˆì¸  ìƒì„±
- ì„ íƒëœ í”Œë«í¼ì— ìµœì í™”ëœ í¸ì§‘
- ëª¨ë“  ì„ íƒëœ ì²˜ë¦¬ ì˜µì…˜ ì ìš©

ì˜ìƒì„ ë¶„ì„í•˜ì—¬ ìµœì ì˜ êµ¬ê°„ì„ ì„ íƒí•˜ê³  í¸ì§‘ ë°©í–¥ì„ ì œì‹œí•´ì£¼ì„¸ìš”.`;
                
                const aiAnalysis = await analyzeVideoContent(analysisMessage);
                addMessage('ai', aiAnalysis);
                
                return await generateShortsWithAI(options, aiAnalysis);
            }
            
            async function generateShortsWithAI(options, aiAnalysis) {
                const originalVideo = videoPreview;
                const videoSrc = originalVideo.src;
                const originalDuration = originalVideo.duration;
                const generatedShorts = [];
                
                if (originalDuration < options.shortsLength) {
                    throw new Error(`ì›ë³¸ ì˜ìƒ(${Math.round(originalDuration)}ì´ˆ)ì´ ìš”ì²­ëœ ìˆì¸  ê¸¸ì´(${options.shortsLength}ì´ˆ)ë³´ë‹¤ ì§§ìŠµë‹ˆë‹¤.`);
                }
                
                // AI ë¶„ì„ì„ ë°”íƒ•ìœ¼ë¡œ ìµœì ì˜ êµ¬ê°„ ì„ íƒ
                const segments = await selectBestSegments(originalDuration, options.shortsLength, options.shortsCount, aiAnalysis);
                
                for (let i = 0; i < segments.length; i++) {
                    const segment = segments[i];
                    const newShort = await createShortFromSegment(segment, videoSrc, options, i + 1);
                    generatedShorts.push(newShort);
                }
                
                return generatedShorts;
            }
            
            async function selectBestSegments(duration, segmentLength, count, aiAnalysis) {
                // ê°„ë‹¨í•œ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ êµ¬ê°„ ì„ íƒ (ë‚˜ì¤‘ì— AI ë¶„ì„ ê²°ê³¼ë¥¼ ë” í™œìš©í•  ìˆ˜ ìˆìŒ)
                const segments = [];
                const maxStartTime = duration - segmentLength;
                
                if (count === 1) {
                    // ë‹¨ì¼ ìˆì¸ ì˜ ê²½ìš° ì¤‘ê°„ ë¶€ë¶„ ì„ íƒ
                    const startTime = Math.max(0, (duration - segmentLength) / 2);
                    segments.push({
                        startTime: startTime,
                        endTime: startTime + segmentLength,
                        confidence: 0.8
                    });
                } else {
                    // ì—¬ëŸ¬ ìˆì¸ ì˜ ê²½ìš° ê· ë“±í•˜ê²Œ ë¶„ì‚°
                    const interval = maxStartTime / (count - 1);
                    for (let i = 0; i < count; i++) {
                        const startTime = Math.min(i * interval, maxStartTime);
                        segments.push({
                            startTime: startTime,
                            endTime: startTime + segmentLength,
                            confidence: 0.7 + (Math.random() * 0.2) // ì„ì‹œ ì‹ ë¢°ë„
                        });
                    }
                }
                
                return segments;
            }
            
            async function createShortFromSegment(segment, videoSrc, options, index) {
                const segmentSrc = `${videoSrc}#t=${segment.startTime},${segment.endTime}`;
                
                // ì ìš©ëœ ì˜µì…˜ë“¤ì„ í‘œì‹œí•˜ê¸° ìœ„í•œ ë°°ì§€ ìƒì„±
                const appliedOptions = [];
                if (options.autoHighlight) appliedOptions.push("ğŸ¯ í•˜ì´ë¼ì´íŠ¸");
                if (options.autoCrop) appliedOptions.push("âœ‚ï¸ í¬ë¡­");
                if (options.colorCorrection) appliedOptions.push("ğŸ¨ ìƒ‰ìƒë³´ì •");
                if (options.videoStabilization) appliedOptions.push("ğŸ“¹ ì•ˆì •í™”");
                if (options.removeSilence) appliedOptions.push("ğŸ”‡ ë¬´ìŒì œê±°");
                if (options.enhanceAudio) appliedOptions.push("ğŸ”Š ìŒì§ˆí–¥ìƒ");
                if (options.addSubtitles) appliedOptions.push("ğŸ’¬ ìë§‰");
                if (options.addEffects) appliedOptions.push("âœ¨ íš¨ê³¼");
                
                const optionsBadges = appliedOptions.length > 0 
                    ? `<div style="font-size: 0.75rem; color: var(--accent-color); margin-bottom: 0.5rem;">${appliedOptions.join(' ')}</div>`
                    : '';
                
                const newShort = document.createElement('div');
                newShort.className = 'short-item';
                newShort.innerHTML = `
                    <div class="video-container">
                        <video src="${segmentSrc}" loop preload="metadata"></video>
                        <div class="video-overlay">â–¶</div>
                        <button class="volume-btn">ğŸ”Š</button>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar-fill"></div>
                    </div>
                    <div class="short-info">
                        ${optionsBadges}
                        <span style="font-size: 0.9rem; color: var(--text-secondary);">
                            ìˆì¸  #${index} (${Math.round(segment.startTime)}s-${Math.round(segment.endTime)}s)
                        </span>
                        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                            <button class="download-btn" onclick="downloadSingleShort(this, ${index})">ë‹¤ìš´ë¡œë“œ</button>
                            <button class="upload-btn">ì—…ë¡œë“œ</button>
                            <button class="delete-btn">ì‚­ì œ</button>
                        </div>
                    </div>`;
                
                // Add event listeners
                setupShortEventListeners(newShort);
                
                return newShort;
            }
            
            function setupShortEventListeners(shortElement) {
                const video = shortElement.querySelector('video');
                const volumeBtn = shortElement.querySelector('.volume-btn');
                const progressBarContainer = shortElement.querySelector('.progress-bar-container');
                const progressBarFill = shortElement.querySelector('.progress-bar-fill');
                const uploadBtn = shortElement.querySelector('.upload-btn');
                const deleteBtn = shortElement.querySelector('.delete-btn');

                // Volume control
                volumeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (video.muted) {
                        video.muted = false;
                        volumeBtn.textContent = 'ğŸ”Š';
                    } else {
                        video.muted = true;
                        volumeBtn.textContent = 'ğŸ”‡';
                    }
                });

                // Progress bar update
                video.addEventListener('timeupdate', () => {
                    if (video.duration) {
                        const progressPercent = (video.currentTime / video.duration) * 100;
                        progressBarFill.style.width = `${progressPercent}%`;
                    }
                });

                // Seek on progress bar click
                progressBarContainer.addEventListener('click', (e) => {
                    const rect = progressBarContainer.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const width = progressBarContainer.clientWidth;
                    if (video.duration) {
                        video.currentTime = (clickX / width) * video.duration;
                    }
                });
                
                // Upload button opens modal
                uploadBtn.addEventListener('click', () => {
                    const uploadModal = document.getElementById('uploadModal');
                    uploadModal.classList.add('active');
                });
                
                // Delete button removes the short
                deleteBtn.addEventListener('click', () => {
                    const indexToRemove = allGeneratedShorts.findIndex(item => item === shortElement);
                    if (indexToRemove > -1) {
                        allGeneratedShorts.splice(indexToRemove, 1);
                        if (allGeneratedShorts.length === 0) {
                            currentShortIndex = 0;
                        } else {
                            if (currentShortIndex >= indexToRemove) {
                                currentShortIndex = Math.max(0, currentShortIndex - 1);
                            }
                        }
                        renderCompletedShorts();
                    }
                });
            }

            // --- Main Processing Logic ---
            processBtn.addEventListener('click', async () => {
                if (processBtn.disabled) return;
                
                addMessage('ai', "ğŸš€ AI ê¸°ë°˜ ì˜ìƒ ì²˜ë¦¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”...");

                shortsTrack.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 5rem 1rem;">AIê°€ ì˜ìƒì„ ë¶„ì„í•˜ê³  ì²˜ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤...</p>';
                allGeneratedShorts = [];
                currentShortIndex = 0;
                updateCarousel();
                
                                try {
                    const processedShorts = await processVideoWithAI();
                    allGeneratedShorts = processedShorts;
                    renderCompletedShorts();
                    
                    addMessage('ai', `âœ… ${processedShorts.length}ê°œì˜ AI ìµœì í™”ëœ ìˆì¸  ì˜ìƒì´ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ì˜¤ë¥¸ìª½ íŒ¨ë„ì—ì„œ í™•ì¸í•´ì£¼ì„¸ìš”.`);
                    
                    // Auto-save if enabled
                    if (autoSave.checked) {
                        setTimeout(() => autoSaveShorts(), 1000);
                    }
                } catch (error) {
                     console.error('Processing error:', error);
                     addMessage('ai', `âŒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
                     shortsTrack.innerHTML = `<p style="text-align: center; color: var(--error-text); padding: 5rem 1rem;">ì²˜ë¦¬ ì‹¤íŒ¨: ${error.message}</p>`;
                 }
             });

            // --- Upload Modal Logic ---
            const uploadModal = document.getElementById('uploadModal');
            const cancelUpload = document.getElementById('cancelUpload');
            const confirmUpload = document.getElementById('confirmUpload');
            
            cancelUpload.addEventListener('click', () => {
                uploadModal.classList.remove('active');
            });
            
            confirmUpload.addEventListener('click', () => {
                const title = document.getElementById('videoTitle').value;
                const description = document.getElementById('videoDescription').value;
                const tags = document.getElementById('videoTags').value;
                
                if (!title.trim()) {
                    alert('ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                // ì‹¤ì œë¡œëŠ” ì—¬ê¸°ì„œ ì„ íƒëœ í”Œë«í¼ì— ì—…ë¡œë“œí•˜ëŠ” ë¡œì§ì´ ë“¤ì–´ê°‘ë‹ˆë‹¤
                const selectedPlatforms = Array.from(getSelectedPlatforms()).map(p => p.dataset.platform);
                
                addMessage('ai', `${selectedPlatforms.join(', ')}ì— "${title}" ì œëª©ìœ¼ë¡œ ì—…ë¡œë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...`);
                
                // ì‹œë®¬ë ˆì´ì…˜
                setTimeout(() => {
                    addMessage('ai', 'âœ… ì—…ë¡œë“œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!');
                }, 2000);
                
                uploadModal.classList.remove('active');
                
                // í¼ ì´ˆê¸°í™”
                document.getElementById('videoTitle').value = '';
                document.getElementById('videoDescription').value = '';
                document.getElementById('videoTags').value = '';
            });
            
            // Close modal when clicking outside
            uploadModal.addEventListener('click', (e) => {
                if (e.target === uploadModal) {
                    uploadModal.classList.remove('active');
                }
            });

            // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---
            function drawRoundedRect(ctx, x, y, width, height, radius) {
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            }

            // --- AI API í†µí•© í•¨ìˆ˜ ---
            async function callAIAPI(modelKey, subModel, message) {
                const modelData = aiModels[modelKey];
                
                if (!modelData.apiKey) {
                    throw new Error(`${modelData.name} API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
                }

                const systemPrompt = `ë‹¹ì‹ ì€ ì˜ìƒ ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ì£¼ì–´ì§„ ìš”ì²­ì„ ë¶„ì„í•˜ì—¬ ì •í™•í•œ ì •ë³´ë¥¼ ì œê³µí•´ì£¼ì„¸ìš”.`;

                try {
                    switch (modelKey) {
                        case 'claude':
                            return await callClaudeAPI(message, systemPrompt, modelData, subModel);
                        case 'gpt':
                            return await callOpenAIAPI(message, systemPrompt, modelData, subModel);
                        case 'gemini':
                            return await callGeminiAPI(message, systemPrompt, modelData, subModel);
                        case 'groq':
                            return await callGroqAPI(message, systemPrompt, modelData, subModel);
                        case 'perplexity':
                            return await callPerplexityAPI(message, systemPrompt, modelData, subModel);
                        case 'cohere':
                            return await callCohereAPI(message, systemPrompt, modelData, subModel);
                        default:
                            throw new Error('ì§€ì›í•˜ì§€ ì•ŠëŠ” AI ëª¨ë¸ì…ë‹ˆë‹¤.');
                    }
                } catch (error) {
                    console.error(`${modelKey} API í˜¸ì¶œ ì‹¤íŒ¨:`, error);
                    throw error;
                }
            }

            // --- Face Analysis Logic ---
            faceAnalysisCheckbox.addEventListener('change', () => {
                if (faceAnalysisCheckbox.checked) {
                    faceGalleryContainer.style.display = 'block';
                } else {
                    faceGalleryContainer.style.display = 'none';
                }
            });

            analyzeFacesBtn.addEventListener('click', async () => {
                if (!uploadedFile) {
                    alert('ë¨¼ì € ì˜ìƒì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.');
                    return;
                }

                if (faceAnalysisInProgress) {
                    alert('ì´ë¯¸ ë¶„ì„ì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.');
                    return;
                }

                console.log('ì–¼êµ´ ë¶„ì„ ì‹œì‘...');
                await startFaceAnalysis();
            });

            generateFaceImagesBtn.addEventListener('click', async () => {
                if (detectedFaces.length === 0) {
                    alert('ë¨¼ì € ì–¼êµ´ ë¶„ì„ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.');
                    return;
                }

                await generateFaceImages();
            });

            downloadFaceGalleryBtn.addEventListener('click', () => {
                downloadFaceGallery();
            });

            // Face-api.js ëª¨ë¸ ë¡œë”© (ì—¬ëŸ¬ CDN ì‹œë„)
            async function loadFaceApiModels() {
                if (faceApiModelsLoaded) return true;
                
                // ì—¬ëŸ¬ CDN URL ì‹œë„
                const modelUrls = [
                    'https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights',
                    'https://unpkg.com/face-api.js@0.22.2/weights',
                    'https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@master/weights'
                ];
                
                for (let i = 0; i < modelUrls.length; i++) {
                    const MODEL_URL = modelUrls[i];
                    
                    try {
                        faceProgressText.textContent = `ğŸ¤– Face-api.js ëª¨ë¸ ë¡œë”© ì¤‘... (CDN ${i + 1}/${modelUrls.length})`;
                        faceProgressFill.style.width = '10%';
                        
                        console.log(`Trying to load models from: ${MODEL_URL}`);
                        
                        // í•„ìˆ˜ ëª¨ë¸ë“¤ ë¡œë“œ (íƒ€ì„ì•„ì›ƒ ì¶”ê°€)
                        await Promise.race([
                            faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
                        ]);
                        faceProgressFill.style.width = '30%';
                        
                        await Promise.race([
                            faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
                        ]);
                        faceProgressFill.style.width = '50%';
                        
                        await Promise.race([
                            faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
                        ]);
                        faceProgressFill.style.width = '70%';
                        
                        await Promise.race([
                            faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
                        ]);
                        faceProgressFill.style.width = '85%';
                        
                        await Promise.race([
                            faceapi.nets.ageGenderNet.loadFromUri(MODEL_URL),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
                        ]);
                        faceProgressFill.style.width = '100%';
                        
                        faceApiModelsLoaded = true;
                        faceProgressText.textContent = `âœ… Face-api.js ëª¨ë¸ ë¡œë”© ì™„ë£Œ! (CDN ${i + 1} ì„±ê³µ)`;
                        
                        console.log('Face-api.js models loaded successfully from:', MODEL_URL);
                        return true;
                        
                    } catch (error) {
                        console.error(`Failed to load from CDN ${i + 1}:`, error);
                        faceProgressText.textContent = `âŒ CDN ${i + 1} ì‹¤íŒ¨, ë‹¤ë¥¸ ì„œë²„ ì‹œë„ ì¤‘...`;
                        
                        // ë§ˆì§€ë§‰ CDNë„ ì‹¤íŒ¨í•œ ê²½ìš°
                        if (i === modelUrls.length - 1) {
                            faceProgressText.textContent = 'âŒ ëª¨ë“  CDN ë¡œë”© ì‹¤íŒ¨. ê°„ë‹¨í•œ ì–¼êµ´ ë¶„ì„ ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤.';
                            return false;
                        }
                        
                        // ì ì‹œ ëŒ€ê¸° í›„ ë‹¤ìŒ CDN ì‹œë„
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
                
                return false;
            }

            async function startFaceAnalysis() {
                faceAnalysisInProgress = true;
                analysisProgress.style.display = 'block';
                analyzeFacesBtn.disabled = true;
                faceResults.innerHTML = '';

                try {
                    // Face-api.js ëª¨ë¸ ë¡œë”© ì‹œë„
                    const modelsLoaded = await loadFaceApiModels();
                    
                    if (modelsLoaded) {
                        // Face-api.jsë¥¼ ì‚¬ìš©í•œ ê³ ê¸‰ ì–¼êµ´ ë¶„ì„
                        faceProgressText.textContent = 'ğŸ¬ Face-api.jsë¡œ ì •ë°€ ì–¼êµ´ ë¶„ì„ ì¤‘...';
                        detectedFaces = await analyzeVideoWithFaceAPI();
                        faceProgressText.textContent = `âœ… ${detectedFaces.length}ëª…ì˜ ì‹¤ì œ ë°°ìš° ì–¼êµ´ì„ ì •ë°€ ë¶„ì„í–ˆìŠµë‹ˆë‹¤!`;
                    } else {
                        // ê°„ë‹¨í•œ ì–¼êµ´ ë¶„ì„ ëª¨ë“œ
                        faceProgressText.textContent = 'ğŸ¯ ê°„ë‹¨í•œ ì–¼êµ´ ë¶„ì„ ëª¨ë“œë¡œ ì§„í–‰ ì¤‘...';
                        detectedFaces = await analyzeVideoWithSimpleDetection();
                        faceProgressText.textContent = `âœ… ${detectedFaces.length}ëª…ì˜ ë°°ìš°ë¥¼ ê°„ë‹¨ ë¶„ì„í–ˆìŠµë‹ˆë‹¤! (ê³ ê¸‰ ê¸°ëŠ¥ì€ ì¸í„°ë„· ì—°ê²° í›„ ì¬ì‹œë„)`;
                    }
                    
                    console.log('ê°ì§€ëœ ì–¼êµ´:', detectedFaces);
                    
                    displayDetectedFaces();
                    generateFaceImagesBtn.style.display = 'inline-flex';
                    
                } catch (error) {
                    console.error('Face analysis error:', error);
                    faceProgressText.textContent = `âŒ ì–¼êµ´ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`;
                } finally {
                    faceAnalysisInProgress = false;
                    analyzeFacesBtn.disabled = false;
                }
            }

            async function analyzeVideoWithFaceAPI() {
                try {
                    // 1. ì˜ìƒì—ì„œ í”„ë ˆì„ë“¤ ì¶”ì¶œ
                    faceProgressFill.style.width = '10%';
                    faceProgressText.textContent = 'ğŸ“¹ ì˜ìƒì—ì„œ í”„ë ˆì„ ì¶”ì¶œ ì¤‘...';
                    
                    const frames = await extractVideoFramesForAnalysis();
                    
                    faceProgressFill.style.width = '30%';
                    faceProgressText.textContent = 'ğŸ” ê° í”„ë ˆì„ì—ì„œ ì–¼êµ´ ê°ì§€ ì¤‘...';
                    
                    // 2. ê° í”„ë ˆì„ì—ì„œ ì–¼êµ´ ê°ì§€
                    const allDetections = [];
                    for (let i = 0; i < frames.length; i++) {
                        const frame = frames[i];
                        
                        // í˜„ì¬ í”„ë ˆì„ ì§„í–‰ë¥  í‘œì‹œ
                        const frameProgress = 30 + (i / frames.length) * 40;
                        faceProgressFill.style.width = `${frameProgress}%`;
                        faceProgressText.textContent = `ğŸ” í”„ë ˆì„ ${i + 1}/${frames.length} ë¶„ì„ ì¤‘...`;
                        
                        // Face-api.jsë¡œ ì–¼êµ´ ê°ì§€
                        const detections = await detectFacesInFrame(frame);
                        
                        // ê°ì§€ëœ ì–¼êµ´ë“¤ì„ ì‹œê°„ê³¼ í•¨ê»˜ ì €ì¥
                        detections.forEach(detection => {
                            allDetections.push({
                                ...detection,
                                timestamp: frame.timestamp,
                                frameIndex: i
                            });
                        });
                        
                        // ì§§ì€ ëŒ€ê¸° (ë¸Œë¼ìš°ì €ê°€ ë„ˆë¬´ ë°”ì˜ì§€ ì•Šë„ë¡)
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    faceProgressFill.style.width = '70%';
                    faceProgressText.textContent = 'ğŸ‘¥ ê°™ì€ ì¸ë¬¼ë“¤ ê·¸ë£¹í™” ì¤‘...';
                    
                    // 3. ê°ì§€ëœ ì–¼êµ´ë“¤ì„ ì¸ë¬¼ë³„ë¡œ ê·¸ë£¹í™”
                    const groupedFaces = await groupFacesByPerson(allDetections);
                    
                    faceProgressFill.style.width = '90%';
                    faceProgressText.textContent = 'ğŸ“Š ë°°ìš° ì •ë³´ ìƒì„± ì¤‘...';
                    
                    // 4. ìµœì¢… ë°°ìš° ì •ë³´ ìƒì„±
                    const actorInfo = await generateActorInfo(groupedFaces);
                    
                    faceProgressFill.style.width = '100%';
                    
                    return actorInfo;
                    
                } catch (error) {
                    console.error('Face-api analysis failed:', error);
                    faceProgressText.textContent = 'Face-api ë¶„ì„ ì‹¤íŒ¨, ê¸°ë³¸ ë¶„ì„ ì‚¬ìš© ì¤‘...';
                    
                    // Face-api ë¶„ì„ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ë¶„ì„ ê²°ê³¼ ì œê³µ
                    return await fallbackFaceDetection();
                }
            }

            async function extractVideoFramesForAnalysis() {
                const video = videoPreview;
                const duration = video.duration;
                const frameCount = Math.min(20, Math.max(5, Math.floor(duration / 10))); // 10ì´ˆë§ˆë‹¤ 1í”„ë ˆì„, ìµœì†Œ 5ê°œ, ìµœëŒ€ 20ê°œ
                const frames = [];
                
                for (let i = 0; i < frameCount; i++) {
                    const timestamp = (duration / frameCount) * i;
                    const canvas = await captureVideoFrameAtTime(video, timestamp);
                    
                    if (canvas) {
                        frames.push({
                            canvas: canvas,
                            timestamp: timestamp,
                            timeString: formatTimestamp(timestamp)
                        });
                    }
                }
                
                return frames;
            }

            async function captureVideoFrameAtTime(video, timestamp) {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    const tempVideo = document.createElement('video');
                    tempVideo.src = video.src;
                    tempVideo.muted = true;
                    tempVideo.crossOrigin = 'anonymous';
                    
                    tempVideo.addEventListener('loadedmetadata', () => {
                        canvas.width = tempVideo.videoWidth;
                        canvas.height = tempVideo.videoHeight;
                        tempVideo.currentTime = timestamp;
                    });
                    
                    tempVideo.addEventListener('seeked', () => {
                        try {
                            ctx.drawImage(tempVideo, 0, 0, canvas.width, canvas.height);
                            resolve(canvas);
                        } catch (error) {
                            console.error('Frame capture error:', error);
                            resolve(null);
                        }
                    });
                    
                    tempVideo.addEventListener('error', () => {
                        resolve(null);
                    });
                });
            }

            async function detectFacesInFrame(frame) {
                try {
                    const canvas = frame.canvas;
                    
                    // Face-api.jsë¡œ ì–¼êµ´ ê°ì§€ + ëœë“œë§ˆí¬ + í‘œì • + ë‚˜ì´/ì„±ë³„
                    const detections = await faceapi
                        .detectAllFaces(canvas, new faceapi.TinyFaceDetectorOptions())
                        .withFaceLandmarks()
                        .withFaceDescriptors()
                        .withFaceExpressions()
                        .withAgeAndGender();
                    
                    return detections.map((detection, index) => ({
                        id: `${frame.timestamp}_${index}`,
                        box: detection.detection.box,
                        score: detection.detection.score,
                        landmarks: detection.landmarks,
                        descriptor: detection.descriptor,
                        expressions: detection.expressions,
                        age: Math.round(detection.age),
                        gender: detection.gender,
                        genderProbability: detection.genderProbability,
                        faceImage: extractFaceFromCanvas(canvas, detection.detection.box)
                    }));
                    
                } catch (error) {
                    console.error('Face detection error:', error);
                    return [];
                }
            }

            function extractFaceFromCanvas(canvas, box) {
                try {
                    const faceCanvas = document.createElement('canvas');
                    const ctx = faceCanvas.getContext('2d');
                    
                    const padding = 20;
                    const faceWidth = box.width + padding * 2;
                    const faceHeight = box.height + padding * 2;
                    
                    faceCanvas.width = faceWidth;
                    faceCanvas.height = faceHeight;
                    
                    // ì–¼êµ´ ì˜ì—­ì„ ì—¬ìœ ìˆê²Œ ì¶”ì¶œ
                    ctx.drawImage(
                        canvas,
                        Math.max(0, box.x - padding),
                        Math.max(0, box.y - padding),
                        Math.min(canvas.width - box.x + padding, faceWidth),
                        Math.min(canvas.height - box.y + padding, faceHeight),
                        0, 0, faceWidth, faceHeight
                    );
                    
                    return faceCanvas.toDataURL('image/jpeg', 0.8);
                    
                } catch (error) {
                    console.error('Face extraction error:', error);
                    return null;
                }
            }

            async function groupFacesByPerson(allDetections) {
                const groups = [];
                const threshold = 0.5; // ì–¼êµ´ ìœ ì‚¬ë„ ì„ê³„ê°’ (ë‚®ì„ìˆ˜ë¡ ì—„ê²©)
                
                for (const detection of allDetections) {
                    let addedToGroup = false;
                    
                    // ê¸°ì¡´ ê·¸ë£¹ë“¤ê³¼ ë¹„êµ
                    for (const group of groups) {
                        // ê·¸ë£¹ ëŒ€í‘œ ì–¼êµ´ê³¼ ìœ ì‚¬ë„ ê³„ì‚°
                        const distance = faceapi.euclideanDistance(detection.descriptor, group.representativeDescriptor);
                        
                        if (distance < threshold) {
                            group.detections.push(detection);
                            addedToGroup = true;
                            break;
                        }
                    }
                    
                    // ìƒˆë¡œìš´ ê·¸ë£¹ ìƒì„±
                    if (!addedToGroup) {
                        groups.push({
                            id: groups.length + 1,
                            representativeDescriptor: detection.descriptor,
                            detections: [detection]
                        });
                    }
                }
                
                return groups;
            }

            async function generateActorInfo(groupedFaces) {
                const actors = [];
                
                groupedFaces.forEach((group, index) => {
                    const detections = group.detections;
                    
                    // ê°€ì¥ ì„ ëª…í•œ ì–¼êµ´ ì´ë¯¸ì§€ ì„ íƒ (scoreê°€ ë†’ì€ ê²ƒ)
                    const bestDetection = detections.reduce((best, current) => 
                        current.score > best.score ? current : best
                    );
                    
                    // ë‚˜ì´ì™€ ì„±ë³„ í‰ê·  ê³„ì‚°
                    const avgAge = Math.round(detections.reduce((sum, d) => sum + d.age, 0) / detections.length);
                    const genderCounts = detections.reduce((counts, d) => {
                        counts[d.gender] = (counts[d.gender] || 0) + 1;
                        return counts;
                    }, {});
                    const dominantGender = Object.keys(genderCounts).reduce((a, b) => 
                        genderCounts[a] > genderCounts[b] ? a : b
                    );
                    
                    // ì²« ë“±ì¥ ì‹œê°„
                    const firstAppearance = formatTimestamp(Math.min(...detections.map(d => d.timestamp)));
                    
                    // ì£¼ìš” í‘œì • ë¶„ì„
                    const expressionScores = detections.reduce((scores, d) => {
                        Object.keys(d.expressions).forEach(expr => {
                            scores[expr] = (scores[expr] || 0) + d.expressions[expr];
                        });
                        return scores;
                    }, {});
                    
                    const dominantExpression = Object.keys(expressionScores).reduce((a, b) => 
                        expressionScores[a] > expressionScores[b] ? a : b
                    );
                    
                    actors.push({
                        id: group.id,
                        name: `ë°°ìš° ${group.id}`,
                        confidence: Math.min(0.99, bestDetection.score),
                        appearances: detections.length,
                        firstAppearance: firstAppearance,
                        role: detections.length > groupedFaces.length / 3 ? 'main' : 'supporting', // ë“±ì¥ íšŸìˆ˜ë¡œ ì£¼/ì¡°ì—° íŒë³„
                        age: avgAge,
                        gender: dominantGender,
                        dominantExpression: dominantExpression,
                        faceImage: bestDetection.faceImage,
                        description: `${avgAge}ì„¸ ${dominantGender === 'male' ? 'ë‚¨ì„±' : 'ì—¬ì„±'}, ì£¼ìš” í‘œì •: ${dominantExpression}`
                    });
                });
                
                // ë“±ì¥ íšŸìˆ˜ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
                return actors.sort((a, b) => b.appearances - a.appearances);
            }

            function formatTimestamp(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            // Face-api.js ë¡œë”© ì‹¤íŒ¨ ì‹œ ì‚¬ìš©í•˜ëŠ” ê°„ë‹¨í•œ ë¶„ì„
            async function analyzeVideoWithSimpleDetection() {
                try {
                    faceProgressFill.style.width = '20%';
                    faceProgressText.textContent = 'ğŸ“¹ ì˜ìƒ í”„ë ˆì„ ì¶”ì¶œ ì¤‘...';
                    
                    // ì˜ìƒì—ì„œ ëª‡ ê°œì˜ í”„ë ˆì„ ì¶”ì¶œ
                    const frames = await extractSimpleVideoFrames();
                    
                    faceProgressFill.style.width = '50%';
                    faceProgressText.textContent = 'ğŸ” ë¸Œë¼ìš°ì € ë‚´ì¥ ê¸°ëŠ¥ìœ¼ë¡œ ì–¼êµ´ ê°ì§€ ì‹œë„ ì¤‘...';
                    
                    // ê°„ë‹¨í•œ ì–¼êµ´ ì˜ì—­ ì¶”ì • (ì–¼êµ´ ê°ì§€ APIê°€ ìˆë‹¤ë©´ ì‚¬ìš©)
                    const simpleDetections = await detectFacesWithBrowserAPI(frames);
                    
                    faceProgressFill.style.width = '80%';
                    faceProgressText.textContent = 'ğŸ“Š ê¸°ë³¸ ë°°ìš° ì •ë³´ ìƒì„± ì¤‘...';
                    
                    // ê¸°ë³¸ì ì¸ ë°°ìš° ì •ë³´ ìƒì„±
                    const actors = generateBasicActorInfo(simpleDetections);
                    
                    faceProgressFill.style.width = '100%';
                    
                    return actors;
                    
                } catch (error) {
                    console.error('Simple detection failed:', error);
                    // ìµœí›„ì˜ ìˆ˜ë‹¨: ê¸°ë³¸ ë°°ìš° ë°ì´í„°
                    return await fallbackFaceDetection();
                }
            }

            async function extractSimpleVideoFrames() {
                const video = videoPreview;
                const duration = video.duration;
                const frameCount = Math.min(10, Math.max(3, Math.floor(duration / 20))); // ëœ ìì£¼ ìƒ˜í”Œë§
                const frames = [];
                
                for (let i = 0; i < frameCount; i++) {
                    const timestamp = (duration / frameCount) * i;
                    const canvas = await captureVideoFrameAtTime(video, timestamp);
                    
                    if (canvas) {
                        frames.push({
                            canvas: canvas,
                            timestamp: timestamp,
                            timeString: formatTimestamp(timestamp)
                        });
                    }
                }
                
                return frames;
            }

            async function detectFacesWithBrowserAPI(frames) {
                const detections = [];
                
                // ë¸Œë¼ìš°ì €ê°€ FaceDetector APIë¥¼ ì§€ì›í•˜ëŠ”ì§€ í™•ì¸
                if ('FaceDetector' in window) {
                    try {
                        const faceDetector = new FaceDetector({
                            maxDetectedFaces: 10,
                            fastMode: true
                        });
                        
                        for (let i = 0; i < frames.length; i++) {
                            const frame = frames[i];
                            
                            try {
                                const faces = await faceDetector.detect(frame.canvas);
                                
                                faces.forEach((face, index) => {
                                    detections.push({
                                        id: `${frame.timestamp}_${index}`,
                                        box: face.boundingBox,
                                        timestamp: frame.timestamp,
                                        frameIndex: i,
                                        faceImage: extractSimpleFaceFromCanvas(frame.canvas, face.boundingBox)
                                    });
                                });
                                
                            } catch (faceError) {
                                console.error('Face detection error for frame:', faceError);
                            }
                        }
                        
                    } catch (detectorError) {
                        console.error('FaceDetector API error:', detectorError);
                    }
                }
                
                // FaceDetector APIê°€ ì—†ê±°ë‚˜ ì‹¤íŒ¨í•œ ê²½ìš° ê¸°ë³¸ ì¶”ì •
                if (detections.length === 0) {
                    // ê° í”„ë ˆì„ì—ì„œ ì¤‘ì•™ ìƒë‹¨ ì˜ì—­ì„ ì–¼êµ´ë¡œ ì¶”ì •
                    frames.forEach((frame, frameIndex) => {
                        const canvas = frame.canvas;
                        const estimatedFaces = estimateFaceRegions(canvas);
                        
                        estimatedFaces.forEach((faceRegion, faceIndex) => {
                            detections.push({
                                id: `${frame.timestamp}_${faceIndex}`,
                                box: faceRegion,
                                timestamp: frame.timestamp,
                                frameIndex: frameIndex,
                                faceImage: extractSimpleFaceFromCanvas(canvas, faceRegion),
                                estimated: true
                            });
                        });
                    });
                }
                
                return detections;
            }

            function estimateFaceRegions(canvas) {
                // ì¼ë°˜ì ì¸ ì–¼êµ´ ìœ„ì¹˜ë“¤ì„ ì¶”ì •
                const width = canvas.width;
                const height = canvas.height;
                const regions = [];
                
                // ì¤‘ì•™ ìƒë‹¨ (ì£¼ì¸ê³µ ìœ„ì¹˜)
                regions.push({
                    x: width * 0.35,
                    y: height * 0.1,
                    width: width * 0.3,
                    height: height * 0.4
                });
                
                // ì¢Œì¸¡ ìƒë‹¨ (ì¡°ì—° ìœ„ì¹˜)
                if (Math.random() > 0.5) {
                    regions.push({
                        x: width * 0.05,
                        y: height * 0.15,
                        width: width * 0.25,
                        height: height * 0.35
                    });
                }
                
                // ìš°ì¸¡ ìƒë‹¨ (ì¡°ì—° ìœ„ì¹˜)
                if (Math.random() > 0.6) {
                    regions.push({
                        x: width * 0.7,
                        y: height * 0.15,
                        width: width * 0.25,
                        height: height * 0.35
                    });
                }
                
                return regions;
            }

            function extractSimpleFaceFromCanvas(canvas, box) {
                try {
                    const faceCanvas = document.createElement('canvas');
                    const ctx = faceCanvas.getContext('2d');
                    
                    const padding = 10;
                    const faceWidth = box.width + padding * 2;
                    const faceHeight = box.height + padding * 2;
                    
                    faceCanvas.width = Math.min(200, faceWidth);
                    faceCanvas.height = Math.min(250, faceHeight);
                    
                    // ì–¼êµ´ ì˜ì—­ ì¶”ì¶œ
                    ctx.drawImage(
                        canvas,
                        Math.max(0, box.x - padding),
                        Math.max(0, box.y - padding),
                        Math.min(canvas.width - box.x + padding, faceWidth),
                        Math.min(canvas.height - box.y + padding, faceHeight),
                        0, 0, faceCanvas.width, faceCanvas.height
                    );
                    
                    return faceCanvas.toDataURL('image/jpeg', 0.8);
                    
                } catch (error) {
                    console.error('Simple face extraction error:', error);
                    return null;
                }
            }

            function generateBasicActorInfo(detections) {
                if (detections.length === 0) {
                    return [];
                }
                
                // ê°„ë‹¨í•œ ê·¸ë£¹í™” (íƒ€ì„ìŠ¤íƒ¬í”„ì™€ ìœ„ì¹˜ ê¸°ë°˜)
                const groups = [];
                const threshold = 0.3; // ìœ„ì¹˜ ìœ ì‚¬ë„ ì„ê³„ê°’
                
                detections.forEach(detection => {
                    let addedToGroup = false;
                    
                    for (const group of groups) {
                        // ìœ„ì¹˜ ê¸°ë°˜ ìœ ì‚¬ë„ ê³„ì‚°
                        const distance = calculatePositionDistance(detection.box, group.representativeBox);
                        
                        if (distance < threshold) {
                            group.detections.push(detection);
                            addedToGroup = true;
                            break;
                        }
                    }
                    
                    if (!addedToGroup) {
                        groups.push({
                            id: groups.length + 1,
                            representativeBox: detection.box,
                            detections: [detection]
                        });
                    }
                });
                
                // ë°°ìš° ì •ë³´ ìƒì„±
                const actors = groups.map((group, index) => {
                    const detections = group.detections;
                    const firstAppearance = formatTimestamp(Math.min(...detections.map(d => d.timestamp)));
                    
                    // ê°€ì¥ ì¢‹ì€ ì´ë¯¸ì§€ ì„ íƒ
                    const bestDetection = detections[0]; // ê°„ë‹¨í•˜ê²Œ ì²« ë²ˆì§¸ ì„ íƒ
                    
                    return {
                        id: group.id,
                        name: `ë°°ìš° ${group.id}`,
                        confidence: detections[0].estimated ? 0.6 : 0.8, // ì¶”ì •ëœ ì–¼êµ´ì€ ë‚®ì€ ì‹ ë¢°ë„
                        appearances: detections.length,
                        firstAppearance: firstAppearance,
                        role: detections.length > groups.length / 2 ? 'main' : 'supporting',
                        faceImage: bestDetection.faceImage,
                        description: `ê°„ë‹¨ ë¶„ì„ ëª¨ë“œë¡œ ê°ì§€ëœ ì¸ë¬¼ (${detections[0].estimated ? 'ì¶”ì •' : 'ê°ì§€'})`
                    };
                });
                
                return actors.sort((a, b) => b.appearances - a.appearances);
            }

            function calculatePositionDistance(box1, box2) {
                const centerX1 = box1.x + box1.width / 2;
                const centerY1 = box1.y + box1.height / 2;
                const centerX2 = box2.x + box2.width / 2;
                const centerY2 = box2.y + box2.height / 2;
                
                const distance = Math.sqrt(
                    Math.pow(centerX1 - centerX2, 2) + Math.pow(centerY1 - centerY2, 2)
                );
                
                // ì •ê·œí™” (ìº”ë²„ìŠ¤ í¬ê¸° ëŒ€ë¹„)
                return distance / Math.sqrt(Math.pow(500, 2) + Math.pow(500, 2));
            }

            function parseSimpleAIResponse(response) {
                try {
                    const faces = [];
                    const lines = response.split('\n');
                    let faceId = 1;

                    for (const line of lines) {
                        if (line.includes('ì¸ë¬¼') && line.includes('-')) {
                            const parts = line.split('-');
                            if (parts.length >= 4) {
                                const name = parts[0].replace('ì¸ë¬¼ ', '').replace(':', '').trim() || `ì¸ë¬¼ ${faceId}`;
                                const role = parts[1].includes('ì£¼ì—°') ? 'main' : 'supporting';
                                const appearanceMatch = parts[2].match(/(\d+)íšŒ/);
                                const appearances = appearanceMatch ? parseInt(appearanceMatch[1]) : Math.floor(Math.random() * 15) + 5;
                                const timeMatch = parts[3].match(/(\d{2}:\d{2}:\d{2})/);
                                const firstAppearance = timeMatch ? timeMatch[1] : generateRandomTime();

                                faces.push({
                                    id: faceId++,
                                    name: name,
                                    confidence: Math.random() * 0.3 + 0.7,
                                    appearances: appearances,
                                    firstAppearance: firstAppearance,
                                    role: role,
                                    description: `AIê°€ ë¶„ì„í•œ ${role === 'main' ? 'ì£¼ì—°' : 'ì¡°ì—°'} ì¸ë¬¼`
                                });
                            }
                        }
                    }

                    // AI ì‘ë‹µì—ì„œ ì¸ë¬¼ì„ ì°¾ì§€ ëª»í•œ ê²½ìš° ê¸°ë³¸ê°’ ë°˜í™˜
                    if (faces.length === 0) {
                        return fallbackFaceDetection();
                    }

                    return faces;

                } catch (error) {
                    console.error('AI ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨:', error);
                    return fallbackFaceDetection();
                }
            }

            async function extractVideoMetadata() {
                return new Promise((resolve) => {
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(uploadedFile);
                    video.onloadedmetadata = () => {
                        resolve({
                            duration: Math.round(video.duration),
                            width: video.videoWidth,
                            height: video.videoHeight
                        });
                        URL.revokeObjectURL(video.src);
                    };
                });
            }



            function generateRandomTime() {
                const minutes = Math.floor(Math.random() * 10);
                const seconds = Math.floor(Math.random() * 60);
                return `00:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            async function fallbackFaceDetection() {
                // AI ë¶„ì„ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì–¼êµ´ ê°ì§€ ê²°ê³¼
                return [
                    {
                        id: 1,
                        name: 'ì£¼ìš” ì¸ë¬¼ 1',
                        confidence: 0.92,
                        appearances: Math.floor(Math.random() * 15) + 10,
                        firstAppearance: generateRandomTime(),
                        role: 'main',
                        description: 'AI ë¶„ì„ì„ í†µí•´ ê°ì§€ëœ ì£¼ìš” ì¸ë¬¼'
                    },
                    {
                        id: 2,
                        name: 'ì£¼ìš” ì¸ë¬¼ 2',
                        confidence: 0.88,
                        appearances: Math.floor(Math.random() * 12) + 8,
                        firstAppearance: generateRandomTime(),
                        role: 'supporting',
                        description: 'AI ë¶„ì„ì„ í†µí•´ ê°ì§€ëœ ì¡°ì—° ì¸ë¬¼'
                    }
                ];
            }

            function displayDetectedFaces() {
                faceResults.innerHTML = '';
                
                detectedFaces.forEach(face => {
                    const faceCard = document.createElement('div');
                    faceCard.className = 'face-card';
                    
                    // ì‹¤ì œ ì–¼êµ´ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ í‘œì‹œ, ì—†ìœ¼ë©´ í”Œë ˆì´ìŠ¤í™€ë”
                    const faceImageHtml = face.faceImage 
                        ? `<img src="${face.faceImage}" alt="${face.name}" style="width: 100%; height: 200px; object-fit: cover; border-radius: 8px;">`
                        : `<div class="face-placeholder">ğŸ­</div>`;
                    
                    faceCard.innerHTML = `
                        ${faceImageHtml}
                        <h4>${face.name}</h4>
                        <div class="face-info">
                            <div>ì‹ ë¢°ë„: ${Math.round(face.confidence * 100)}%</div>
                            <div>ë“±ì¥ íšŸìˆ˜: ${face.appearances}íšŒ</div>
                            <div>ì²« ë“±ì¥: ${face.firstAppearance}</div>
                            <div>ì—­í• : ${face.role === 'main' ? 'ì£¼ì—°' : 'ì¡°ì—°'}</div>
                            ${face.age ? `<div>ë‚˜ì´: ${face.age}ì„¸</div>` : ''}
                            ${face.gender ? `<div>ì„±ë³„: ${face.gender === 'male' ? 'ë‚¨ì„±' : 'ì—¬ì„±'}</div>` : ''}
                            ${face.dominantExpression ? `<div>ì£¼ìš” í‘œì •: ${face.dominantExpression}</div>` : ''}
                        </div>
                        <div class="face-actions">
                            <button class="btn-edit" onclick="editFace(${face.id})">ìˆ˜ì •</button>
                            <button class="btn-upload" onclick="uploadFaceImage(${face.id})">ì´ë¯¸ì§€ ì—…ë¡œë“œ</button>
                            <button class="btn-delete" onclick="deleteFace(${face.id})">ì‚­ì œ</button>
                        </div>
                    `;
                    faceResults.appendChild(faceCard);
                });
            }

            async function generateFaceImages() {
                generateFaceImagesBtn.disabled = true;
                generateFaceImagesBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ìƒì„± ì¤‘...';

                try {
                    const selectedModelKey = mainModelSelect.value;
                    const selectedSubModel = subModelSelect.value;
                    
                    // ì´ë¯¸ì§€ ìƒì„±
                    for (let i = 0; i < detectedFaces.length; i++) {
                        const face = detectedFaces[i];
                        
                        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                        const progress = ((i + 1) / detectedFaces.length) * 100;
                        faceProgressFill.style.width = `${progress}%`;
                        faceProgressText.textContent = `ğŸ¬ ${face.name} ì‹¤ì œ ì˜ìƒì—ì„œ ì–¼êµ´ ì¶”ì¶œ ì¤‘... ${Math.round(progress)}%`;
                        
                        // AI ì„¤ëª… ê¸°ë°˜ ê³ í’ˆì§ˆ ì´ë¯¸ì§€ ìƒì„±
                        const generatedImage = await generateEnhancedFaceImage(face, selectedModelKey, selectedSubModel);
                        face.generatedImage = generatedImage;
                        
                        // UI ì—…ë°ì´íŠ¸
                        updateFaceCardWithImage(face);
                        
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }

                    downloadFaceGalleryBtn.style.display = 'inline-flex';
                    faceProgressText.textContent = 'âœ… ëª¨ë“  ë°°ìš° ì–¼êµ´ ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ!';
                    generateFaceImagesBtn.innerHTML = '<i class="fas fa-check"></i> ìƒì„± ì™„ë£Œ';
                    
                } catch (error) {
                    console.error('Face image generation error:', error);
                    faceProgressText.textContent = `âŒ ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`;
                    generateFaceImagesBtn.innerHTML = '<i class="fas fa-magic"></i> ì–¼êµ´ ì´ë¯¸ì§€ ìƒì„±';
                } finally {
                    generateFaceImagesBtn.disabled = false;
                }
            }

            async function generateEnhancedFaceImage(face, modelKey, subModel) {
                try {
                    // 1. AI ì´ë¯¸ì§€ ìƒì„± API ì‹œë„ (DALL-E, Stable Diffusion ë“±)
                    const aiGeneratedImage = await generateAIFaceImage(face, modelKey, subModel);
                    if (aiGeneratedImage) {
                        return aiGeneratedImage;
                    }

                    // 2. ì˜ìƒì—ì„œ ì‹¤ì œ ì–¼êµ´ í”„ë ˆì„ ì¶”ì¶œ ì‹œë„
                    const realFaceImage = await extractRealFaceFromVideo(face);
                    if (realFaceImage) {
                        return realFaceImage;
                    }

                    // 3. AI ë¬˜ì‚¬ ê¸°ë°˜ ì •êµí•œ ì¼ëŸ¬ìŠ¤íŠ¸ ìƒì„±
                    const descriptionPrompt = `${face.name}ì˜ ì™¸ëª¨ë¥¼ ë§¤ìš° ìƒì„¸íˆ ë¬˜ì‚¬í•´ì£¼ì„¸ìš”. 
                    
ë‚˜ì´ëŒ€, ì„±ë³„, í”¼ë¶€í†¤, í—¤ì–´ìŠ¤íƒ€ì¼, í—¤ì–´ì»¬ëŸ¬, ì–¼êµ´í˜•, ëˆˆ ëª¨ì–‘, ëˆˆì¹, ì½” í˜•íƒœ, ì…ìˆ , íŠ¹ì§•ì ì¸ ì™¸ëª¨ ë“±ì„ êµ¬ì²´ì ìœ¼ë¡œ ì„¤ëª…í•´ì£¼ì„¸ìš”.
ì˜ˆ: "25ì„¸ ì—¬ì„±, ë°ì€ í”¼ë¶€í†¤, ê¸´ ì›¨ì´ë¸Œ ê°ˆìƒ‰ ë¨¸ë¦¬, ê³„ë€í˜• ì–¼êµ´, í° ê°ˆìƒ‰ ëˆˆ, ë„í†°í•œ ì…ìˆ , ë¯¸ì†Œì§“ëŠ” í‘œì •"`;

                    const description = await callAIAPI(modelKey, subModel, descriptionPrompt);
                    
                    // AI ì„¤ëª… ê¸°ë°˜ ì‚¬ì‹¤ì  ì¼ëŸ¬ìŠ¤íŠ¸ ìƒì„±
                    return generateRealisticFaceIllustration(face, description);
                    
                } catch (error) {
                    console.error('Face image generation failed:', error);
                    // ëª¨ë“  ë°©ë²• ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ê³ í’ˆì§ˆ ì´ë¯¸ì§€ ìƒì„±
                    return generateEnhancedPlaceholderImage(face);
                }
            }

            async function generateAIFaceImage(face, modelKey, subModel) {
                try {
                    console.log(`AIë¡œ ${face.name}ì˜ ì–¼êµ´ ì´ë¯¸ì§€ ìƒì„± ì¤‘...`);
                    
                    // OpenAI DALL-E API ì‚¬ìš© (GPT ëª¨ë¸ ì„ íƒ ì‹œ)
                    if (modelKey === 'gpt') {
                        return await generateWithDALLE(face, subModel);
                    }
                    
                    // Stable Diffusion API ì‚¬ìš© (ë‹¤ë¥¸ ëª¨ë¸ë“¤)
                    return await generateWithStableDiffusion(face, modelKey, subModel);
                    
                } catch (error) {
                    console.error('AI image generation failed:', error);
                    return null;
                }
            }

            async function generateWithDALLE(face, subModel) {
                try {
                    const modelData = aiModels['gpt'];
                    if (!modelData.apiKey) {
                        throw new Error('OpenAI API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
                    }

                    // ì–¼êµ´ íŠ¹ì§• í”„ë¡¬í”„íŠ¸ ìƒì„±
                    const prompt = `Professional headshot portrait of ${face.name}, ${face.role === 'main' ? 'main character' : 'supporting character'}, ${face.description || 'attractive person'}, realistic digital art, high quality, detailed facial features, studio lighting, neutral background`;

                    const response = await fetch('https://api.openai.com/v1/images/generations', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${modelData.apiKey}`
                        },
                        body: JSON.stringify({
                            model: "dall-e-3",
                            prompt: prompt,
                            n: 1,
                            size: "1024x1024",
                            quality: "standard"
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`DALL-E API ì˜¤ë¥˜: ${response.statusText}`);
                    }

                    const data = await response.json();
                    if (data.data && data.data[0] && data.data[0].url) {
                        // ìƒì„±ëœ ì´ë¯¸ì§€ë¥¼ ìº”ë²„ìŠ¤ì— ë¡œë“œí•˜ê³  ë¦¬ì‚¬ì´ì¦ˆ
                        return await processGeneratedImage(data.data[0].url, face);
                    }
                    
                    return null;
                    
                } catch (error) {
                    console.error('DALL-E generation failed:', error);
                    return null;
                }
            }

            async function generateWithStableDiffusion(face, modelKey, subModel) {
                try {
                    // Stable Diffusion API í†µí•©ì€ ì—¬ê¸°ì— êµ¬í˜„
                    // í˜„ì¬ëŠ” ë” ì •êµí•œ Canvas ê¸°ë°˜ ìƒì„±ìœ¼ë¡œ ëŒ€ì²´
                    console.log('Stable Diffusion APIëŠ” í˜„ì¬ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
                    return null;
                    
                } catch (error) {
                    console.error('Stable Diffusion generation failed:', error);
                    return null;
                }
            }

            async function processGeneratedImage(imageUrl, face) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = 300;
                        canvas.height = 400;
                        const ctx = canvas.getContext('2d');
                        
                        // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜
                        const gradient = ctx.createLinearGradient(0, 0, 300, 400);
                        gradient.addColorStop(0, '#f8f9fa');
                        gradient.addColorStop(1, '#e9ecef');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 300, 400);
                        
                        // ì´ë¯¸ì§€ë¥¼ ì›í˜•ìœ¼ë¡œ í´ë¦¬í•‘
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(150, 200, 120, 0, 2 * Math.PI);
                        ctx.clip();
                        
                        // AI ìƒì„± ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                        const imgSize = Math.min(img.width, img.height);
                        const srcX = (img.width - imgSize) / 2;
                        const srcY = (img.height - imgSize) / 2;
                        
                        ctx.drawImage(img, srcX, srcY, imgSize, imgSize, 30, 80, 240, 240);
                        ctx.restore();
                        
                        // ì›í˜• í…Œë‘ë¦¬
                        ctx.strokeStyle = '#007b6d';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(150, 200, 120, 0, 2 * Math.PI);
                        ctx.stroke();
                        
                        // ì •ë³´ í…ìŠ¤íŠ¸
                        ctx.fillStyle = '#2d3436';
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(face.name, 150, 50);
                        
                        ctx.font = '14px Arial';
                        ctx.fillStyle = '#636e72';
                        ctx.fillText(`${face.role === 'main' ? 'ì£¼ì—°' : 'ì¡°ì—°'} â€¢ AI ìƒì„±`, 150, 350);
                        ctx.fillText(`ì‹ ë¢°ë„ ${Math.round(face.confidence * 100)}% â€¢ ${face.appearances}íšŒ ë“±ì¥`, 150, 370);
                        
                        resolve(canvas.toDataURL('image/jpeg', 0.9));
                    };
                    
                    img.onerror = () => {
                        console.error('Generated image loading failed');
                        resolve(null);
                    };
                    
                    img.src = imageUrl;
                });
            }

            function generateRealisticFaceIllustration(face, description) {
                const canvas = document.createElement('canvas');
                canvas.width = 300;
                canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // AI ì„¤ëª… íŒŒì‹±
                const features = parseAIDescription(description);
                
                // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜ (ì„±ë³„ì— ë”°ë¼ ìƒ‰ìƒ ì¡°ì •)
                const colorScheme = features.gender === 'female' 
                    ? ['#ffeaa7', '#fab1a0', '#e17055'] 
                    : ['#74b9ff', '#0984e3', '#6c5ce7'];
                
                const gradient = ctx.createRadialGradient(150, 200, 50, 150, 200, 200);
                gradient.addColorStop(0, colorScheme[0]);
                gradient.addColorStop(0.7, colorScheme[1]);
                gradient.addColorStop(1, colorScheme[2]);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 300, 400);
                
                // ì–¼êµ´ ë² ì´ìŠ¤ (í”¼ë¶€í†¤ ë°˜ì˜)
                const skinColors = {
                    light: '#ffeaa7',
                    medium: '#fab1a0',
                    dark: '#e17055',
                    default: '#ffeaa7'
                };
                const skinColor = skinColors[features.skinTone] || skinColors.default;
                
                ctx.beginPath();
                if (features.faceShape === 'round') {
                    ctx.arc(150, 180, 85, 0, 2 * Math.PI);
                } else if (features.faceShape === 'square') {
                    ctx.roundRect(80, 110, 140, 150, 20);
                } else { // oval or default
                    ctx.ellipse(150, 180, 75, 95, 0, 0, 2 * Math.PI);
                }
                ctx.fillStyle = skinColor;
                ctx.fill();
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // í—¤ì–´ìŠ¤íƒ€ì¼ ê·¸ë¦¬ê¸°
                drawHair(ctx, features);
                
                // ëˆˆ ê·¸ë¦¬ê¸° (í¬ê¸°ì™€ ëª¨ì–‘ ë°˜ì˜)
                drawEyes(ctx, features);
                
                // ëˆˆì¹ ê·¸ë¦¬ê¸°
                drawEyebrows(ctx, features);
                
                // ì½” ê·¸ë¦¬ê¸°
                drawNose(ctx, features);
                
                // ì…ìˆ  ê·¸ë¦¬ê¸°
                drawLips(ctx, features);
                
                // í‘œì • ë°˜ì˜ (ë¯¸ì†Œ, ì§„ì§€í•¨ ë“±)
                if (features.expression === 'smile') {
                    // ì›ƒëŠ” ì… ëª¨ì–‘ìœ¼ë¡œ ìˆ˜ì •
                    ctx.beginPath();
                    ctx.arc(150, 205, 12, 0, Math.PI);
                    ctx.strokeStyle = '#e17055';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // í…ìŠ¤íŠ¸ ì •ë³´
                ctx.fillStyle = 'white';
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeText(face.name, 150, 320);
                ctx.fillText(face.name, 150, 320);
                
                ctx.font = '16px Arial';
                ctx.fillText(`${face.role === 'main' ? 'ì£¼ì—°' : 'ì¡°ì—°'} â€¢ AI ì¼ëŸ¬ìŠ¤íŠ¸`, 150, 345);
                
                ctx.font = '14px Arial';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(`${features.age || '??'}ì„¸ ${features.gender || '??'} â€¢ ì‹ ë¢°ë„ ${Math.round(face.confidence * 100)}%`, 150, 365);
                ctx.fillText(`ë“±ì¥ ${face.appearances}íšŒ â€¢ ${face.firstAppearance}`, 150, 385);
                
                return canvas.toDataURL('image/png');
            }

            function parseAIDescription(description) {
                const features = {
                    age: null,
                    gender: null,
                    skinTone: 'light',
                    hairStyle: 'short',
                    hairColor: 'black',
                    faceShape: 'oval',
                    eyeSize: 'medium',
                    eyeColor: 'brown',
                    expression: 'neutral'
                };
                
                if (!description) return features;
                
                const desc = description.toLowerCase();
                
                // ë‚˜ì´ ì¶”ì¶œ
                const ageMatch = desc.match(/(\d+)ì„¸|(\d+)ëŒ€/);
                if (ageMatch) {
                    features.age = ageMatch[1] || (ageMatch[2] ? parseInt(ageMatch[2]) * 10 + 5 : null);
                }
                
                // ì„±ë³„ ì¶”ì¶œ
                if (desc.includes('ë‚¨ì„±') || desc.includes('ë‚¨ì')) features.gender = 'male';
                if (desc.includes('ì—¬ì„±') || desc.includes('ì—¬ì')) features.gender = 'female';
                
                // í”¼ë¶€í†¤
                if (desc.includes('ë°ì€') || desc.includes('í•˜ì–€')) features.skinTone = 'light';
                if (desc.includes('ì–´ë‘ìš´') || desc.includes('ê²€ì€')) features.skinTone = 'dark';
                if (desc.includes('ì¤‘ê°„') || desc.includes('ë³´í†µ')) features.skinTone = 'medium';
                
                // í—¤ì–´ìŠ¤íƒ€ì¼
                if (desc.includes('ê¸´')) features.hairStyle = 'long';
                if (desc.includes('ì§§ì€')) features.hairStyle = 'short';
                if (desc.includes('ì›¨ì´ë¸Œ') || desc.includes('ê³±ìŠ¬')) features.hairStyle = 'wavy';
                
                // í—¤ì–´ì»¬ëŸ¬
                if (desc.includes('ê°ˆìƒ‰')) features.hairColor = 'brown';
                if (desc.includes('ê¸ˆìƒ‰') || desc.includes('ë¸”ë¡ ë“œ')) features.hairColor = 'blonde';
                if (desc.includes('ë¹¨ê°„') || desc.includes('ë¹¨ê°•')) features.hairColor = 'red';
                
                // ì–¼êµ´í˜•
                if (desc.includes('ë‘¥ê·¼') || desc.includes('ì›í˜•')) features.faceShape = 'round';
                if (desc.includes('ê°ì§„') || desc.includes('ì‚¬ê°')) features.faceShape = 'square';
                
                // ëˆˆ í¬ê¸°
                if (desc.includes('í° ëˆˆ') || desc.includes('ì»¤ë‹¤ë€ ëˆˆ')) features.eyeSize = 'large';
                if (desc.includes('ì‘ì€ ëˆˆ')) features.eyeSize = 'small';
                
                // í‘œì •
                if (desc.includes('ë¯¸ì†Œ') || desc.includes('ì›ƒ')) features.expression = 'smile';
                if (desc.includes('ì§„ì§€') || desc.includes('ì‹¬ê°')) features.expression = 'serious';
                
                return features;
            }

            function drawHair(ctx, features) {
                const hairColors = {
                    black: '#2d3436',
                    brown: '#6c5ce7',
                    blonde: '#fdcb6e',
                    red: '#e17055'
                };
                
                ctx.fillStyle = hairColors[features.hairColor] || hairColors.black;
                
                if (features.hairStyle === 'long') {
                    // ê¸´ ë¨¸ë¦¬
                    ctx.beginPath();
                    ctx.ellipse(150, 120, 90, 40, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // ë¨¸ë¦¬ì¹´ë½ ì˜†ë©´
                    ctx.beginPath();
                    ctx.ellipse(100, 160, 25, 60, -0.3, 0, 2 * Math.PI);
                    ctx.ellipse(200, 160, 25, 60, 0.3, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    // ì§§ì€ ë¨¸ë¦¬
                    ctx.beginPath();
                    ctx.ellipse(150, 130, 80, 50, 0, 0, Math.PI);
                    ctx.fill();
                }
            }

            function drawEyes(ctx, features) {
                const eyeSize = features.eyeSize === 'large' ? 12 : features.eyeSize === 'small' ? 6 : 9;
                
                // ëˆˆ í°ì
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.ellipse(130, 160, eyeSize, eyeSize * 0.7, 0, 0, 2 * Math.PI);
                ctx.ellipse(170, 160, eyeSize, eyeSize * 0.7, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // ëˆˆë™ì
                const eyeColors = {
                    brown: '#8b4513',
                    blue: '#4169e1',
                    green: '#228b22',
                    black: '#000000'
                };
                ctx.fillStyle = eyeColors[features.eyeColor] || eyeColors.brown;
                ctx.beginPath();
                ctx.ellipse(130, 160, eyeSize * 0.6, eyeSize * 0.6, 0, 0, 2 * Math.PI);
                ctx.ellipse(170, 160, eyeSize * 0.6, eyeSize * 0.6, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // ëˆˆë™ì í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.ellipse(132, 158, 2, 2, 0, 0, 2 * Math.PI);
                ctx.ellipse(172, 158, 2, 2, 0, 0, 2 * Math.PI);
                ctx.fill();
            }

            function drawEyebrows(ctx, features) {
                ctx.strokeStyle = '#2d3436';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                // ì™¼ìª½ ëˆˆì¹
                ctx.beginPath();
                ctx.moveTo(115, 145);
                ctx.quadraticCurveTo(130, 140, 145, 145);
                ctx.stroke();
                
                // ì˜¤ë¥¸ìª½ ëˆˆì¹
                ctx.beginPath();
                ctx.moveTo(155, 145);
                ctx.quadraticCurveTo(170, 140, 185, 145);
                ctx.stroke();
            }

            function drawNose(ctx, features) {
                ctx.strokeStyle = '#fab1a0';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(150, 170);
                ctx.lineTo(145, 185);
                ctx.moveTo(150, 185);
                ctx.lineTo(155, 185);
                ctx.stroke();
            }

            function drawLips(ctx, features) {
                ctx.fillStyle = '#e17055';
                
                if (features.expression === 'smile') {
                    // ì›ƒëŠ” ì…
                    ctx.beginPath();
                    ctx.arc(150, 200, 15, 0, Math.PI);
                    ctx.fill();
                } else {
                    // ì¼ë°˜ ì…
                    ctx.beginPath();
                    ctx.ellipse(150, 200, 12, 6, 0, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            async function extractRealFaceFromVideo(face) {
                try {
                    console.log(`${face.name}ì˜ ì‹¤ì œ ì–¼êµ´ ì¶”ì¶œ ì¤‘...`);
                    
                    // ì˜ìƒì—ì„œ í•´ë‹¹ ì‹œê°„ëŒ€ì˜ í”„ë ˆì„ ì¶”ì¶œ
                    const frameImage = await captureVideoFrame(face.firstAppearance);
                    if (!frameImage) {
                        return null;
                    }

                    // í”„ë ˆì„ì—ì„œ ì–¼êµ´ ì˜ì—­ ê°ì§€ ë° ì¶”ì¶œ
                    const faceImage = await detectAndCropFace(frameImage, face);
                    
                    return faceImage;
                    
                } catch (error) {
                    console.error('Real face extraction failed:', error);
                    return null;
                }
            }

            async function captureVideoFrame(timeString) {
                return new Promise((resolve) => {
                    try {
                        // ì‹œê°„ ë¬¸ìì—´ì„ ì´ˆë¡œ ë³€í™˜ (00:02:15 -> 135ì´ˆ)
                        const timeParts = timeString.split(':');
                        const timeInSeconds = parseInt(timeParts[0]) * 3600 + 
                                            parseInt(timeParts[1]) * 60 + 
                                            parseInt(timeParts[2]);

                        // ë¹„ë””ì˜¤ ìš”ì†Œ ìƒì„±
                        const video = document.createElement('video');
                        video.src = URL.createObjectURL(uploadedFile);
                        video.crossOrigin = 'anonymous';
                        video.muted = true;

                        video.addEventListener('loadedmetadata', () => {
                            // ì§€ì •ëœ ì‹œê°„ìœ¼ë¡œ ì´ë™
                            video.currentTime = Math.min(timeInSeconds, video.duration - 1);
                        });

                        video.addEventListener('seeked', () => {
                            try {
                                // ìº”ë²„ìŠ¤ì— í˜„ì¬ í”„ë ˆì„ ê·¸ë¦¬ê¸°
                                const canvas = document.createElement('canvas');
                                canvas.width = video.videoWidth;
                                canvas.height = video.videoHeight;
                                const ctx = canvas.getContext('2d');
                                
                                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                                
                                // ì´ë¯¸ì§€ ë°ì´í„° ë°˜í™˜
                                const imageData = canvas.toDataURL('image/jpeg', 0.8);
                                
                                // ë©”ëª¨ë¦¬ ì •ë¦¬
                                URL.revokeObjectURL(video.src);
                                
                                resolve(imageData);
                                
                            } catch (error) {
                                console.error('Frame capture error:', error);
                                resolve(null);
                            }
                        });

                        video.addEventListener('error', () => {
                            console.error('Video loading error');
                            resolve(null);
                        });

                    } catch (error) {
                        console.error('Video frame capture failed:', error);
                        resolve(null);
                    }
                });
            }

            async function detectAndCropFace(frameImage, face) {
                try {
                    // í”„ë ˆì„ ì´ë¯¸ì§€ë¥¼ ìº”ë²„ìŠ¤ì— ë¡œë“œ
                    const img = new Image();
                    img.src = frameImage;
                    
                    return new Promise((resolve) => {
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // ì›ë³¸ ì´ë¯¸ì§€ í¬ê¸°
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            
                            // ë‹¤ì¤‘ ì–¼êµ´ ì˜ì—­ ì¶”ì • (ì—¬ëŸ¬ ìœ„ì¹˜ì—ì„œ ì‹œë„)
                            const faceRegions = [
                                // ì¤‘ì•™ ìƒë‹¨ (ì£¼ì¸ê³µ ìœ„ì¹˜)
                                { 
                                    x: img.width * 0.35, 
                                    y: img.height * 0.1, 
                                    width: img.width * 0.3, 
                                    height: img.height * 0.4 
                                },
                                // ì¢Œì¸¡ ìƒë‹¨
                                { 
                                    x: img.width * 0.1, 
                                    y: img.height * 0.1, 
                                    width: img.width * 0.25, 
                                    height: img.height * 0.35 
                                },
                                // ìš°ì¸¡ ìƒë‹¨
                                { 
                                    x: img.width * 0.65, 
                                    y: img.height * 0.1, 
                                    width: img.width * 0.25, 
                                    height: img.height * 0.35 
                                },
                                // ì¤‘ì•™ ì¤‘ê°„
                                { 
                                    x: img.width * 0.3, 
                                    y: img.height * 0.25, 
                                    width: img.width * 0.4, 
                                    height: img.height * 0.4 
                                }
                            ];

                            // ì—­í• ì— ë”°ë¼ ìš°ì„ ìˆœìœ„ ê²°ì •
                            const selectedRegion = face.role === 'main' ? faceRegions[0] : faceRegions[Math.floor(Math.random() * faceRegions.length)];
                            
                            const faceWidth = Math.min(300, selectedRegion.width);
                            const faceHeight = Math.min(400, selectedRegion.height);
                            const faceX = selectedRegion.x;
                            const faceY = selectedRegion.y;
                            
                            // ì–¼êµ´ ì˜ì—­ ì¶”ì¶œ
                            const faceCanvas = document.createElement('canvas');
                            faceCanvas.width = 300;
                            faceCanvas.height = 400;
                            const faceCtx = faceCanvas.getContext('2d');
                            
                            // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜
                            const gradient = faceCtx.createLinearGradient(0, 0, 300, 400);
                            gradient.addColorStop(0, '#f8f9fa');
                            gradient.addColorStop(1, '#e9ecef');
                            faceCtx.fillStyle = gradient;
                            faceCtx.fillRect(0, 0, 300, 400);
                            
                            // ì¶”ì¶œëœ ì–¼êµ´ ì˜ì—­ì„ ì¤‘ì•™ì— ë°°ì¹˜ (ë‘¥ê·¼ ëª¨ì„œë¦¬ íš¨ê³¼)
                            faceCtx.save();
                            
                            // ë‘¥ê·¼ ì‚¬ê°í˜• í´ë¦¬í•‘ ê²½ë¡œ ìƒì„±
                            const cornerRadius = 15;
                            faceCtx.beginPath();
                            drawRoundedRect(faceCtx, 25, 50, 250, 300, cornerRadius);
                            faceCtx.clip();
                            
                            // ì–¼êµ´ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                            faceCtx.drawImage(
                                canvas, 
                                faceX, faceY, faceWidth, faceHeight,
                                25, 50, 250, 300
                            );
                            
                            faceCtx.restore();
                            
                            // ë‘¥ê·¼ í…Œë‘ë¦¬ ì¶”ê°€
                            faceCtx.strokeStyle = '#007b6d';
                            faceCtx.lineWidth = 3;
                            faceCtx.beginPath();
                            drawRoundedRect(faceCtx, 25, 50, 250, 300, cornerRadius);
                            faceCtx.stroke();
                            
                            // ê·¸ë¦¼ì íš¨ê³¼
                            faceCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                            faceCtx.shadowBlur = 10;
                            faceCtx.shadowOffsetX = 2;
                            faceCtx.shadowOffsetY = 2;
                            
                            // ì •ë³´ í…ìŠ¤íŠ¸ ì¶”ê°€
                            faceCtx.fillStyle = '#2d3436';
                            faceCtx.font = 'bold 18px Arial';
                            faceCtx.textAlign = 'center';
                            faceCtx.fillText(face.name, 150, 30);
                            
                            faceCtx.font = '14px Arial';
                            faceCtx.fillStyle = '#636e72';
                            faceCtx.fillText(`${face.role === 'main' ? 'ì£¼ì—°' : 'ì¡°ì—°'} â€¢ ì‹ ë¢°ë„ ${Math.round(face.confidence * 100)}%`, 150, 380);
                            faceCtx.fillText(`ë“±ì¥ ${face.appearances}íšŒ â€¢ ${face.firstAppearance}`, 150, 395);
                            
                            resolve(faceCanvas.toDataURL('image/jpeg', 0.9));
                        };
                        
                        img.onerror = () => {
                            console.error('Image loading failed');
                            resolve(null);
                        };
                    });
                    
                } catch (error) {
                    console.error('Face detection and crop failed:', error);
                    return null;
                }
            }



            function generateDetailedPlaceholderImage(face, description) {
                const canvas = document.createElement('canvas');
                canvas.width = 300;
                canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // ì‚¬ì‹¤ì ì¸ ê·¸ë¼ë°ì´ì…˜ ë°°ê²½
                const gradient = ctx.createRadialGradient(150, 200, 50, 150, 200, 200);
                gradient.addColorStop(0, '#f8f9fa');
                gradient.addColorStop(0.7, '#e9ecef');
                gradient.addColorStop(1, '#dee2e6');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 300, 400);
                
                // ì–¼êµ´ ì˜ì—­ í‘œì‹œ
                ctx.beginPath();
                ctx.ellipse(150, 180, 80, 100, 0, 0, 2 * Math.PI);
                ctx.fillStyle = '#ffeaa7';
                ctx.fill();
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ëˆˆ ê·¸ë¦¬ê¸°
                ctx.beginPath();
                ctx.ellipse(130, 160, 8, 6, 0, 0, 2 * Math.PI);
                ctx.ellipse(170, 160, 8, 6, 0, 0, 2 * Math.PI);
                ctx.fillStyle = '#2d3436';
                ctx.fill();
                
                // ì½” ê·¸ë¦¬ê¸°
                ctx.beginPath();
                ctx.moveTo(150, 170);
                ctx.lineTo(145, 185);
                ctx.lineTo(155, 185);
                ctx.closePath();
                ctx.fillStyle = '#fab1a0';
                ctx.fill();
                
                // ì… ê·¸ë¦¬ê¸°
                ctx.beginPath();
                ctx.ellipse(150, 200, 15, 8, 0, 0, Math.PI);
                ctx.fillStyle = '#e17055';
                ctx.fill();
                
                // í…ìŠ¤íŠ¸ ì •ë³´
                ctx.fillStyle = '#2d3436';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(face.name, 150, 320);
                
                ctx.font = '14px Arial';
                ctx.fillStyle = '#636e72';
                ctx.fillText(`${face.role === 'main' ? 'ì£¼ì—°' : 'ì¡°ì—°'} â€¢ ì‹ ë¢°ë„ ${Math.round(face.confidence * 100)}%`, 150, 340);
                ctx.fillText(`ë“±ì¥ ${face.appearances}íšŒ â€¢ ì²« ë“±ì¥ ${face.firstAppearance}`, 150, 360);
                
                // AI ì„¤ëª… ì¶”ê°€ (ìš”ì•½)
                if (description && description.length > 0) {
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#74b9ff';
                    const shortDesc = description.substring(0, 50) + '...';
                    ctx.fillText('AI ë¶„ì„: ' + shortDesc, 150, 380);
                }
                
                return canvas.toDataURL('image/png');
            }

            function generateEnhancedPlaceholderImage(face) {
                const canvas = document.createElement('canvas');
                canvas.width = 300;
                canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // ì—­í• ì— ë”°ë¥¸ ìƒ‰ìƒ í…Œë§ˆ
                const colorTheme = face.role === 'main' 
                    ? { primary: '#667eea', secondary: '#764ba2', accent: '#f093fb' }
                    : { primary: '#4ecdc4', secondary: '#44a08d', accent: '#96fbc4' };
                
                // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜
                const gradient = ctx.createLinearGradient(0, 0, 300, 400);
                gradient.addColorStop(0, colorTheme.primary);
                gradient.addColorStop(0.5, colorTheme.secondary);
                gradient.addColorStop(1, colorTheme.accent);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 300, 400);
                
                // ì˜¤ë²„ë ˆì´ íŒ¨í„´
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    ctx.arc(Math.random() * 300, Math.random() * 400, Math.random() * 30, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // ì¤‘ì•™ ì•„ì´ì½˜
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = '60px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ­', 150, 180);
                
                // ì´ë¦„
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeText(face.name, 150, 250);
                ctx.fillText(face.name, 150, 250);
                
                // ì—­í•  ì •ë³´
                ctx.font = '16px Arial';
                ctx.fillText(`${face.role === 'main' ? 'ì£¼ì—° ë°°ìš°' : 'ì¡°ì—° ë°°ìš°'}`, 150, 280);
                
                // ìƒì„¸ ì •ë³´
                ctx.font = '14px Arial';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(`ì‹ ë¢°ë„: ${Math.round(face.confidence * 100)}%`, 150, 310);
                ctx.fillText(`ë“±ì¥ íšŸìˆ˜: ${face.appearances}íšŒ`, 150, 330);
                ctx.fillText(`ì²« ë“±ì¥: ${face.firstAppearance}`, 150, 350);
                
                // AI ìƒì„± í‘œì‹œ
                ctx.font = '12px Arial';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillText('AI ë¶„ì„ ê²°ê³¼', 150, 380);
                
                return canvas.toDataURL('image/png');
            }

            function updateFaceCardWithImage(face) {
                const faceCards = faceResults.querySelectorAll('.face-card');
                const targetCard = Array.from(faceCards).find(card => 
                    card.querySelector('h4').textContent === face.name
                );
                
                if (targetCard) {
                    const placeholder = targetCard.querySelector('.face-placeholder');
                    placeholder.innerHTML = `<img src="${face.generatedImage}" alt="${face.name}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">`;
                    placeholder.style.background = 'none';
                }
            }

            function downloadFaceGallery() {
                const zip = new JSZip();
                const promises = [];

                detectedFaces.forEach(face => {
                    if (face.generatedImage) {
                        // Base64 ì´ë¯¸ì§€ë¥¼ blobìœ¼ë¡œ ë³€í™˜
                        const base64Data = face.generatedImage.split(',')[1];
                        const byteCharacters = atob(base64Data);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const blob = new Blob([byteArray], { type: 'image/png' });
                        
                        zip.file(`${face.name}_${face.role}.png`, blob);
                    }
                });

                // ë©”íƒ€ë°ì´í„° íŒŒì¼ ì¶”ê°€
                const metadata = {
                    analysisDate: new Date().toISOString(),
                    totalFaces: detectedFaces.length,
                    faces: detectedFaces.map(face => ({
                        name: face.name,
                        role: face.role,
                        confidence: face.confidence,
                        appearances: face.appearances,
                        firstAppearance: face.firstAppearance
                    }))
                };
                
                zip.file('face_analysis_metadata.json', JSON.stringify(metadata, null, 2));

                zip.generateAsync({ type: 'blob' }).then(content => {
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `face_gallery_${new Date().toISOString().split('T')[0]}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
            }

            // Global functions for face card actions
            window.editFace = function(faceId) {
                const face = detectedFaces.find(f => f.id === faceId);
                if (face) {
                    const newName = prompt('ë°°ìš° ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:', face.name);
                    if (newName && newName.trim()) {
                        face.name = newName.trim();
                        displayDetectedFaces();
                        
                        // ì´ë¯¸ì§€ê°€ ìƒì„±ë˜ì–´ ìˆë‹¤ë©´ ë‹¤ì‹œ í‘œì‹œ
                        if (face.generatedImage) {
                            updateFaceCardWithImage(face);
                        }
                    }
                }
            };

            window.uploadFaceImage = function(faceId) {
                const face = detectedFaces.find(f => f.id === faceId);
                if (!face) return;

                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.style.display = 'none';
                
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            // ì—…ë¡œë“œëœ ì´ë¯¸ì§€ë¥¼ í”„ë¡œì„¸ì‹±
                            processUploadedFaceImage(event.target.result, face);
                        };
                        reader.readAsDataURL(file);
                    }
                    document.body.removeChild(fileInput);
                });
                
                document.body.appendChild(fileInput);
                fileInput.click();
            };

            function processUploadedFaceImage(imageDataUrl, face) {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 300;
                    canvas.height = 400;
                    const ctx = canvas.getContext('2d');
                    
                    // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜
                    const gradient = ctx.createLinearGradient(0, 0, 300, 400);
                    gradient.addColorStop(0, '#f8f9fa');
                    gradient.addColorStop(1, '#e9ecef');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 300, 400);
                    
                    // ì´ë¯¸ì§€ë¥¼ ì›í˜•ìœ¼ë¡œ í´ë¦¬í•‘
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(150, 200, 120, 0, 2 * Math.PI);
                    ctx.clip();
                    
                    // ì—…ë¡œë“œëœ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (ë¹„ìœ¨ ìœ ì§€í•˜ë©° ì¤‘ì•™ì— ë°°ì¹˜)
                    const imgSize = Math.min(img.width, img.height);
                    const srcX = (img.width - imgSize) / 2;
                    const srcY = (img.height - imgSize) / 2;
                    
                    ctx.drawImage(img, srcX, srcY, imgSize, imgSize, 30, 80, 240, 240);
                    ctx.restore();
                    
                    // ì›í˜• í…Œë‘ë¦¬
                    ctx.strokeStyle = '#17a2b8';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(150, 200, 120, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    // ì •ë³´ í…ìŠ¤íŠ¸
                    ctx.fillStyle = '#2d3436';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(face.name, 150, 50);
                    
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#636e72';
                    ctx.fillText(`${face.role === 'main' ? 'ì£¼ì—°' : 'ì¡°ì—°'} â€¢ ì‚¬ìš©ì ì—…ë¡œë“œ`, 150, 350);
                    ctx.fillText(`ì‹ ë¢°ë„ ${Math.round(face.confidence * 100)}% â€¢ ${face.appearances}íšŒ ë“±ì¥`, 150, 370);
                    
                    // ì—…ë¡œë“œ ì™„ë£Œ ë©”ì‹œì§€
                    addMessage('ai', `âœ… ${face.name}ì˜ ì–¼êµ´ ì´ë¯¸ì§€ê°€ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!`);
                    
                    // ì´ë¯¸ì§€ ì €ì¥ ë° í‘œì‹œ
                    face.generatedImage = canvas.toDataURL('image/jpeg', 0.9);
                    updateFaceCardWithImage(face);
                };
                img.src = imageDataUrl;
            }

            window.deleteFace = function(faceId) {
                if (confirm('ì´ ë°°ìš°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    detectedFaces = detectedFaces.filter(f => f.id !== faceId);
                    displayDetectedFaces();
                    
                    // ì´ë¯¸ì§€ë“¤ ë‹¤ì‹œ í‘œì‹œ
                    detectedFaces.forEach(face => {
                        if (face.generatedImage) {
                            updateFaceCardWithImage(face);
                        }
                    });
                }
            };

            // --- Initial Setup ---
            loadSavedApiKeys();
            loadStorageSettings();
            loadChats();
            renderCompletedShorts();
            initializeMainModels();
            updateSubModels();
            updateProcessButtonState();
        });
    </script>
</body>
</html>